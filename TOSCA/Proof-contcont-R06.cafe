require ProofContCont Proof-contcont.cafe

--> *********************************************************************************
--> (2) inv(S) and wfs(S) and cont(S) and not final(S) implies cont(SS) or final(SS).
--> *********************************************************************************

--> ************************************************************************
-->  ctrans [R05]:
-->     < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->  => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->     if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************
select ProofContCont .
-- When R05 can be applied to the state S:
--> **************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rules.
--> **************************************************************************
:goal {
  eq contcont(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ***********************************************************
--> Step 2-2: Split the most general case for a rule into cases
-->  where the condition of the rule does or does not hold.
--> ***********************************************************
-- The condition of R05 does or does not hold for the node of idND.
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
-- Case 1: When the condition of R05 holds for the node of idND:
--> ***************************************************************
--> Step 2-3: Split the rule applied case into cases
-->  where predicate final does or does not hold in the next state.
--> ***************************************************************
-- We know that final(S') never holds in this case.
--> ***************************************************************
--> Step 2-4: Think which rule can be applied to the next state
-->  and repeat case splitting similarly as Step 1-3, 1-4, and 1-5.
--> ***************************************************************
-- The next rule should be R06 for the resource of idCP.
--> ***********************************************************
--> Step 1-5: When there is a dangling link, split the case
-->  into cases where the linked object does or does not exist.
--> ***********************************************************
-- The node of the capability of idCP does or does not exist.
:csp {
  eq existND(sND,idND) = false .
  eq sND = (node(tnd,idND,snd) sND') .
}
-- Case 1-1: The node of the capability of idCP does not exist:
:apply (rd) -- 1-1
-- Case 1-2: The node of the capability of idCP exists:
--> ****************************************************
--> Step 1-4: Split the first rule case into cases where
-->  the condition of the rule does or does not hold.
--> ****************************************************
-- The condition of R06 does or does not hold for the requirement of idRQ.
:csp {
  eq snd = initial .
  eq snd = created .
  eq snd = started .
}
-- Case 1-2-1: The node is initial:
:apply (rd) -- 1-2-1
-- Case 1-2-2: The node is created:
:apply (rd) -- 1-2-2
-- Case 1-2-3: The node is started:
:apply (rd) -- 1-2-3
-- Case 2: When the condition of R05 does not hold for the node of idND:
:apply (rd) -- 2
show proof
select
