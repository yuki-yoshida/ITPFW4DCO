require Proof Proof.cafe

--> ***************************
--> (5) init(S) implies inv(S).
--> (6) inv(S) implies inv(SS).
--> ***************************

module! ProofInv {
  pr(PROOFbase)
  pr(STATERules)
  pred invS : State

  pred initinv : State
  eq initinv(S:State)
     = init(S) implies invS(S) .

  pred invinv : State
  eq invinv(S:State)
     = not (S =(*,1)=>+ SS:State if CC:Bool suchThat
            not ((CC implies
                  (wfs(S) and inv(S) and invS(S) implies invS(SS))) == true)
     	   { S => SS !! CC ! wfs(S) ! inv(S) ! invS(S) ! invS(SS) }) .
}

--> ****************************************************************************
--> Proof of inv-ifOpenMsgThenCPActivated.
-->  eq inv-ifOpenMsgThenCPActivated(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifOpenMsgThenCPInStates(MP,SetCP,(open available)) .
--> ****************************************************************************
--> Proof of inv(S) implies inv(SS)
module! Proofinv-ifOpenMsgThenCPActivated {
  pr(ProofInv)
  eq invS(S:State) = inv-ifOpenMsgThenCPActivated(S) .

  var IDND : NDID
  var IDCP : CPID
  var TRL : RLType
  var SetCP : SetOfCapability
  vars SCP1 SCP2 : CPState
  var STCP : SetOfCPState
  var MP : PoolOfMsg

  -- If (SCP2 \in STCP) or not (SCP1 \in STCP),
  -- then ifOpenMsgThenCPInStates keeps to hold.
  ceq [tosca-lemma1112 :nonexec]:
      (ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP) and
       ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP2,IDND) SetCP),STCP))
      = ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP)
      if (SCP2 \in STCP) or not (SCP1 \in STCP) .

}

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
select Proofinv-ifOpenMsgThenCPActivated .
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:ctf {
  eq mp = empMsg .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:init [tosca-lemma1112] by {
  MP:PoolOfMsg          <- mp ;
  TRL:RLType            <- hostedOn ;
  IDCP:CPID             <- idCP ;
  SCP1:CPState          <- closed ;
  SCP2:CPState          <- available ;
  IDND:NDID             <- idND ;
  SetCP:SetOfCapability <- sCP ;
  STCP:SetOfCPState     <- (open available) ;
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND2) sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:init [tosca-lemma1112] by {
  MP:PoolOfMsg          <- mp ;
  TRL:RLType            <- dependsOn ;
  IDCP:CPID             <- idCP ;
  SCP1:CPState          <- closed ;
  SCP2:CPState          <- open ;
  IDND:NDID             <- idND ;
  SetCP:SetOfCapability <- sCP ;
  STCP:SetOfCPState     <- (open available) ;
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:init [tosca-lemma1112] by {
  MP:PoolOfMsg          <- mp ;
  TRL:RLType            <- dependsOn ;
  IDCP:CPID             <- idCP ;
  SCP1:CPState          <- open ;
  SCP2:CPState          <- available ;
  IDND:NDID             <- idND ;
  SetCP:SetOfCapability <- sCP ;
  STCP:SetOfCPState     <- (open available) ;
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND2) sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND2) sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:init [tosca-lemma1112] by {
  MP:PoolOfMsg          <- mp ;
  TRL:RLType            <- connectsTo ;
  IDCP:CPID             <- idCP ;
  SCP1:CPState          <- closed ;
  SCP2:CPState          <- open ;
  IDND:NDID             <- idND ;
  SetCP:SetOfCapability <- sCP ;
  STCP:SetOfCPState     <- (open available) ;
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:init [tosca-lemma1112] by {
  MP:PoolOfMsg          <- mp ;
  TRL:RLType            <- connectsTo ;
  IDCP:CPID             <- idCP ;
  SCP1:CPState          <- open ;
  SCP2:CPState          <- available ;
  IDND:NDID             <- idND ;
  SetCP:SetOfCapability <- sCP ;
  STCP:SetOfCPState     <- (open available) ;
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof

--> *********************************************************************
--> Proof of inv-ifCPClosedThenRQUnbound.
-->  eq inv-ifCPClosedThenRQUnbound(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .
--> *********************************************************************
--> This proof requires inv-ifOpenMsgThenCPActivated.
--> Proof of inv(S) implies inv(SS)
module! Proofinv-ifCPClosedThenRQUnbound {
  pr(ProofInv)
  eq invS(S:State) = inv-ifCPClosedThenRQUnbound(S) .

  var SetCP : SetOfCapability
  var SetRL : SetOfRelationship
  var SetRQ : SetOfRequirement
  var TRL : RLType
  var IDND : NDID           
  var IDCP : CPID
  var IDRQ : RQID
  var IDRL : RLID      
  var STCP : SetOfCPState
  vars SRQ1 SRQ2 : RQState
  var STRQ : SetOfRQState 
  var S : State

  -- inv(S)
  -- This proof requires inv-ifOpenMsgThenCPActivated.
  ceq inv(S) = false if not inv-ifOpenMsgThenCPActivated(S) .
  -- wfs(S)
  ceq wfs(S) = false if not wfs-uniqCP(S) .
  ceq wfs(S) = false if not wfs-allRLHaveCP(S) .
  ceq wfs(S) = false if not wfs-allRLHaveSameTypeCPRQ(S) .

  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship
  eq lemma(SetCP,SetRQ,SetRL)
     = (allCPInStates(SetCP,closed) and allRQInStates(SetRQ,unbound) and 
        allCPHaveRL(SetCP,SetRL) and allRLHaveRQ(SetRL,SetRQ)) implies
       ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .

  eq [lemma :nonexec]:
      (allCPInStates(SetCP,closed) and allRQInStates(SetRQ,unbound) and 
       allCPHaveRL(SetCP,SetRL) and allRLHaveRQ(SetRL,SetRQ) and
       ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL))
    = (allCPInStates(SetCP,closed) and allRQInStates(SetRQ,unbound) and 
       allCPHaveRL(SetCP,SetRL) and allRLHaveRQ(SetRL,SetRQ)) .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose capability is not concerned, changes its state.
  ceq [tosca-lemma08 :nonexec]:
      (ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
       ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ2,IDND) SetRQ),STRQ,
				  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)))
     = ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL))
     if not existCP(SetCP,IDCP) .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose current state is not concerned, changes its state.
  ceq [tosca-lemma09 :nonexec]:
      (ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
       ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL)))
     = ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL))
     if not (SRQ1 \in STRQ) .
}

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
--> Proof of lemma.
select Proofinv-ifCPClosedThenRQUnbound .
:goal {
  eq [lemma-1]: lemma(empCP,sRQ,sRL) = true .
  eq [lemma-2]: lemma(sCP,sRQ,sRL) implies
                lemma((cap(trl,idCP,scp,idND) sCP),sRQ,sRL) = true .
}
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:csp {
  eq onlyOneRLOfCP(sRL,idCP) = false .
  eq sRL = (rel(trl',idRL,idCP,idRQ) sRL') .
}
:apply (rd-) -- 1-1
:csp {
  eq existRQ(sRQ,idRQ) = false .
  eq sRQ = (req(trl'',idRQ,srq,idND') sRQ') .
}
:apply (rd-) -- 1-2-1
:csp {
  eq srq = unbound .
  eq srq = waiting .
  eq srq = ready .
}
:apply (rd-) -- 1-2-2-1
:apply (rd-) -- 1-2-2-2
:apply (rd-) -- 1-2-2-3
:apply (rd-) -- 2
:apply (rd-) -- 3
show proof

--> Proof of initinv.
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:init [lemma] by {
  SetCP:SetOfCapability   <- sCP ;
  SetRQ:SetOfRequirement  <- sRQ ;
  SetRL:SetOfRelationship <- sRL ;
}
:apply (rd-)
show proof

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND2) sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (rd-) -- 1
:init [tosca-lemma08] by {
  SetCP:SetOfCapability   <- sCP ;
  STCP:SetOfCPState       <- closed ;
  TRL:RLType              <- hostedOn ;
  IDRQ:RQID               <- idRQ ;
  SRQ1:RQState            <- unbound ;
  IDND:NDID               <- idND2 ;
  SetRQ:SetOfRequirement  <- sRQ ;
  STRQ:SetOfRQState       <- unbound ;
  IDRL:RLID               <- idRL ;
  IDCP:CPID               <- idCP ;
  SetRL:SetOfRelationship <- sRL ;
  SRQ2:RQState            <- ready ;
}
:apply (rd-) -- 2
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND2) sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof
eof
--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND2) sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (rd-) -- 1
:apply (rd-) -- 2
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = created .
}
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(trl,idCP,scp,idND') sCP') .
}
:apply (rd-) -- 1-1
:ctf {
  eq trl = connectsTo .
}
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:apply (rd-) -- 1-2-1-1
:ctf {
  eq existCP(sCP',idCP) = true .
}
:ctf {
  eq state(getNode(sND,idND')) = started .
}
:apply (rd-) -- 1-2-1-2-1-1
:apply (rd-) -- 1-2-1-2-1-2
:init [tosca-lemma08] by {
  SetCP:SetOfCapability   <- sCP' ;
  STCP:SetOfCPState       <- closed ;
  TRL:RLType              <- connectsTo ;
  IDRQ:RQID               <- idRQ ;
  SRQ1:RQState            <- unbound ;
  IDND:NDID               <- idND ;
  SetRQ:SetOfRequirement  <- sRQ ;
  STRQ:SetOfRQState       <- unbound ;
  IDRL:RLID               <- idRL ;
  IDCP:CPID               <- idCP ;
  SetRL:SetOfRelationship <- sRL ;
  SRQ2:RQState            <- waiting ;
}
:ctf {
  eq state(getNode(sND,idND')) = started .
}
:apply (rd-) -- 1-2-1-2-2-1
:apply (rd-) -- 1-2-1-2-2-2
:ctf {
  eq existCP(sCP',idCP) = true .
}
:apply (rd-) -- 1-2-1-3-1
:init [tosca-lemma08] by {
  SetCP:SetOfCapability   <- sCP' ;
  STCP:SetOfCPState       <- closed ;
  TRL:RLType              <- connectsTo ;
  IDRQ:RQID               <- idRQ ;
  SRQ1:RQState            <- unbound ;
  IDND:NDID               <- idND ;
  SetRQ:SetOfRequirement  <- sRQ ;
  STRQ:SetOfRQState       <- unbound ;
  IDRL:RLID               <- idRL ;
  IDCP:CPID               <- idCP ;
  SetRL:SetOfRelationship <- sRL ;
  SRQ2:RQState            <- waiting ;
}
:apply (rd-) -- 1-2-1-3-2
:apply (rd-) -- 1-2-2
:apply (rd-) -- 2
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:init [tosca-lemma09] by {
  SetCP:SetOfCapability   <- sCP ;
  STCP:SetOfCPState       <- closed ;
  TRL:RLType              <- connectsTo ;
  IDRQ:RQID               <- idRQ ;
  SRQ1:RQState            <- waiting ;
  IDND:NDID               <- idND ;
  SetRQ:SetOfRequirement  <- sRQ ;
  STRQ:SetOfRQState       <- unbound ;
  IDRL:RLID               <- idRL ;
  IDCP:CPID               <- idCP ;
  SetRL:SetOfRelationship <- sRL ;
  SRQ2:RQState            <- ready ;
}
:apply (rd-)
show proof

select
