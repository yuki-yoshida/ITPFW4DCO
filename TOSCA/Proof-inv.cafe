require Proof Proof.cafe

--> ***************************
--> (5) init(S) implies inv(S).
--> (6) inv(S) implies inv(SS).
--> ***************************

module! ProofInv {
  pr(PROOFbase)
  pr(STATERules)
  pred invS : State

  pred initinv : State
  eq initinv(S:State)
     = init(S) implies invS(S) .

  pred iinv : State State .
  eq iinv(S:State,SS:State)
     = wfs(S) and inv(S) and invS(S) 
       implies invS(SS) .
  pred invinv : State
  eq invinv(S:State)
     = not (S =(*,1)=>+ SS:State if CC:Bool suchThat
            not ((CC implies iinv(S,SS)) == true)
     	   { S => SS !! CC ! wfs(S) ! inv(S) ! invS(S) ! invS(SS) }) .
}

--> ****************************************************************
--> Proof of inv-ifOpenMsgThenCPActivated.
-->  eq inv-ifOpenMsgThenCPActivated(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifOpenMsgThenCPInStates(MP,SetCP,(open available)) .
--> ****************************************************************
--> Proof of inv(S) implies inv(SS)
module! Proofinv-ifOpenMsgThenCPActivated {
  pr(ProofInv)
  eq invS(S:State) = inv-ifOpenMsgThenCPActivated(S) .

  var IDND : NDID
  var IDCP : CPID
  var TRL : RLType
  var SetCP : SetOfCapability
  vars SCP1 SCP2 : CPState
  var STCP : SetOfCPState
  var MP : PoolOfMsg

  -- If (SCP2 \in STCP) or not (SCP1 \in STCP),
  -- then ifOpenMsgThenCPInStates keeps to hold.
  ceq [tosca-lemma13 :nonexec]:
      (ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP) and
       ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP2,IDND) SetCP),STCP))
     = ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP)
     if (SCP2 \in STCP) .

  ceq [tosca-lemma14 :nonexec]:
      (ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP) and
       ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP2,IDND) SetCP),STCP))
     = ifOpenMsgThenCPInStates(MP,(cap(TRL,IDCP,SCP1,IDND) SetCP),STCP)
     if not (SCP1 \in STCP) .

}

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
select Proofinv-ifOpenMsgThenCPActivated .
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:ctf {
  eq mp = empMsg .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:init [tosca-lemma13] by {
  SCP2:CPState <- available ;
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:init [tosca-lemma14] by {
  SCP1:CPState <- closed ;
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:init [tosca-lemma13] by {
  SCP2:CPState <- available ;
}
:apply (rd) -- 1 
:apply (rd) -- 2
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:init [tosca-lemma13] by {
  SCP2:CPState <- available ;
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd)
show proof
select

--> ********************************************************************
--> Proof of inv-ifCPClosedThenRQUnbound.
-->  eq inv-ifCPClosedThenRQUnbound(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .
--> ********************************************************************
--> This proof requires inv-ifOpenMsgThenCPActivated.
--> Proof of inv(S) implies inv(SS)
module! Proofinv-ifCPClosedThenRQUnbound {
  pr(ProofInv)
  eq invS(S:State) = inv-ifCPClosedThenRQUnbound(S) .

  var SetCP : SetOfCapability
  var SetRL : SetOfRelationship
  var SetRQ : SetOfRequirement
  var TRL : RLType
  var IDND : NDID           
  var IDCP : CPID
  var IDRQ : RQID
  var IDRL : RLID      
  var STCP : SetOfCPState
  vars SRQ1 SRQ2 : RQState
  var STRQ : SetOfRQState 
  var S : State

  -- inv(S)
  -- This proof requires inv-ifOpenMsgThenCPActivated.
  ceq inv(S) = false if not inv-ifOpenMsgThenCPActivated(S) .
  -- wfs(S)
  ceq wfs(S) = false if not wfs-uniqCP(S) .
  ceq wfs(S) = false if not wfs-allRLHaveCP(S) .
  ceq wfs(S) = false if not wfs-allRLHaveSameTypeCPRQ(S) .

  -- Since wfs-allCPHaveRL and wfs-allRLHaveRQ(SetRL,SetRQ) always hold
  -- they are omitted from the antecedent.
  eq [tosca-lemma19]:
      (allRQInStates(SetRQ,STRQ) and 
       ifCPInStatesThenRQInStates(SetCP,STCP,SetRQ,STRQ,SetRL))
    = allRQInStates(SetRQ,STRQ) .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose capability is not concerned, changes its state.
  ceq [tosca-lemma08 :nonexec]:
      (ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
       ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ2,IDND) SetRQ),STRQ,
				  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)))
     = ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL))
     if not existCP(SetCP,IDCP) .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose current state is not concerned, changes its state.
  ceq [tosca-lemma09 :nonexec]:
      (ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
       ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL)))
     = ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(TRL,IDRL,IDCP,IDRQ) SetRL))
     if not (SRQ1 \in STRQ) .
}

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
select Proofinv-ifCPClosedThenRQUnbound .
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd)
show proof

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
:ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (rd) -- 1
:init [tosca-lemma08] by {
    SRQ1:RQState <- unbound ;
}
:apply (rd) -- 2
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (rd) -- 1
:ctf {
  eq (state(getNode(sND,idND')) = created) = true .
}
:init [tosca-lemma08] by {
    SRQ1:RQState <- unbound ;
}
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:apply (rd) -- 2-1-1
:apply (rd) -- 2-1-2
:apply (rd) -- 2-1-3
:apply (rd) -- 2-2
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (rd) -- 1
:apply (rd) -- 2
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
:ctf {
  eq state(getNode(sND,idND)) = created .
}
:csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(trl,idCP,scp,idND') sCP') .
}
:apply (rd) -- 1-1
:ctf {
  eq existCP(sCP',idCP) = true .
}
:apply (rd) -- 1-2-1
:ctf {
  eq trl = connectsTo .
}
:init [tosca-lemma08] by {
    SRQ1:RQState <- unbound ;
}
:csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:apply (rd) -- 1-2-2-1-1
:apply (rd) -- 1-2-2-1-2
:apply (rd) -- 1-2-2-1-3
:apply (rd) -- 1-2-2-2
:apply (rd) -- 2
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:init [tosca-lemma09] by {
    SRQ1:RQState <- waiting ;
}
:apply (rd)
show proof
select
