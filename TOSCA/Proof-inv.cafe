require PROOF Proof.cafe

--> ***************************
--> (3) init(S) implies inv(S).
--> (4) inv(S) implies inv(SS).
--> ***************************

module ProofInv {
  protecting(PROOF)
  -- Common lemmas in this domain.

  var IDCP : CPID
  var IDND : NDID
  var IDRL : RLID
  var IDRQ : RQID
  vars SCP SCP1 SCP2 : CPState
  vars SRQ SRQ1 SRQ2 : RQState
  var STCP : SetOfCPState
  var STRQ : SetOfRQState
  var SetCP : SetOfCapability
  var SetRL : SetOfRelationship
  var SetRQ : SetOfRequirement
  var TCP : CPType
  var TRQ : RQType
  var TRL : RLType
  var MP : PoolOfMsg

  eq [tosca-lemma03]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,(opMsg(IDCP) MP)) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) .

  eq [tosca-lemma04]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,(avMsg(IDCP) MP)) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) .

  ceq [tosca-lemma05]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(opMsg(IDCP) MP)) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(opMsg(IDCP) MP)) 
     if (SRQ2 in STRQ) and (IDRQ = req(getRLOfCP(SetRL, IDCP))) .

  ceq [tosca-lemma06]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ2,IDND) SetRQ),STRQ,SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL,MP) 
     if not (TRQ = connectsTo) and SRQ1 > SRQ2 .

  ceq [tosca-lemma07]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(avMsg(IDCP) MP)) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(avMsg(IDCP) MP)) 
     if SRQ2 in STRQ .

  ceq [tosca-lemma0701]:
      (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(connectsTo,IDRL,IDCP,IDRQ) SetRL),(avMsg(IDCP) MP)) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		(rel(connectsTo,IDRL,IDCP,IDRQ) SetRL),MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		(rel(connectsTo,IDRL,IDCP,IDRQ) SetRL),(avMsg(IDCP) MP)) 
     if not existCP(SetCP,IDCP) .

  ceq [tosca-lemma08]:
      (allCPInStates(SetCP,SCP) and
       ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) )
     = allCPInStates(SetCP,SCP) 
     if not (SCP in STCP) .

  eq [tosca-lemma09]:
      (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,(opMsg(IDCP) MP)) )
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) .

  eq [tosca-lemma10]:
      (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,(avMsg(IDCP) MP)) )
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP) .

  ceq [tosca-lemma11]:
      (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(opMsg(IDCP) MP)) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(opMsg(IDCP) MP))
     if not (SRQ1 in STRQ) .

  ceq [tosca-lemma12]:
      (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL,MP) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ2,IDND) SetRQ),STRQ,SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL,MP)
     if (TRQ = connectsTo) = false and SRQ1 > SRQ2 .

  ceq [tosca-lemma13]:
      (allCPInStates(SetCP,SCP) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,STCP,SetRQ,STRQ,SetRL,MP))
     = allCPInStates(SetCP,SCP) 
     if not (SCP in STCP) .

  ceq [tosca-lemma14]:
      (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(avMsg(IDCP) MP)) and
       ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ2,IDND) SetRQ),STRQ,
		SetRL,MP) )
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		SetCP,STCP,(req(connectsTo,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		SetRL,(avMsg(IDCP) MP)) 
     if (SRQ2 in STRQ) and (IDRQ = req(getRLOfCP(SetRL, IDCP))) .

  -- If (SCP2 in STCP) or not (SCP1 in STCP),
  -- then ifOpenMsgThenCPInStates keeps to hold.
  ceq [tosca-lemma15]:
      (ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP) and
       ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP2,IDND) SetCP),STCP))
     = ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP)
     if (SCP2 in STCP) and SCP1 > SCP2 .

  ceq [tosca-lemma16]:
      (ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP) and
       ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP2,IDND) SetCP),STCP))
     = ifOpenMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP)
     if not (SCP1 in STCP) and SCP1 > SCP2 .

  -- ifAvailableMsgThenCPInStates keeps to hold
  -- after changing the state of a capability to the target state. 
  ceq [tosca-lemma17]:
      (ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP) and
       ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP2,IDND) SetCP),STCP))
     = ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP)
     if (SCP2 in STCP) and SCP1 > SCP2 .

  -- ifAvailableMsgThenCPInStates keeps to hold
  -- after changing the state of a capability whose current state is not the target state. 
  ceq [tosca-lemma18]:
      (ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP) and
       ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP2,IDND) SetCP),STCP))
     = ifAvailableMsgThenCPInStates(MP,(cap(TCP,IDCP,SCP1,IDND) SetCP),STCP)
     if not (SCP1 in STCP) and SCP1 > SCP2 .

  -- Since wfs-allCPHaveRL and wfs-allRLHaveRQ(SetRL,SetRQ) always hold
  -- they are omitted from the antecedent.
  ceq [tosca-lemma19]:
      (allRQInStates(SetRQ,SRQ) and 
       ifCPInStatesThenRQInStates(SetCP,STCP,SetRQ,STRQ,SetRL))
    = allRQInStates(SetRQ,SRQ)
    if SRQ in STRQ .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose capability is not concerned, changes its state.
  ceq [tosca-lemma20]:
      (ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
       ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ2,IDND) SetRQ),STRQ,
				  (rel(TRL,IDRL,IDCP,IDRQ) SetRL)))
     = ifCPInStatesThenRQInStates(SetCP,STCP,(req(TRL,IDRQ,SRQ1,IDND) SetRQ),STRQ,
		                  (rel(TRL,IDRL,IDCP,IDRQ) SetRL))
     if not existCP(SetCP,IDCP) and uniqCP(SetCP) and
        allCPHaveRL(SetCP,(rel(TRL,IDRL,IDCP,IDRQ) SetRL)) and
        allRLHaveRQ((rel(TRL,IDRL,IDCP,IDRQ) SetRL),(req(TRL,IDRQ,SRQ1,IDND) SetRQ))
	and SRQ1 > SRQ2 .

  -- ifCPClosedThenRQUnbound keeps to hold 
  -- even if a requirement, whose current state is not concerned, changes its state.
  ceq [tosca-lemma21]:
      (ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL) and
       ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ2,IDND) SetRQ),STRQ,SetRL))
     = ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL)
     if not (SRQ1 in STRQ) and SRQ1 > SRQ2 .

  ceq [tosca-lemma22]:
      (ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL) and
       ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ2,IDND) SetRQ),STRQ,SetRL))
     = ifCPInStatesThenRQInStates(
		SetCP,STCP,(req(TRQ,IDRQ,SRQ1,IDND) SetRQ),STRQ,SetRL)
     if (SRQ2 in STRQ) and SRQ1 > SRQ2 .
}

-- Note:
--  The proofs of wfs invariants are not shown 
--  because they are not interesting when no rule changes the model structure.
--  The cases which use allRLHaveSameTypeCPRQ are omitted and
--  introduced capabilities, relationships, and requirements are assumed to have correct types.

--> ***********************************************************************
--> Proof of inv-ifNDInitialThenRQUnboundReady.
-->  eq inv-ifNDInitialThenRQUnboundReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenRQInStates(SetND,initial,SetRQ,(unbound ready)) .
--> ***********************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifNDInitialThenRQUnboundReady {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
}

select Proofinv-ifNDInitialThenRQUnboundReady .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp5-2a = :csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd,idND',initial) sND') .
  eq sND = (node(tnd,idND',created) sND') .
  eq sND = (node(tnd,idND',started) sND') .
}
:def csp5-2b = :csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Since the condition of rule R07 is complicated, two :csp commands are required.
-- Don't try rd- before both case splitting are applied.
:apply (csp5-2a csp5-2b rd-)
:def ctfidND' = :ctf {
  eq existND(sND',idND') = true .
}
-- There remain two leaves of the proof tree and 
-- they should be resolved separatedly.
:apply (ctfidND' rd-)
:apply (ctfidND' rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp5-4idND = :csp {
  eq existND(sND,idND) = false .
  eq sND = (node(tnd,idND,snd) sND') .
}
:apply (csp5-4idND rd-)
:def csp5-2 = :csp {
  eq snd = initial .
  eq snd = created .
  eq snd = started .
}
:apply (csp5-2 rd-)
:def ctfidND = :ctf {
  eq existND(sND',idND) = true .
}
:apply (ctfidND rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> **************************************************************************************
--> Proof of inv-ifNDCreatedThenHostedOnRQReady.
-->  eq inv-ifNDCreatedThenHostedOnRQReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenRQOfTypeInStates(SetND,(created started),SetRQ,hostedOn,ready) .
--> **************************************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifNDCreatedThenHostedOnRQReady {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
}

select Proofinv-ifNDCreatedThenHostedOnRQReady .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
:def ctfsRQ = :ctf {
  eq sRQ = empRQ .
}
:apply (ctfsRQ rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> **************************************************************
--> Proof of inv-ifNDStartedThenRQReady.
-->  eq inv-ifNDStartedThenRQReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenRQInStates(SetND,started,SetRQ,ready) .
--> **************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifNDStartedThenRQReady {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifNDStartedThenRQReady(S) .
}

select Proofinv-ifNDStartedThenRQReady .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> ********************************************************************
--> Proof of inv-ifCPClosedThenRQUnbound.
-->  eq inv-ifCPClosedThenRQUnbound(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .
--> ********************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
--> This proof requires inv-ifOpenMsgThenCPActivated.
module Proofinv-ifCPClosedThenRQUnbound {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifCPClosedThenRQUnbound(S) .
}

select Proofinv-ifCPClosedThenRQUnbound .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
-- This goal requires o2o2o-lemma01
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:def ctf5-2 = :ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (ctf5-2 rd-)
:def ctfuniqCP = :ctf {
  eq uniqCP((rel(hostedOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqCP rd-)
:def ctfuniqRQ = :ctf {
  eq uniqRQ((rel(hostedOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqRQ rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
-- This goal requires o2o2o-lemma01
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2a = :ctf {
  eq state(getNode(sND,idND')) = created .
}
:def ctf5-2b = :ctf {
  eq scp = closed .
}
-- Since the condition of rule R07 is complicated, two :csp commands are required.
-- Don't try rd- before both case splitting are applied.
:apply (ctf5-2a ctf5-2b rd-)
:def ctfidCP = :ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (ctfidCP rd-)
:def ctfuniqCP = :ctf {
  eq uniqCP((rel(dependsOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqCP rd-)
:def ctfuniqRQ = :ctf {
  eq uniqRQ((rel(dependsOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqRQ rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
-- This goal requires o2o2o-lemma01
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
:def csp5-4idCP = :csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
}
:apply (csp5-4idCP rd-)
:def ctfidCP = :ctf {
  eq existCP(sCP',idCP) = true .
}
:apply (ctfidCP rd-)
:def ctfscp = :ctf {
  eq scp = closed .
}
:apply (ctfscp rd-)
:def ctfuniqCP = :ctf {
  eq uniqCP((rel(connectsTo,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqCP rd-)
:def ctfuniqRQ = :ctf {
  eq uniqRQ((rel(connectsTo,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqRQ rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> ****************************************************************************
--> Proof of inv-ifCPOpenThenRQUnboundWaiting.
-->  eq inv-ifCPOpenThenRQUnboundWaiting(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,open,SetRQ,(unbound waiting),SetRL) .
--> ****************************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
--> This proof requires inv-ifCPClosedThenRQUnbound, inv-ifAvailableMsgThenCPAvailable.
module Proofinv-ifCPOpenThenRQUnboundWaiting {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
}

select Proofinv-ifCPOpenThenRQUnboundWaiting .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:def ctfmp = :ctf {
  eq mp = empMsg .
}
:apply (ctfmp rd-) 
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
-- This goal requires o2o2o-lemma01
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:def ctf5-2 = :ctf {
  eq existCP(sCP,idCP) = true .
}
:apply (ctf5-2 rd-)
:def ctfuniqCP = :ctf {
  eq uniqCP((rel(hostedOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqCP rd-)
:def ctfuniqRQ = :ctf {
  eq uniqRQ((rel(hostedOn,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqRQ rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
:def csp5-4idCP = :csp {
  eq onlyOneRLOfCP(sRL,idCP) = false .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
}
:apply (csp5-4idCP rd-)
:def csp5-4idRQa = :csp {
  eq existRQ(sRQ,idRQ) = false .
  eq sRQ = (req(dependsOn,idRQ,srq,idND') sRQ') .
}
:def csp5-4idRQb = :csp {
  eq srq = unbound .
  eq srq = waiting .
  eq srq = ready .
}
:apply (csp5-4idRQa rd- csp5-4idRQb rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2a = :ctf {
  eq state(getNode(sND,idND')) = created .
}
:def csp5-2b = :csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Since the condition of rule R07 is complicated, two :csp commands are required.
-- Don't try rd- before both case splitting are applied.
:apply (ctf5-2a csp5-2b rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
:def csp5-4idCP = :csp {
  eq onlyOneRLOfCP(sRL,idCP) = false .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
}
:apply (csp5-4idCP rd-)
:def csp5-4idRQa = :csp {
  eq existRQ(sRQ,idRQ) = false .
  eq sRQ = (req(connectsTo,idRQ,srq,idND') sRQ') .
}
:def csp5-4idRQb = :csp {
  eq srq = unbound .
  eq srq = waiting .
  eq srq = ready .
}
:apply (csp5-4idRQa rd- csp5-4idRQb rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
-- This goal requires o2o2o-lemma01
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:def csp5-4idCPa = :csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
}
:def csp5-4idCPb = :csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:apply (csp5-4idCPa rd- csp5-4idCPb rd-)
:def ctfidCP = :ctf {
  eq existCP(sCP',idCP) = true .
}
:apply (ctfidCP rd-)
:def ctfuniqCP = :ctf {
  eq uniqCP((rel(connectsTo,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqCP rd-)
:def ctfuniqRQ = :ctf {
  eq uniqRQ((rel(connectsTo,idRL,idCP,idRQ) sRL)) = true .
}
:apply (ctfuniqRQ rd-)
show proof
select

--> ************************************************************
--> Proof of inv-HostedOnCPNotOpen.
-->  eq inv-allHostedOnCPNotOpen(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = allHostedOnCPInStates(SetCP,(closed available)) .
--> ************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-HostedOnCPNotOpen {
  protecting(ProofInv)
  eq invK(S:State) = inv-HostedOnCPNotOpen(S) .
}

select Proofinv-HostedOnCPNotOpen .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> *********************************************************
--> Proof of inv-HostedOnRQNotWaiting.
-->  eq inv-HostedOnRQNotWaiting(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = HostedOnRQInState(SetCP,(closed available)) .
--> *********************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-HostedOnRQNotWaiting {
  protecting(ProofInv)
  eq invK(S:State) = inv-HostedOnRQNotWaiting(S) .
}

select Proofinv-HostedOnRQNotWaiting .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> ****************************************************************************************
--> Proof of inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg.
-->  eq inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,open,SetRQ,waiting,SetRL,MP) .
--> ****************************************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
--> This proof requires inv-ifAvailableMsgThenCPAvailable.
module Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
}

select Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:def csp5-4idCPa = :csp {
  eq existCP(sCP,idCP) = false .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
}
:def csp5-4idCPb = :csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
:apply (csp5-4idCPa rd- csp5-4idCPb rd-)
:def ctfidCP = :ctf {
  eq existCP(sCP',idCP) = true .
}
:apply (ctfidCP rd-)
show proof
select

--> *****************************************************************************************************
--> Proof of inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg.
-->  eq inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,available,SetRQ,(waiting ready),SetRL,MP) .
--> *****************************************************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
--> This proof requires inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg.
module Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
}

select Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
:def ctfopMsg = :ctf {
  eq opMsg(idCP) in mp = true .
}
:apply (ctfopMsg rd-)
:def csp5-4idCP = :csp {
  eq onlyOneRLOfCP(sRL,idCP) = false .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
}
:apply (csp5-4idCP rd-)
:def csp5-4idRQa = :csp {
  eq existRQ(sRQ,idRQ) = false .
  eq sRQ = (req(connectsTo,idRQ,srq,idND') sRQ') .
}
:def csp5-4idRQb = :csp {
  eq srq = unbound .
  eq srq = waiting .
  eq srq = ready .
}
:apply (csp5-4idRQa rd- csp5-4idRQb rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> ************************************************************************************************
--> Proof of inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg.
-->  eq inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,available,SetRQ,ready,SetRL,MP) .
--> ************************************************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
}

select Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:apply (rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> ****************************************************************
--> Proof of inv-ifOpenMsgThenCPActivated.
-->  eq inv-ifOpenMsgThenCPActivated(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifOpenMsgThenCPInStates(MP,SetCP,(open available)) .
--> ****************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifOpenMsgThenCPActivated {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifOpenMsgThenCPActivated(S) .
}

select Proofinv-ifOpenMsgThenCPActivated .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:def ctfmp = :ctf {
  eq mp = empMsg .
}
:apply (ctfmp rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq (state(getNode(sND,idND')) = created and isActivated(scp)) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select

--> *********************************************************************
--> Proof of inv-ifAvailableMsgThenCPAvailable.
-->  eq inv-ifAvailableMsgThenCPAvailable(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifAvailableMsgThenCPInStates(MP,SetCP,available) .
--> *********************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifAvailableMsgThenCPAvailable {
  protecting(ProofInv)
  eq invK(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
}

select Proofinv-ifAvailableMsgThenCPAvailable .
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sND,sCP,sRQ,sRL,mp >) = true .
}
:def ctfmp = :ctf {
  eq mp = empMsg .
}
:apply (ctfmp rd-)
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfTypeOfNDInStates(SetRQ,hostedOn,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfTypeOfNDInStates(sRQ,hostedOn,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(hostedOn,idCP,available,idND) sCP), 
  	           (req(hostedOn,idRQ,unbound,idND') sRQ), 
	           (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) -- 1
show proof

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,unbound,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp5-2a = :csp {
  eq existND(sND,idND') = false .
  eq sND = (node(tnd,idND',initial) sND') .
  eq sND = (node(tnd,idND',created) sND') .
  eq sND = (node(tnd,idND',started) sND') .
}
:def csp5-2b = :csp {
  eq scp = closed .
  eq scp = open .
  eq scp = available .
}
-- Since the condition of rule R07 is complicated, two :csp commands are required.
-- Don't try rd- before both case splitting are applied.
:apply (csp5-2a csp5-2b rd-)
show proof

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(dependsOn,idCP,scp,idND) sCP), 
   	           (req(dependsOn,idRQ,waiting,idND') sRQ), 
	           (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >) = true .
}
:apply (rd-) 
show proof

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq isCreated(state(getNode(sND,idND))) = true .
}
:apply (ctf5-2 rd-)
show proof

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = started .
}
:apply (ctf5-2 rd-)
show proof

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,unbound,idND) sRQ), 
	      (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (opMsg(idCP) mp) >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def ctf5-2 = :ctf {
  eq state(getNode(sND,idND)) = created .
}
:apply (ctf5-2 rd-)
show proof

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sND, sCP, 
   	      (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	      (avMsg(idCP) mp) >) = true .
}
:apply (rd-)
show proof
select
--> Totally 156 goals should be proved.
