require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> ********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->         mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->        )) ListLG) > .
--> ********************************************************************************************

open ProofContCont .

  -- Lemmas
  var SCO : SetOfComponent
  var SIM : SetOfImport
  var L : ListOfLog
  -- eq robust-lemmaC11(SCO,SIM,L)
  --   = cont(< SCO, SIM, L >) 
  --     when inv(< SCO, SIM, L >) and
  --          equivIMSet(SIM) = false .
  ceq cont(< SCO, SIM, L >) = true
    if inv(< SCO, SIM, L >) and  equivIMSet(SIM) = false .

  -- eq robust-lemmaC12(SCO,SIM,L)
  --   = cont(< SCO, SIM, L >) 
  --     when inv(< (CO, SIM, L >) and
  --          equivCOSet(SCO) = false .
  ceq cont(< SCO, SIM, L >) = true
    if inv(< SCO, SIM, L >) and equivCOSet(SCO) = false .

--> *************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
                (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
                lg >) = true .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:apply (tIMscsp rd-)
-- Case 2: mandatory unwired unwired unwired
:apply(nCOscsp tCOscsp rd-)
-- Case 2-1-1: stopped stopped stopped
--> *********************************************************
--> Step 2-3: Split the current case into cases where
-->  predicate final does or does not hold in the next state.
--> *********************************************************
-- Set inv(SS) = true to use lemmas.
:def invctf = :ctf {
  eq inv(< (cmp(idCO,stopped,stopped,stopped) sCO), 
           (imp(mandatory,idIM,idCO,eidCO,unwired,unwired,unwired) sIM), 
           (ilog("RD-unwire2:Do Unwire",imp(mandatory,idIM,idCO,eidCO,unwired,unwired,unwired),
                (1 + (tdis(sIM) + tdis(sCO)))) lg) >) = true .
}
:apply(invctf rd-)
:def finalcsp = :csp {
  eq (equivIMSet(sIM) and equivCOSet(sCO)) = true .
  eq equivIMSet(sIM) = false .
  eq equivCOSet(sCO) = false .
}
:apply(finalcsp rd-)
--> Proof of (2) inv(S) and not final(S) and inv(SS) implies cont(SS) or final(SS).
-->   for Rule RD-unwire2 done
-->
show proof
close

--> Totally 1 goal should be proved.
