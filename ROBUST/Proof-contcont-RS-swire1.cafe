require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->         mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->        )) ListLG) > .
--> ******************************************************************************************

open ProofContCont .

  -- Lemmas
  var CO : Component
  var SCO : SetOfComponent
  var SIM : SetOfImport
  var L : ListOfLog

  -- eq robust-lemmaC01(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(started,stopped,stopped)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(started,stopped,stopped)) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(started,stopped,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(started,stopped,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC03(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(started,started,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(started,started,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC04(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(stopped,sstarted,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(stopped,sstarted,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

--> *************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM), lg >) = true .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO',eidCO) = false .
  eq sCO' = (cmp(eidCO,cCOs',nCOs',tCOs') sCO'') .
}
:def cCOs'csp = :csp  { 
  eq cCOs' = stopped .
  eq cCOs' = started .
  eq cCOs' = sstarted .
}
:def nCOs'csp = :csp  { 
  eq nCOs' = stopped .
  eq nCOs' = started .
  eq nCOs' = sstarted .
}
:def tCOs'csp = :csp  { 
  eq tCOs' = stopped .
  eq tCOs' = started .
  eq tCOs' = sstarted .
}
--> ***************************************************************
--> Step 2-4: Consider which rule can be applied to the next state.
--> ***************************************************************
-- The next rule should be RD-wire1 or RD-wire2
--> *************************************************************************************
--> Step 2-5: Split the current case into cases which collectively cover the current case
-->  and the next state of one of the split cases matches to LHS of the current rule.
--> *************************************************************************************
:apply (exICOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-1-3-3: stopped sstarted sstarted is discharged by C04
-- Case 2-2-1-1: started stopped stopped   is discharged by C01
-- Case 2-2-1-3: started stopped sstarted  is discharged by C02
-- Case 2-2-2-3: started started sstarted  is discharged by C03
-- Case 2-3-3-3: sstarted sstarted sstarted
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (tIMcsp rd-)
-- Case 2-3-3-3-2: optional
:apply (exECOcsp rd-)
:apply (cCOs'csp nCOs'csp tCOs'csp rd-)
--> Proof of (2) inv(S) and not final(S) and inv(SS) implies cont(SS) or final(SS).
-->   for Rule RS-swire1 done
-->
show proof
close

--> Totally 1 goal should be proved.
