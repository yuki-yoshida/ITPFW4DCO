require Template Template.cafe
require LIST LIST.cafe
provide DomainModel

-- An abstract model for Robust Reconfiguration Algorithm by F. Boyer et al.

-- There are two kinds of objects:
-- Component(CO): a component of which a cloud system composes.
-- Import(IM): a directed relationship of two components
--  which means one of them (the importer) requires a service provided by other (exporter).

module! COMPONENT {
  -- Instantiation of Template
  extending(OBJECTBASE
	* {sort Object -> Component,
	   sort ObjIDLt -> COIDLt,
	   sort ObjID -> COID,
	   sort ObjTypeLt -> COTypeLt,
	   sort ObjType -> COType,
	   sort ObjStateLt -> COStateLt,
	   sort ObjState -> COState,
	   sort SetOfObject -> SetOfComponent,
	   sort SetOfObjState -> SetOfCOState,
	   op empObj -> empCO,
	   op empState -> empSCO,
	   op existObj -> existCO,
	   op existObjInStates -> existCOInStates,
	   op uniqObj -> uniqCO,
	   op #ObjInStates -> #ComponentInStates,
	   op getObject -> getComponent,
	   op allObjInStates -> allCOInStates,
	   op allObjNotInStates -> allCONotInStates,
	   op someObjInStates -> someCOInStates})

  -- Constructor
  -- cmp(ID, CState, TState) is a Component where the identifier is ID,
  --    the current local state is CState, and the target local state is TState
  op cmp : COID COState COState -> Component {constr}

  -- Variables
  var IDCO : COID
  vars CSCO TSCO : COState

  -- Selectors
  op target : Component -> COState
  eq id(cmp(IDCO,CSCO,TSCO)) = IDCO .
  eq state(cmp(IDCO,CSCO,TSCO)) = CSCO .
  eq target(cmp(IDCO,CSCO,TSCO)) = TSCO .

  -- Local States
  ops notalive stopped started failed : -> COStateLt {constr}
  eq (notalive > stopped) = true .
  eq (stopped > started) = true .
  eq (started > failed) = true .
}

module! IMPORT {
  protecting(COMPONENT)

  -- Instantiation of Template
  extending(OBJECTBASE
	* {sort Object -> Import,
	   sort ObjIDLt -> IMIDLt,
	   sort ObjID -> IMID,
	   sort ObjTypeLt -> IMTypeLt,
	   sort ObjType -> IMType,
	   sort ObjStateLt -> IMStateLt,
	   sort ObjState -> IMState,
	   sort SetOfObject -> SetOfImport,
	   sort SetOfObjState -> SetOfIMState,
	   op empObj -> empIM,
	   op empState -> empSIM,
	   op existObj -> existIM,
	   op existObjInStates -> existIMInStates,
	   op uniqObj -> uniqIM,
	   op #ObjInStates -> #ImportInStates,
	   op getObject -> getImport,
	   op allObjInStates -> allIMInStates,
	   op allObjOfTypeInStates -> allIMOfTypeInStates,
	   op allObjNotInStates -> allIMNotInStates,
	   op someObjInStates -> someIMInStates})

  -- Constructor
  -- imp(Type, ID, IID, EID, CState, TState) is an Imports where the identifier is ID,
  --    the importer Component is IID, the exporter Component is EID,
  --    the current local state is CState, and the target local state is TState

  op imp : IMType IMID COID COID IMState IMState -> Import {constr}

  -- Variables
  var TIM : IMType
  var IDIM : IMID
  vars IIDCO EIDCO : COID
  vars CSIM TSIM : IMState

  -- Types
  ops mandatory optional : -> IMType

  -- Selectors
  op target : Import -> IMState
  op importer : Import -> COID
  op exporter : Import -> COID
  eq type(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = TIM .
  eq id(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = IDIM .
  eq state(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = CSIM .
  eq target(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = TSIM .
  eq importer(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = IIDCO .
  eq exporter(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM)) = EIDCO .
  
  -- Local States
  ops wired unwired : -> IMStateLt {constr}
  eq (wired > unwired) = true .
}

module! LINKS {
  extending(OBJLINKMANY2ONE(
	IMPORT {sort Object -> Import,
		sort ObjID -> IMID,
		sort ObjType -> IMType,
		sort ObjState -> IMState,
		sort SetOfObject -> SetOfImport,
		sort SetOfObjState -> SetOfIMState,
		sort LObject -> Component,
		sort LObjID -> COID,
		sort LObjState -> COState,
		sort SetOfLObject -> SetOfComponent,
		sort SetOfLObjState -> SetOfCOState,
		op allObjInStates -> allIMInStates,
		op link -> importer,
		op empLObj -> empCO,
		op existLObj -> existCO,
		op allLObjInStates -> allCOInStates,
		op existLObjInStates -> existCOInStates,
		op getLObject -> getComponent})
	* {op hasLObj -> hasImporter,
	   op getXOfZ -> getICOOfIM,
	   op getZsOfX -> getIMsOfICO,
	   op getZsOfTypeOfX -> getIMsOfTypeOfICO,
	   op getZsOfXInStates -> getIMsOfICOInStates,
	   op getXsOfZs -> getICOsOfIMs,
	   op getXsOfZsInStates -> getICOsOfIMsInStates,
	   op getZsOfXs -> getIMsOfICOs,
	   op getZsOfXsInStates -> getIMsOfICOsInStates,
	   op allZHaveX -> allIMHaveICO,
	   op allZOfXInStates -> allIMOfICOInStates,
	   op allZOfTypeOfXInStates -> allIMOfTypeOfICOInStates,
	   op ifOfXThenInStates -> ifOfICOThenInStates,
	   op ifXInStatesThenZInStates -> ifICOInStatesThenIMInStates}
	)

  extending(OBJLINKMANY2ONE(
	IMPORT {sort Object -> Import,
		sort ObjID -> IMID,
		sort ObjType -> IMType,
		sort ObjState -> IMState,
		sort SetOfObject -> SetOfImport,
		sort SetOfObjState -> SetOfIMState,
		sort LObject -> Component,
		sort LObjID -> COID,
		sort LObjState -> COState,
		sort SetOfLObject -> SetOfComponent,
		sort SetOfLObjState -> SetOfCOState,
		op allObjInStates -> allIMInStates,
		op link -> exporter,
		op empLObj -> empCO,
		op existLObj -> existCO,
		op allLObjInStates -> allCOInStates,
		op existLObjInStates -> existCOInStates,
		op getLObject -> getComponent})
	* {op hasLObj -> hasExporter,
	   op getXOfZ -> getECOOfIM,
	   op getZsOfX -> getIMsOfECO,
	   op getZsOfXInStates -> getIMsOfECOInStates,
	   op getXsOfZs -> getECOsOfIMs,
	   op getXsOfZsInStates -> getECOsOfIMsInStates,
	   op getZsOfXs -> getIMsOfECOs,
	   op getZsOfXsInStates -> getIMsOfECOsInStates,
	   op allZHaveX -> allIMHaveECO,
	   op allZOfXInStates -> allIMOfECOInStates,
	   op ifOfXThenInStates -> ifOfECOThenInStates,
	   op ifXInStatesThenZInStates -> ifECOInStatesThenIMInStates}
	)

}

module! LOG {
  protecting(IMPORT)
  protecting(STRING)
  [Log]
  op clog : String Component -> Log {constr}
  op ilog : String Import -> Log {constr}
}

module! STATE {
  protecting(LINKS)
  protecting(LIST(LOG {sort Elt -> Log})
      * {sort List -> ListOfLog,
      	 op empty -> empLog})

  [State]
  -- A State consists of
  --  a set of current Components and a set of current Imports,
  --  a set of target Components and a set of target Imports,
  --  and set of logs
  op <_,_, _,_, _> :
    SetOfComponent SetOfImport
      SetOfComponent SetOfImport
	ListOfLog
      -> State {constr}

  vars SCCO STCO : SetOfComponent
  vars SCIM STIM : SetOfImport
  var L : ListOfLog
  ops cCmps tCmps : State -> SetOfComponent
  ops cImps tImps : State -> SetOfImport
  eq cCmps(< SCCO,SCIM,STCO,STIM,L >) = SCCO .
  eq tCmps(< SCCO,SCIM,STCO,STIM,L >) = STCO .
  eq cImps(< SCCO,SCIM,STCO,STIM,L >) = SCIM .
  eq tImps(< SCCO,SCIM,STCO,STIM,L >) = STIM .

  pred wfs : State
  pred init : State
  pred final : State
  pred inv : State
}

-- module! STATECyclefuns {
--   protecting(STATE)

--   var CO : Component
--   var SetCO : SetOfComponent
--   var SetIM : SetOfImport

--   op getAllCOInState : State -> SetOfComponent
--   eq getAllCOInState(< SetCO,SetIM >) = SetCO .

--   op DDSCO : Component State -> SetOfComponent
--   eq DDSCO(CO,< SetCO,SetIM >)
--     = if state(CO) = initial then
--          getRCOsOfIMsInStates(SetCO,getIMsOfCOInStates(SetIM,CO,notready),initial)
--       else empCO fi .
-- }

module! STATEfuns {
  protecting(STATE)

  vars SCCO STCO : SetOfComponent
  vars SCIM STIM : SetOfImport
  var L : ListOfLog

  vars IDCO IIDCO EIDCO : COID 
  vars CSCO TSCO : COState
  var IDIM : IMID
  var TIM : IMType
  vars CSIM TSIM : IMState
  var StCO : SetOfCOState
  var StIM : SetOfIMState
  var S : State

--   extending(CYCLEIMED(
--   	STATECyclefuns {sort Object -> Component,
--   	       		sort SetOfObject -> SetOfComponent,
-- 			sort ObjState -> COState,
-- 			sort SetOfObjState -> SetOfCOState,
-- 			op DDSC -> DDSCO,
--   	       		op empObj -> empCO,
-- 			op someObjInStates -> someCOInStates,
--   	       		op getAllObjInState -> getAllCOInState})
--   	* {op noCycleC -> noCOCycle}
--   	)

  pred allCOInBothStates : SetOfComponent SetOfCOState 
  eq allCOInBothStates(empCO,StCO) = true .
  eq allCOInBothStates((cmp(IDCO,CSCO,TSCO) SCCO),StCO) 
     = (TSCO in StCO) and (CSCO in StCO) and allCOInBothStates(SCCO,StCO) .

  op getIMsOfECOInTargetStates : SetOfImport COID SetOfIMState -> SetOfImport
  eq getIMsOfECOInTargetStates(empIM,IDCO,StIM) = empIM .
  ceq getIMsOfECOInTargetStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM) SCIM),IDCO,StIM) 
     = (imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM) getIMsOfECOInTargetStates(SCIM,IDCO,StIM))
     if TSIM in StIM .
  ceq getIMsOfECOInTargetStates((imp(TIM,IDIM,IIDCO,EIDCO,CSIM,TSIM) SCIM),IDCO,StIM) 
     = getIMsOfECOInTargetStates(SCIM,IDCO,StIM)
     if not EIDCO = IDCO or not TSIM in StIM .


  pred allIMInTargetStates : SetOfImport SetOfIMState 
  eq allIMInTargetStates(empIM,StIM) = true .
  eq allIMInTargetStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM) SCIM),StIM) 
     = (TSIM in StIM) and allIMInTargetStates(SCIM,StIM) .

  pred allIMInBothStates : SetOfImport SetOfIMState 
  eq allIMInBothStates(empIM,StIM) = true .
  eq allIMInBothStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM) SCIM),StIM) 
     = (TSIM in StIM) and (CSIM in StIM) and allIMInBothStates(SCIM,StIM) .

--   pred wfs-atLeastOneCO : State
--   eq wfs-atLeastOneCO(< SCCO,SCIM >) = not (SCCO = empCO) .
--   pred wfs-uniqCO : State
--   eq wfs-uniqCO(< SCCO,SCIM >) = uniqCO(SCCO) .
--   pred wfs-uniqIM : State
--   eq wfs-uniqIM(< SCCO,SCIM >) = uniqIM(SCIM) .
--   pred wfs-allIMHaveCO : State
--   eq wfs-allIMHaveCO(< SCCO,SCIM >) = allIMHaveCO(SCIM,SCCO) .
--   pred wfs-allIMHaveRCO : State
--   eq wfs-allIMHaveRCO(< SCCO,SCIM >) = allIMHaveRCO(SCIM,SCCO) .
  
-- --> **************************************
-- --> Step 0-1: Define init(S) and final(S).
-- --> **************************************
--   -- wfs is a conjunction of invariants which are intentionally imposed by the init condition.
--   -- Since too long wfs causes a large evalutaion cost, define wfs minimally for each use case.
--   eq [:nonexec]: wfs(S)
--      = wfs-atLeastOneCO(S) and
--        wfs-uniqCO(S) and wfs-uniqIM(S) and 
--        wfs-allIMHaveCO(S) and wfs-allIMHaveRCO(S) .

--   eq init(< SCCO,SCIM >)
--      = wfs(< SCCO,SCIM >) and
--        noCOCycle(< SCCO,SCIM >) and
--        allCOInStates(SCCO,initial) and 
--        allIMInStates(SCIM,notready) .

  eq final(< SCCO,SCIM,STCO,STIM,L >)
     = (SCCO = STCO) and (SCIM = STIM) .

}

-- Architecture Invariants
-- (1) All started components have their mandatory imports wired.
-- (2) All started components are wired only to started components.
-- (3) There are no wires to/from failed or destructed components.
-- (4) There are no cycles through mandatory imports

-- Rules to keep invariants
-- [RD-start]:A Component can start
--    all its mandatory Imports are wired to started Components and				
--    (all its optional Imports to stopped Components are unwired.)
--    all its optional Imports are wired only to started components.
-- [RD-stop]:A Component can be stopped when there is no started component importing it.
-- [RD-wire1/2]An Import can be wired when its Component is stopped or its export Component is started.
-- [RD-unwire1]:An optional Import can be unwired anytime.
-- A mandatory Import can be unwired when its Component is stopped.
-- A mandatory Import should be wired to started Component when its Component should start.
-- An export Component of a mandatory Import should start when its import component should start.
-- An optional Import to stopped Compoent should be unwired when its Component should start.
-- [RS-unwire3]:An optional Import of a started Component should be unwired when its export Component should stop.
-- [RS-stop3]:A Component should stop when its mandatory Import is wired to a Component which should stop.
-- [RS-start2]:A Component should start when its optional Import from started Component should be wired.
-- [RS-stop2]:A Component should stop when its mandatory Import should be unwired.

module! STATERules {
  protecting(STATEfuns)

  -- Variables
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO TSCO : COState
  var IDIM : IMID
  var TIM : IMType
  vars CSIM TSIM : IMState

  var SetCCO : SetOfComponent -- current Components
  var SetCIM : SetOfImport    -- current Imports
  var SetTCO : SetOfComponent -- target Components
  var SetTIM : SetOfImport    -- target Imports

  var ListLG : ListOfLog

  -- A Component should be started if it is targeted.
  trans [RS-start1]:
     < (cmp(IDCO, stopped, stopped) SetCCO), SetCIM,
       (cmp(IDCO, started, TSCO) SetTCO), SetTIM,
       ListLG >
  => < (cmp(IDCO, stopped, started) SetCCO), SetCIM,
       (cmp(IDCO, started, TSCO) SetTCO), SetTIM,
       (clog("RS-start1:Should Start", cmp(IDCO, stopped, started)) ListLG) > .

  -- A Component should start when its optional Import from started Component should be writed.
  -- N.B. The following rule need not to check the types of Imports
  --      because a mandatory Import from started Component be always wired.
  ctrans [RS-start2]:
     < (cmp(IDCO, stopped, stopped) SetCCO), SetCIM,
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, stopped, started) SetCCO), SetCIM,
       SetTCO, SetTIM,
       (clog("RS-start2:Should Start", cmp(IDCO, stopped, started)) ListLG) > 
     if someCOInStates(getICOsOfIMs(SetCCO,
                                    getIMsOfECOInTargetStates(SetCIM,IDCO,wired)),
                       started) .

  -- A Component should be stopped if it is targeted.
  trans [RS-stop1]:
     < (cmp(IDCO, started, started) SetCCO), SetCIM,
       (cmp(IDCO, stopped, TSCO) SetTCO), SetTIM,
       ListLG >
  => < (cmp(IDCO, started, stopped) SetCCO), SetCIM,
       (cmp(IDCO, stopped, TSCO) SetTCO), SetTIM,
       (clog("RS-stop1:Should Stop", cmp(IDCO, stopped, TSCO)) ListLG) > .

  -- A Component should stop when its mandatory Import should be unwired.
  trans [RS-stop2]:
     < (cmp(IDCO, started, started) SetCCO), (imp(mandatory,IDIM,IDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, started, stopped) SetCCO), (imp(mandatory,IDIM,IDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped)) ListLG) > .

  -- A Component should stop when its mandatory Import is wired to a Component which should stop.
  -- N.B. When the Import will be unwired, the component need not stop.
  trans [RS-stop3]:
     < (cmp(IIDCO, started, started) cmp(EIDCO, started, stopped) SetCCO), 
                     (imp(mandatory,IDIM,IIDCO,EIDCO,wired,wired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IIDCO, started, stopped) cmp(EIDCO, started, stopped) SetCCO), 
                     (imp(mandatory,IDIM,IIDCO,EIDCO,wired,wired) SetCIM),
       SetTCO, SetTIM,
       (clog("RS-stop3:Should Stop", cmp(IIDCO, started, stopped)) ListLG) > .

  ctrans [RD-start]:
     < (cmp(IDCO, stopped, started) SetCCO), SetCIM,
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, started, started) SetCCO), SetCIM,
       SetTCO, SetTIM,
       (clog("RD-start:Do Start", cmp(IDCO, started, started)) ListLG) > 
     if allIMInBothStates(getIMsOfTypeOfICO(SetCIM,mandatory,IDCO),wired) and
        allCOInBothStates(getECOsOfIMs(SetCCO,getIMsOfICOInStates(SetCIM,IDCO,wired)),started) .

  -- An Imports should be wired if it is trageted.
  ctrans [RS-wire1]:
     < SetCCO, SetCIM,
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,TSIM) SetTIM),
       ListLG >
  => < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired) SetCIM),
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,TSIM) SetTIM),
       (ilog("RS-wire1:Should Wire", imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired)) ListLG) >
     if not existIM(SetCIM, IDIM) .

  trans [RS-wire2]:
     < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired) SetCIM),
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,  wired)   SetTIM),
       ListLG >
  => < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired) SetCIM),
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,  wired)   SetTIM),
       (ilog("RS-wire2:Should Wire", imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired)) ListLG) > .

  -- A wired Imports should be unwired
  --         if it does not exist in the target or it is targeted.
  ctrans [RS-unwire1]:
     < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,wired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RS-unwire1:Should Unwire", imp(TIM,IDIM,IIDCO,EIDCO,wired,unwired)) ListLG) >
     if not existIM(SetTIM, IDIM).

  trans [RS-unwire2]:
     < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,  wired)   SetCIM),
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired) SetTIM),
       ListLG >
  => < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,wired,  unwired) SetCIM),
       SetTCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired) SetTIM),
       (ilog("RS-unwire2:Should Unwire", imp(TIM,IDIM,IIDCO,EIDCO,wired,  unwired)) ListLG) > .

  -- An optional Import of a started Component should be unwired when its export Component should stop.
  trans [RS-unwire3]:
     < (cmp(IIDCO, started, TSCO) cmp(EIDCO, started, stopped) SetCCO), 
                       (imp(optional,IDIM,IIDCO,EIDCO,wired,wired)   SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IIDCO, started, TSCO) cmp(EIDCO, started, stopped) SetCCO), 
                       (imp(optional,IDIM,IIDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RS-unwire3:Should Unwire", imp(optional,IDIM,IIDCO,EIDCO,wired,unwired)) ListLG) > .

  -- An optional Import can be wired when its Component is stopped or its export Component is started.
  trans [RD-wire1]:
     < (cmp(IIDCO, stopped, stopped) SetCCO), 
               (imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IIDCO, stopped, stopped) SetCCO), 
               (imp(TIM,IDIM,IIDCO,EIDCO,wired,wired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RD-wire1:Do Wire", imp(TIM,IDIM,IIDCO,EIDCO,wired,wired)) ListLG) > .

  trans [RD-wire2]:
     < (cmp(EIDCO, started, started) SetCCO), 
               (imp(TIM,IDIM,IIDCO,EIDCO,unwired,wired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(EIDCO, started, started) SetCCO), 
               (imp(TIM,IDIM,IIDCO,EIDCO,wired,wired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RD-wire2:Do Wire", imp(TIM,IDIM,IIDCO,EIDCO,wired,wired)) ListLG) > .

  -- An Optional Imports can be unwired anytime.
  -- N.B. "Anytime" means the component is not failed.
  ctrans [RD-unwire1]:
     < (cmp(IDCO, CSCO, CSCO) SetCCO), (imp(optional,IDIM,IDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, CSCO, CSCO) SetCCO), (imp(optional,IDIM,IDCO,EIDCO,unwired,unwired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RD-unwire1:Do Unwire", imp(optional,IDIM,IDCO,EIDCO,unwired,unwired)) ListLG) > 
     if not CSCO = failed .

  -- A Mandatory Imports can be unwired only if the component is stopped.
  trans [RD-unwire2]:
     < (cmp(IDCO, stopped, TSCO) SetCCO), (imp(mandatory,IDIM,IDCO,EIDCO,wired,unwired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, stopped, TSCO) SetCCO), (imp(mandatory,IDIM,IDCO,EIDCO,unwired,unwired) SetCIM),
       SetTCO, SetTIM,
       (ilog("RD-unwire2:Do Unwire", imp(mandatory,IDIM,IDCO,EIDCO,unwired,unwired)) ListLG) > .

  ctrans [RD-remove]:
     < SetCCO, (imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired) SetCIM),
       SetTCO, SetTIM,
       ListLG >
  => < SetCCO, SetCIM,
       SetTCO, SetTIM,
       (ilog("RD-remove:Do Remove", imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired)) ListLG) >
     if not existIM(SetTIM, IDIM).

  -- A Component can be stopped when there is no started component importing it.
  -- N.B. This rule requires to check not cause loops.
  ctrans [RD-stop]:
     < (cmp(IDCO, started, stopped) SetCCO), SetCIM,
       SetTCO, SetTIM,
       ListLG >
  => < (cmp(IDCO, stopped, stopped) SetCCO), SetCIM,
       SetTCO, SetTIM,
       (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped)) ListLG) > 
     if getICOsOfIMsInStates(SetCCO,getIMsOfECOInStates(SetCIM,IDCO,wired),started) = empCO .
}
