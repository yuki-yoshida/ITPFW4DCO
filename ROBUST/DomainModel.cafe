require Template Template.cafe
require LIST LIST.cafe
provide DomainModel

-- An abstract model for Robust Reconfiguration Algorithm by F. Boyer et al.

-- There are two kinds of objects:
-- Component(CO): a component of which a cloud system composes.
-- Import(IM): a directed relationship of two components
--  which means one of them (the importer) requires a service provided by other (exporter).

module! COMPONENT {
  -- Instantiation of Template
  extending(OBJECTBASE
	* {sort Object -> Component,
	   sort ObjIDLt -> COIDLt,
	   sort ObjID -> COID,
	   sort ObjTypeLt -> COTypeLt,
	   sort ObjType -> COType,
	   sort ObjStateLt -> COStateLt,
	   sort ObjState -> COState,
	   sort SetOfObject -> SetOfComponent,
	   sort SetOfObjState -> SetOfCOState,
	   op empObj -> empCO,
	   op empState -> empSCO,
	   op existObj -> existCO,
	   op existObjInStates -> existCOInStates,
	   op uniqObj -> uniqCO,
	   op #ObjInStates -> #ComponentInStates,
	   op getObject -> getComponent,
	   op allObjInStates -> allCOInStates,
	   op allObjNotInStates -> allCONotInStates,
	   op someObjInStates -> someCOInStates})

  -- Constructor
  -- cmp(ID, CState, NState, TState) is a Component where the identifier is ID,
  --    the current local state is CState, the possible next local state is NState, and
  --    the target local state is TState
  op cmp : COID COState COState COState -> Component {constr}

  -- Variables
  var IDCO : COID
  vars CSCO NSCO TSCO : COState

  -- Selectors
  ops next target : Component -> COState
  eq id(cmp(IDCO,CSCO,NSCO,TSCO)) = IDCO .
  eq state(cmp(IDCO,CSCO,NSCO,TSCO)) = CSCO .
  eq next(cmp(IDCO,CSCO,NSCO,TSCO)) = NSCO .
  eq target(cmp(IDCO,CSCO,NSCO,TSCO)) = TSCO .

  -- Local States
  ops notalive stopped started failed : -> COStateLt {constr}
  eq (notalive > stopped) = true .
  eq (stopped > started) = true .
  eq (started > failed) = true .
}

module! IMPORT {
  protecting(COMPONENT)

  -- Instantiation of Template
  extending(OBJECTBASE
	* {sort Object -> Import,
	   sort ObjIDLt -> IMIDLt,
	   sort ObjID -> IMID,
	   sort ObjTypeLt -> IMTypeLt,
	   sort ObjType -> IMType,
	   sort ObjStateLt -> IMStateLt,
	   sort ObjState -> IMState,
	   sort SetOfObject -> SetOfImport,
	   sort SetOfObjState -> SetOfIMState,
	   op empObj -> empIM,
	   op empState -> empSIM,
	   op existObj -> existIM,
	   op existObjInStates -> existIMInStates,
	   op uniqObj -> uniqIM,
	   op #ObjInStates -> #ImportInStates,
	   op getObject -> getImport,
	   op allObjInStates -> allIMInStates,
	   op allObjOfTypeInStates -> allIMOfTypeInStates,
	   op allObjNotInStates -> allIMNotInStates,
	   op someObjInStates -> someIMInStates})

  -- Constructor
  -- imp(Type, ID, IID, EID, CState, NState, TState) is an Imports where the identifier is ID,
  --    the importer Component is IID, the exporter Component is EID,
  --    the current local state is CState, the next local state is NState, and
  --    the target local state is TState
  op imp : IMType IMID COID COID IMState IMState IMState -> Import {constr}

  -- Variables
  var TIM : IMType
  var IDIM : IMID
  vars IIDCO EIDCO : COID
  vars CSIM NSIM TSIM : IMState

  -- Types
  ops mandatory optional : -> IMType

  -- Selectors
  ops next target : Import -> IMState
  op importer : Import -> COID
  op exporter : Import -> COID
  eq type(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = TIM .
  eq id(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = IDIM .
  eq state(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = CSIM .
  eq next(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = NSIM .
  eq target(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = TSIM .
  eq importer(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = IIDCO .
  eq exporter(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM)) = EIDCO .

  -- Local States
  ops unused wired unwired : -> IMStateLt {constr}
  eq (unused > wired) = true .
  eq (unused > unwired) = true .
  eq (wired > unwired) = true .
}

module! LINKS {
  extending(OBJLINKMANY2ONE(
	IMPORT {sort Object -> Import,
		sort ObjID -> IMID,
		sort ObjType -> IMType,
		sort ObjState -> IMState,
		sort SetOfObject -> SetOfImport,
		sort SetOfObjState -> SetOfIMState,
		sort LObject -> Component,
		sort LObjID -> COID,
		sort LObjState -> COState,
		sort SetOfLObject -> SetOfComponent,
		sort SetOfLObjState -> SetOfCOState,
		op allObjInStates -> allIMInStates,
		op link -> importer,
		op empLObj -> empCO,
		op existLObj -> existCO,
		op allLObjInStates -> allCOInStates,
		op existLObjInStates -> existCOInStates,
		op getLObject -> getComponent})
	* {op hasLObj -> hasImporter,
	   op getXOfZ -> getICOOfIM,
	   op getZsOfX -> getIMsOfICO,
	   op getZsOfTypeOfX -> getIMsOfTypeOfICO,
	   op getZsOfXInStates -> getIMsOfICOInStates,
	   op getXsOfZs -> getICOsOfIMs,
	   op getXsOfZsInStates -> getICOsOfIMsInStates,
	   op getZsOfXs -> getIMsOfICOs,
	   op getZsOfXsInStates -> getIMsOfICOsInStates,
	   op allZHaveX -> allIMHaveICO,
	   op allZOfXInStates -> allIMOfICOInStates,
	   op allZOfTypeOfXInStates -> allIMOfTypeOfICOInStates,
	   op ifOfXThenInStates -> ifOfICOThenInStates,
	   op ifXInStatesThenZInStates -> ifICOInStatesThenIMInStates}
	)

  extending(OBJLINKMANY2ONE(
	IMPORT {sort Object -> Import,
		sort ObjID -> IMID,
		sort ObjType -> IMType,
		sort ObjState -> IMState,
		sort SetOfObject -> SetOfImport,
		sort SetOfObjState -> SetOfIMState,
		sort LObject -> Component,
		sort LObjID -> COID,
		sort LObjState -> COState,
		sort SetOfLObject -> SetOfComponent,
		sort SetOfLObjState -> SetOfCOState,
		op allObjInStates -> allIMInStates,
		op link -> exporter,
		op empLObj -> empCO,
		op existLObj -> existCO,
		op allLObjInStates -> allCOInStates,
		op existLObjInStates -> existCOInStates,
		op getLObject -> getComponent})
	* {op hasLObj -> hasExporter,
	   op getXOfZ -> getECOOfIM,
	   op getZsOfX -> getIMsOfECO,
	   op getZsOfXInStates -> getIMsOfECOInStates,
	   op getXsOfZs -> getECOsOfIMs,
	   op getXsOfZsInStates -> getECOsOfIMsInStates,
	   op getZsOfXs -> getIMsOfECOs,
	   op getZsOfXsInStates -> getIMsOfECOsInStates,
	   op allZHaveX -> allIMHaveECO,
	   op allZOfXInStates -> allIMOfECOInStates,
	   op ifOfXThenInStates -> ifOfECOThenInStates,
	   op ifXInStatesThenZInStates -> ifECOInStatesThenIMInStates}
	)

}

module! LOG {
  protecting(IMPORT)
  protecting(STRING)
  [Log]
  op clog : String Component -> Log {constr}
  op ilog : String Import -> Log {constr}
}

module! STATE {
  protecting(LINKS)
  protecting(LIST(LOG {sort Elt -> Log})
      * {sort List -> ListOfLog,
      	 op empty -> empLog})

  [State]
  -- A State consists of
  --  a set of current Components and a set of current Imports,
  --  a set of target Components and a set of target Imports,
  --  and set of logs
  op <_,_,_> :
    SetOfComponent SetOfImport
	ListOfLog
      -> State {constr}

  var SCO : SetOfComponent
  var SIM : SetOfImport
  var L : ListOfLog
  op cmps : State -> SetOfComponent
  op imps : State -> SetOfImport
  eq cmps(< SCO,SIM,L >) = SCO .
  eq imps(< SCO,SIM,L >) = SIM .

  pred wfs : State
  pred init : State
  pred final : State
  pred inv : State
}

-- module! STATECyclefuns {
--   protecting(STATE)

--   var CO : Component
--   var SetCO : SetOfComponent
--   var SetIM : SetOfImport

--   op getAllCOInState : State -> SetOfComponent
--   eq getAllCOInState(< SetCO,SetIM >) = SetCO .

--   op DDSCO : Component State -> SetOfComponent
--   eq DDSCO(CO,< SetCO,SetIM >)
--     = if state(CO) = initial then
--          getRCOsOfIMsInStates(SetCO,getIMsOfCOInStates(SetIM,CO,notready),initial)
--       else empCO fi .
-- }

module! STATEfuns {
  protecting(STATE)

  var SCCO : SetOfComponent
  var SCIM : SetOfImport
  var L : ListOfLog

  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StCO : SetOfCOState
  var StIM : SetOfIMState
  var S : State

--   extending(CYCLEIMED(
--   	STATECyclefuns {sort Object -> Component,
--   	       		sort SetOfObject -> SetOfComponent,
-- 			sort ObjState -> COState,
-- 			sort SetOfObjState -> SetOfCOState,
-- 			op DDSC -> DDSCO,
--   	       		op empObj -> empCO,
-- 			op someObjInStates -> someCOInStates,
--   	       		op getAllObjInState -> getAllCOInState})
--   	* {op noCycleC -> noCOCycle}
--   	)

  pred stableCOSet : SetOfComponent
  eq stableCOSet(empCO) = true .
  eq stableCOSet((cmp(IDCO,CSCO,NSCO,TSCO) SCCO))
     = (CSCO = NSCO) and stableCOSet(SCCO) .

  pred stableIMSet : SetOfImport
  eq stableIMSet(empIM) = true .
  eq stableIMSet((imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) SCIM))
     = (CSIM = NSIM) and stableIMSet(SCIM) .

  pred equivCOSet : SetOfComponent
  eq equivCOSet(empCO) = true .
  eq equivCOSet(cmp(IDCO,CSCO,NSCO,TSCO) SCCO)
     = (CSCO = NSCO) and (CSCO = TSCO) and equivCOSet(SCCO) .

  pred equivIMSet : SetOfImport
  eq equivIMSet(empIM) = true .
  eq equivIMSet(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) SCIM)
     = (CSIM = NSIM) and (CSIM = TSIM) and equivIMSet(SCIM) .

  pred allCOInBothStates : SetOfComponent SetOfCOState 
  eq allCOInBothStates(empCO,StCO) = true .
  eq allCOInBothStates((cmp(IDCO,CSCO,NSCO,TSCO) SCCO),StCO) 
     = (CSCO in StCO) and (NSCO in StCO) and allCOInBothStates(SCCO,StCO) .

  op getIMsOfECOInNextStates : SetOfImport COID SetOfIMState -> SetOfImport
  eq getIMsOfECOInNextStates(empIM,IDCO,StIM) = empIM .
  ceq getIMsOfECOInNextStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) SCIM),IDCO,StIM) 
     = (imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) getIMsOfECOInNextStates(SCIM,IDCO,StIM))
     if NSIM in StIM .
  ceq getIMsOfECOInNextStates((imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM) SCIM),IDCO,StIM) 
     = getIMsOfECOInNextStates(SCIM,IDCO,StIM)
     if not EIDCO = IDCO or not NSIM in StIM .


  pred allIMInNextStates : SetOfImport SetOfIMState 
  eq allIMInNextStates(empIM,StIM) = true .
  eq allIMInNextStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) SCIM),StIM) 
     = (NSIM in StIM) and allIMInNextStates(SCIM,StIM) .

  pred allIMInBothStates : SetOfImport SetOfIMState 
  eq allIMInBothStates(empIM,StIM) = true .
  eq allIMInBothStates((imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM) SCIM),StIM) 
     = (CSIM in StIM) and (NSIM in StIM) and allIMInBothStates(SCIM,StIM) .

  pred wfs-uniqCO : State
  eq wfs-uniqCO(< SCCO,SCIM,L >) = uniqCO(SCCO) .

  pred wfs-uniqIM : State
  eq wfs-uniqIM(< SCCO,SCIM,L >) = uniqIM(SCIM) .

  pred wfs-allIMHaveICO : State
  eq wfs-allIMHaveICO(< SCCO,SCIM,L >) = allIMHaveICO(SCIM,SCCO) .

  pred wfs-allIMHaveECO : State
  eq wfs-allIMHaveECO(< SCCO,SCIM,L >) = allIMHaveECO(SCIM,SCCO) .
  
--> **************************************
--> Step 0-1: Define init(S) and final(S).
--> **************************************
  -- wfs is a conjunction of invariants which are intentionally imposed by the init condition.
  -- Since too long wfs causes a large evalutaion cost, define wfs minimally for each use case.
  eq [:nonexec]: wfs(S)
     = wfs-uniqCO(S) and wfs-uniqIM(S) and 
       wfs-allIMHaveICO(S) and wfs-allIMHaveECO(S) .

  eq init(< SCCO,SCIM,L >)
     = wfs(< SCCO,SCIM,L >) and
       stableCOSet(SCCO) and stableIMSet(SCIM) and
       not final(< SCCO,SCIM,L >) .
--        noCOCycle(< SCCO,SCIM >) .

  eq final(< SCCO,SCIM,L >)
     = equivCOSet(SCCO) and equivIMSet(SCIM) .

}

-- Architecture Invariants
-- (1) All started components have their mandatory imports wired.
-- (2) All started components are wired only to started components.
-- (3) There are no wires to/from failed or destructed components.
-- (4) There are no cycles through mandatory imports

-- Rules to keep invariants
-- [RD-start]:A Component can start
--    all its mandatory Imports are wired to started Components and				
--    (all its optional Imports to stopped Components are unwired.)
--    all its optional Imports are wired only to started components.
-- [RD-stop]:A Component can be stopped when there is no started component importing it.
-- [RD-wire1/2]An Import can be wired when its Component is stopped or its export Component is started.
-- [RD-unwire1]:An optional Import can be unwired anytime.
-- A mandatory Import can be unwired when its Component is stopped.
-- A mandatory Import should be wired to started Component when its Component should start.
-- An export Component of a mandatory Import should start when its import component should start.
-- An optional Import to stopped Compoent should be unwired when its Component should start.
-- [RS-unwire3]:An optional Import of a started Component should be unwired when its export Component should stop.
-- [RS-stop3]:A Component should stop when its mandatory Import is wired to a Component which should stop.
-- [RS-start2]:A Component should start when its optional Import from started Component should be wired.
-- [RS-stop2]:A Component should stop when its mandatory Import should be unwired.

module! STATERules {
  protecting(STATEfuns)

  -- Variables
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO TSCO' : COState
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState

  var SCO : SetOfComponent -- current Components
  var SIM : SetOfImport    -- current Imports

  var ListLG : ListOfLog

  -- A Component should be started if it is targeted.
  trans [RS-start1]:
     < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
       ListLG >
  => < (cmp(IDCO, stopped, started, started) SCO), SIM,
       (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started)) ListLG) > .

  -- A Component should start when its optional Import from started Component should be writed.
  -- N.B. The following rule need not to check the types of Imports
  --      because a mandatory Import from started Component be always wired.
  ctrans [RS-start2]:
     < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
       ListLG >
  => < (cmp(IDCO, stopped, started, TSCO) SCO), SIM,
       (clog("RS-start2:Should Start", cmp(IDCO, stopped, started, TSCO)) ListLG) > 
     if someCOInStates(getICOsOfIMs(SCO,
                                    getIMsOfECOInNextStates(SIM,IDCO,wired)),
                       started) .

  -- A Component should be stopped if it is targeted.
  trans [RS-stop1]:
     < (cmp(IDCO, started, started, stopped) SCO), SIM,
       ListLG >
  => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
       (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped)) ListLG) > .

  -- A Component should stop when its mandatory Import should be unwired.
  trans [RS-stop2]:
     < (cmp(IDCO, started, started, TSCO) SCO),
       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
        ListLG >
  => < (cmp(IDCO, started, stopped, TSCO) SCO),
       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, TSCO)) ListLG) > .

  -- A Component should stop when its mandatory Import is wired to a Component which should stop.
  -- N.B. When the Import will be unwired, the component need not stop.
  trans [RS-stop3]:
     < (cmp(IIDCO, started, started, TSCO) cmp(EIDCO, started, stopped, TSCO') SCO), 
       (imp(mandatory, IDIM, IIDCO, EIDCO, wired, wired, TSIM) SIM),
       ListLG >
  => < (cmp(IIDCO, started, stopped, TSCO) cmp(EIDCO, started, stopped, TSCO') SCO), 
       (imp(mandatory, IDIM, IIDCO, EIDCO, wired, wired, TSIM) SIM),
       (clog("RS-stop3:Should Stop", cmp(IIDCO, started, stopped, TSCO)) ListLG) > .

  ctrans [RD-start]:
     < (cmp(IDCO, stopped, started, TSCO) SCO), SIM,
       ListLG >
  => < (cmp(IDCO, started, started, TSCO) SCO), SIM,
       (clog("RD-start:Do Start", cmp(IDCO, started, started, TSCO)) ListLG) > 
     if allIMInBothStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(wired unused)) and
        allCOInBothStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,wired)),started) .

  -- An Imports should be wired if it is targeted.
  trans [RS-wire1]:
     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unused, wired) SIM),
       ListLG >
  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  wired, wired) SIM),
       (ilog("RS-wire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired)) ListLG) > .

  trans [RS-wire2]:
     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM),
       ListLG >
  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,   wired, wired) SIM),
       (ilog("RS-wire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired)) ListLG) > .

  -- A wired Imports should be unwired if it will not used or unwired.
  trans [RS-unwire1]:
     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unused) SIM),
       ListLG >
  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused) SIM),
       (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused)) ListLG) > .

  trans [RS-unwire2]:
     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
       ListLG >
  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
       (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired)) ListLG) > .

  -- An optional Import of a started Component should be unwired when its export Component should stop.
  trans [RS-unwire3]:
     < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, TSCO') SCO), 
       (imp(optional, IDIM, IIDCO, EIDCO, wired,   wired, TSIM) SIM),
       ListLG >
  => < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, TSCO') SCO), 
       (imp(optional, IDIM, IIDCO, EIDCO, wired, unwired, TSIM) SIM),
       (ilog("RS-unwire3:Should Unwire", imp(optional, IDIM, IIDCO, EIDCO, wired, unwired, TSIM)) ListLG) > .

  -- An optional Import can be wired when its Component is stopped or its export Component is started.
  trans [RD-wire1]:
     < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, TSIM) SIM),
       ListLG >
  => < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, TSIM) SIM),
       (ilog("RD-wire1:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, TSIM)) ListLG) > .

  trans [RD-wire2]:
     < (cmp(EIDCO, started, started, TSCO) SCO), 
       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, TSIM) SIM),
       ListLG >
  => < (cmp(EIDCO, started, started, TSCO) SCO), 
       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, TSIM) SIM),
       (ilog("RD-wire2:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, TSIM)) ListLG) > .

  -- An Optional Imports can be unwired anytime.
  -- N.B. "Anytime" means the component is not failed.
  ctrans [RD-unwire1]:
     < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
       (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
       ListLG >
  => < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
       (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
       (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM)) ListLG) > 
     if not CSCO = failed .

  -- A Mandatory Imports can be unwired only if the component is stopped.
  trans [RD-unwire2]:
     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
       (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
       ListLG >
  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
       (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM)) ListLG) > .

  trans [RD-remove]:
     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, unused) SIM),
       ListLG >
  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused,  unused, unused) SIM),
       (ilog("RD-remove:Do Remove", imp(TIM, IDIM, IIDCO, EIDCO, unused, unused, unused)) ListLG) > .

  -- A Component can be stopped when there is no started component importing it.
  -- N.B. This rule requires to check not cause loops.
  ctrans [RD-stop]:
     < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
       ListLG >
  => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
       (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped,TSCO)) ListLG) > 
     if getICOsOfIMsInStates(SCO,getIMsOfECOInStates(SIM,IDCO,wired),started) = empCO .
}
