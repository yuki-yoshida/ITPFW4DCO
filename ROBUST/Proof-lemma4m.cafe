require Proof Proof.cafe

--> Common lemmas in this domain.

module ROBUSTLEMMA {
  protecting(ProofBase)

  pred (_when _) : Bool Bool { prec: 63 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  -- Nat Axiom
  vars X X1 X2 Y Y1 Y2 Z Z1 Z2 : Nat

  eq ((X + Z) >= (Y + Z))
    =  (X >= Y) .

  eq ((X + Z) = (Y + Z))
    =  (X = Y) .

  ceq ((X + Z1) >= (Y + Z2))
    =  (X >= Y) 
    if (Z1 >= Z2) .

  -- Bag Axiom
  vars B B' B1 B2 B3 B4 : BagOfID
  var ID : CIID

  ceq ((B1 B2) = (B3 B4))  = (B2 = B4)
    if (B1 = B3) .

  ceq (ID in (B1 B2)) = (ID in B1)
    if not (ID in B2) .

  -- eq set-lemma09(O,S,S')
  --    = subset(S,S') implies subset(S,(O S')) .
  ceq subbag(B,(ID B')) = true
    if subbag(B,B') .

  -- eq set-lemma10(S,S1,S2)
  --    = subset(S2,S) implies subset((S1 S2),S) 
  --    when subset(S1,S) .
  -- ceq subbag((B1 B2),B) = true
  --  if subbag(B1,B) and subbag(B2,B) .

  -- eq set-lemma11(S,S1,S2)
  --    = subset(S,S1) implies subset(S,(S1 S2)) . 
  ceq subbag(B,(B1 B2)) = true
    if subbag(B,B1) .

  -- eq set-lemma12(S)
  --    = subset(S,S) .
  eq subbag(B,B) = true .

  -- eq set-lemma13(S,S1,S2)
  --    = subset(S1,S2) implies subset(S1,S) 
  --    when subset(S2,S) .
  ceq [BagOfIDAxiom1 :nonexec]:
   subbag(B1,B) = true
    if subbag(B1,B2) and subbag(B2,B) .

  eq [BagOfIDAxiom2 :nonexec]:
   (subbag(ID B1,B2) implies (ID in B2)) = true .
  
  -- Domain Axiom
  vars CO CO' CO0 : Component
  vars SCO SCO' SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  vars CSCO' NSCO' TSCO' : COState
  var StCO : SetOfCOState

  vars IM IM' IM0 : Import
  vars SIM SIM' SIM0 : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog

  var BID : BagOfID

  eq id(getComponent(SCO,IDCO)) = IDCO .
  eq subset(getIMsOfECOInTargetStates(SIM,IDCO,TSIM),SIM) = true .

  -- Auxiliary Predicate
  pred allIMNotStablyWired : SetOfImport SetOfComponent SetOfImport
  eq allIMNotStablyWired(empIM,SCO0,SIM0) = true .
  eq allIMNotStablyWired((IM0 SIM),SCO0,SIM0)
     = (not isIMStablyWired(IM0,SCO0,SIM0)) and allIMNotStablyWired(SIM,SCO0,SIM0) .

  -- Lemmas to be proved
  pred robust-lemmaM01 : Component Component SetOfComponent SetOfImport
  eq robust-lemmaM01(CO,CO',SCO0,SIM0)
    = (makeupIDBag(CO, SCO0,SIM0) =
       makeupIDBag(CO',SCO0,SIM0))
    when id(CO) = id(CO')
     and not isForced(CO)
     and not isForced(CO') .

  pred robust-lemmaM02 : SetOfImport Component Component SetOfComponent SetOfImport
  eq robust-lemmaM02(SIM,CO,CO',SCO0,SIM0)
    = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
       makeupIDBag(SIM,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
     and not isForced(CO)
     and not isForced(CO') .

  pred robust-lemmaM03 : Component Component Component SetOfComponent SetOfImport
  eq robust-lemmaM03(CO0,CO,CO',SCO0,SIM0)
    = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
       makeupIDBag(CO0,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
     and not isForced(CO)
     and not isForced(CO') .

  pred robust-lemmaM04 : SetOfImport Component Component SetOfComponent SetOfImport
  eq robust-lemmaM04(SIM,CO,CO',SCO0,SIM0)
    = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
       makeupIDBag(SIM,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
     and isForced(CO)
     and isForced(CO') .

  pred robust-lemmaM05 : Component Component Component SetOfComponent SetOfImport
  eq robust-lemmaM05(CO0,CO,CO',SCO0,SIM0)
    = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
       makeupIDBag(CO0,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
     and isForced(CO)
     and isForced(CO') .

  pred robust-lemmaM06 : Component SetOfComponent SetOfImport
  eq robust-lemmaM06(CO,SCO,SIM)
    = subbag(makeupIDBag(CO,(CO SCO),SIM),makeIDBag(SIM,(CO SCO),SIM))
    when isForced1(CO)
     and allFFCOHasFFIIM((CO SCO),SIM)
     and allFFIMHasFFECO(SIM,(CO SCO)) .

  pred robust-lemmaM07 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemmaM07(SIM,IDCO,SCO0,SIM0)
    = (makeupIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
       makeupIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
    when canStart(IDCO,SCO0,SIM0)
     and subset(SIM,SIM0) .

  pred robust-lemmaM08 : Component COID SetOfComponent SetOfImport
  eq robust-lemmaM08(CO,IDCO,SCO0,SIM0)
    = (makeupIDBag(CO,(cmp(IDCO,started,started,started) SCO0),SIM0) =
       makeupIDBag(CO,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
    when canStart(IDCO,SCO0,SIM0) .

  pred robust-lemmaM09 : SetOfImport COID Component SetOfComponent SetOfImport
  eq robust-lemmaM09(SIM,IDCO,CO,SCO0,SIM0)
    = allIMNotStablyWired(getIMsOfECOInTargetStates(SIM,IDCO,wired),(CO SCO0),SIM0)
    when not canStart(IDCO,(CO SCO0),SIM0)
     and subset(SIM,SIM0)
     and not (IDCO = id(CO)) .

  pred robust-lemmaM10 : SetOfImport Component SetOfComponent SetOfImport
  eq robust-lemmaM10(SIM,CO,SCO0,SIM0)
    = not (cid(id(CO)) in makeupIDBag(SIM,(CO SCO0),SIM0))
    when canStart(id(CO),(CO SCO0),SIM0)
     and subset(SIM,SIM0)
     and allIMNotStablyWired(SIM,(CO SCO0),SIM0) .

  pred robust-lemmaM11 : Component Component SetOfComponent SetOfImport
  eq robust-lemmaM11(CO0,CO,SCO0,SIM0)
    = not (cid(id(CO)) in makeupIDBag(CO0,(CO SCO0),SIM0))
    when canStart(id(CO),(CO SCO0),SIM0)
     and not canStart(id(CO0),(CO SCO0),SIM0) .

  pred robust-lemmaM20 : SetOfImport Component Component SetOfComponent SetOfImport
  eq robust-lemmaM20(SIM,CO,CO',SCO0,SIM0)
    = (makeIDBag(SIM,(CO  SCO0),SIM0) =
       makeIDBag(SIM,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
     and not isForced(CO)
     and not isForced(CO') .

  pred robust-lemmaM21 : SetOfImport Component Component SetOfComponent SetOfImport
  eq robust-lemmaM21(SIM,CO,CO',SCO0,SIM0)
    = (makeIDBag(SIM,(CO  SCO0),SIM0) =
       makeIDBag(SIM,(CO' SCO0),SIM0))
    when id(CO) = id(CO')
      and isForced(CO)
      and isForced(CO') .

  pred robust-lemmaM22 : BagOfID Component Component SetOfComponent SetOfImport
  eq robust-lemmaM22(BID,CO,CO',SCO,SIM)
    = fdis(BID,(CO  SCO),SIM) >= 
      fdis(BID,(CO' SCO),SIM) 
    when id(CO) = id(CO')
     and fdis(CO) >= fdis(CO') .

  pred robust-lemmaM23 : SetOfImport Component SetOfComponent
  eq robust-lemmaM23(SIM,CO,SCO)
    = cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM)
    when isForced1(CO)
     and allFFCOHasFFIIM((CO SCO),SIM)
     and allFFIMHasFFECO(SIM,(CO SCO)) .

  pred robust-lemmaM24 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemmaM24(SIM,IDCO,SCO0,SIM0)
    = makeIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
      makeIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0)
    when canStart(IDCO,SCO0,SIM0)
     and subset(SIM,SIM0) .

  pred robust-lemmaM25 : SetOfImport Component SetOfComponent SetOfImport
  eq robust-lemmaM25(SIM,CO,SCO0,SIM0)
    = not (cid(id(CO)) in makeIDBag(SIM,(CO SCO0),SIM0))
    when canStart(id(CO),(CO SCO0),SIM0)
     and subset(SIM,SIM0) .

  pred robust-lemmaM26 : SetOfImport Component SetOfComponent SetOfImport
  eq robust-lemmaM26(SIM,CO,SCO0,SIM0)
    = (canStart(IDCO,(CO SCO0),SIM0) = canStart(IDCO,SCO0,SIM0))
    when IDCO = id(CO) .

  pred robust-lemmaM27 : BagOfID Component SetOfComponent SetOfImport
  eq robust-lemmaM27(BID,CO,SCO,SIM)
    = (fdis(BID,(CO  SCO),SIM) = fdis(BID,SCO,SIM))
    when not cid(id(CO)) in BID .

  -- tuple of SetOfImport, SetOfComponent, and SetOfImport
  [SIMSCOSIM] op t : SetOfImport SetOfComponent SetOfImport -> SIMSCOSIM {constr} .

  -- well-founded binary relation   
  pred _<wf_ : SIMSCOSIM SIMSCOSIM .
  ceq t(SIM,SCO0,SIM0) <wf t(SIM',SCO0,SIM0) = true
     if SIM <wf SIM' .
  ceq t(SIM,SCO0,SIM0) <wf t((IM SIM'),SCO0,SIM0) = true
     if SIM = getIMsOfECOInTargetStates(SIM0,importer(IM),wired) .
}

--> *************************************
--> Proof of robust-lemmaM01.
-->  eq robust-lemmaM01(CO,CO',SCO0,SIM0)
-->    = (makeupIDBag(CO, SCO0,SIM0) =
-->       makeupIDBag(CO',SCO0,SIM0))
-->    when id(CO) = id(CO')
-->     and not isForced(CO)
-->     and not isForced(CO') .
--> *************************************

select ROBUSTLEMMA
:goal { eq robust-lemmaM01(co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
--> Proof of robust-lemmaM01 done.
-->
show proof
select

--> *****************************************
--> Proof of robust-lemmaM02.
-->  eq robust-lemmaM02(SIM,CO,CO',SCO0,SIM0)
-->    = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
-->       makeupIDBag(SIM,(CO' SCO0),SIM0))
-->    when id(CO) = id(CO')
-->     and not isForced(CO)
-->     and not isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM02-IH :nonexec]:
     robust-lemmaM02(SIM:SetOfImport,co,co',sCO0,sIM0) = true
     if t(SIM,sCO0,sIM0) <wf t((im sIM'),sCO0,sIM0) .

:goal { eq robust-lemmaM02(sIM, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:init as robust-lemmaM02-IH-in [robust-lemmaM02-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp)
:apply (rd-)
:def isFIMctp = :ctf {
  eq isForced(im) = true .
}
:apply (isFIMctp rd-)
:def impIMctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (impIMctf rd-)
:def isFimpCOctf = :ctf {
  eq isForced(getComponent(sCO0,importer(im))) = true .
}
:apply (isFimpCOctf rd-)
--> Proof of robust-lemmaM02 done.
-->
show proof
close

--> *****************************************
--> Proof of robust-lemmaM03.
-->  eq robust-lemmaM03(CO0,CO,CO',SCO0,SIM0)
-->    = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
-->       makeupIDBag(CO0,(CO' SCO0),SIM0))
-->    when id(CO) = id(CO')
-->     and not isForced(CO)
-->     and not isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .

  -- Sublemmas
  -- eq robust-lemmaM02(SIM,CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
  --      makeupIDBag(SIM,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and not isForced(CO)
  --    and not isForced(CO') .
  ceq (makeupIDBag(SIM,(CO  SCO0),SIM0) =
       makeupIDBag(SIM,(CO' SCO0),SIM0)) = true
    if id(CO) = id(CO') and
       not isForced(CO) and
       not isForced(CO') .

:goal { eq robust-lemmaM03(co0, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:def isFCO0ctf = :ctf {
  eq isForced(co0) = true .
}
:apply (isFCO0ctf rd-)
--> Proof of robust-lemmaM03 done.
-->
show proof
close

--> *****************************************
--> Proof of robust-lemmaM04.
-->  eq robust-lemmaM04(SIM,CO,CO',SCO0,SIM0)
-->    = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
-->       makeupIDBag(SIM,(CO' SCO0),SIM0))
-->    when id(CO) = id(CO')
-->     and isForced(CO)
-->     and isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM04-IH :nonexec]:
     robust-lemmaM04(SIM:SetOfImport,co,co',sCO0,sIM0) = true
     if t(SIM,sCO0,sIM0) <wf t((im sIM'),sCO0,sIM0) .

:goal { eq robust-lemmaM04(sIM, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:init as robust-lemmaM04-IH-in [robust-lemmaM04-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp)
:apply (rd-)
:def isFIMctp = :ctf {
  eq isForced(im) = true .
}
:apply (isFIMctp rd-)
:def impIMctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (impIMctf rd-)
:def isFimpCOctf = :ctf {
  eq isForced(getComponent(sCO0,importer(im))) = true .
}
:apply (isFimpCOctf rd-)
--> Proof of robust-lemmaM04 done.
-->
show proof
close

--> *****************************************
--> Proof of robust-lemmaM05.
-->  eq robust-lemmaM05(CO0,CO,CO',SCO0,SIM0)
-->    = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
-->       makeupIDBag(CO0,(CO' SCO0),SIM0))
-->    when id(CO) = id(CO')
-->     and isForced(CO)
-->     and isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .

  -- Sublemmas
  -- eq robust-lemmaM04(SIM,CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
  --      makeupIDBag(SIM,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and not isForced(CO)
  --    and not isForced(CO') .
  ceq (makeupIDBag(SIM,(CO  SCO0),SIM0) =
       makeupIDBag(SIM,(CO' SCO0),SIM0)) = true
    if id(CO) = id(CO') and
       isForced(CO) and
       isForced(CO') .

:goal { eq robust-lemmaM05(co0, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:def isFCO0ctf = :ctf {
  eq isForced(co0) = true .
}
:apply (isFCO0ctf rd-)
--> Proof of robust-lemmaM05 done.
-->
show proof
close

--> *********************************************************************
--> Proof of robust-lemmaM06.
-->  eq robust-lemmaM06(CO,SCO,SIM)
-->    = subbag(makeupIDBag(CO,(CO SCO),SIM),makeIDBag(SIM,(CO SCO),SIM))
-->    when isForced1(CO)
-->     and allFFCOHasFFIIM((CO SCO),SIM)
-->     and allFFIMHasFFECO(SIM,(CO SCO)) .
--> *********************************************************************

open ROBUSTLEMMA .
  -- tuple of CO and SetOfComponent and SetOfImport
  [COSCOSIM] op t : Component SetOfComponent SetOfImport -> COSCOSIM {constr} .
  pred _<wf_ : COSCOSIM COSCOSIM .

  -- Induction Hypothesis
  ceq [robust-lemmaM06-IH :nonexec]:
     robust-lemmaM06(CO',(co sCO),sIM) = true
     if t(CO',(co sCO),sIM) <wf t(co,(co sCO),sIM) .

  -- well-founded binary relation   
  ceq ( t(CO',(CO CO' SCO),(IM SIM)) <wf t(CO,(CO CO' SCO),(IM SIM)) ) = true
    if importer(IM) = id(CO) and
       exporter(IM) = id(CO') .

   -- Assuming wfs-iidCOeidCODiffer(S) holds.
   -- This rejects id(co) = eidCO,
   -- but it causes cyclic evaluation of makeupIDBag before discharing.
   eq (id(co) = eidCO) = false .

:goal { eq robust-lemmaM06(co, sCO, sIM) = true .}
:def isFCOctf = :ctf {
  eq isForced1(co) = true .
}
:apply (isFCOctf rd-)
:def allFFCOcsp = :csp {
  eq allFFCOHasFFIIM((co sCO), sIM) = false .
  eq sIM = (imp(mandatory,idIM,id(co),eidCO,wired,unwired,unused) sIM') .
  eq sIM = (imp(mandatory,idIM,id(co),eidCO,wired,unwired, wired) sIM') .
}
:apply (allFFCOcsp rd-)
:def allFFIMcsp = :csp {
  eq allFFIMHasFFECO(sIM', (co sCO)) = false .
  eq sCO = (cmp(eidCO,started,stopped,started) sCO') .
}  
:apply (allFFIMcsp rd-)
:init ( eq allFFCOHasFFIIM((co SCO:SetOfComponent), sIM) = true . )
      by {SCO:SetOfComponent <- sCO;}
:init ( eq allFFIMHasFFECO(sIM', (co SCO:SetOfComponent)) = true . )
      by {SCO:SetOfComponent <- sCO;}
:init as robust-lemmaM06-in [robust-lemmaM06-IH]
      by {CO':Component <- cmp(eidCO,started,stopped,started);}
:init as BagOfIDAxiom1-in [BagOfIDAxiom1]
      by {B1:BagOfID <- makeupIDBag(co,(co sCO),sIM);
	  B2:BagOfID <- makeupIDBag(cmp(eidCO,started,stopped,started),(co sCO),sIM);
	  B:BagOfID <- makeIDBag(sIM,(co sCO),sIM);}
:apply (rd-)
--> Proof of robust-lemmaM06 done.
-->
show proof
close

--> *********************************************************************
--> Proof of robust-lemmaM07.
-->  eq robust-lemmaM07(SIM,IDCO,SCO0,SIM0)
-->    = (makeupIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
-->       makeupIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
-->    when canStart(IDCO,SCO0,SIM0)
-->     and subset(SIM,SIM0) .
--> *********************************************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM07-IH :nonexec]:
     robust-lemmaM07(SIM:SetOfImport,idCO,sCO0,sIM0) = true
     if t(SIM,sCO0,sIM0) <wf t((im sIM'),sCO0,sIM0) .

:goal { eq robust-lemmaM07(sIM, idCO, sCO0, sIM0) = true .}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def iminSIM0csp = :csp {
  eq (im in sIM0) = false .
  eq sIM0 = (im sIM0') .
}
:apply (iminSIM0csp rd-)
:def sIMsubsIM0csp = :csp {
  eq subset(sIM',im sIM0') = false .
  eq subset(sIM',sIM0') = true .
}
:apply (sIMsubsIM0csp rd-)
:def isFimcsp = :csp {
  eq isForced(im) = false .
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,wired,wired) . 
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,unwired,wired) .
}
:apply (isFimcsp)
-- 2-2-2-1
:def canStartctf1 = :ctf {
  eq allIMStablyWired((if ((mandatory = type(im)) and (idCO = importer(im))) then (im getIMsOfTypeOfICO(sIM0',mandatory,idCO)) else getIMsOfTypeOfICO(sIM0',mandatory,idCO) fi),sCO0,(im sIM0')) = true .
}
:apply (canStartctf1 rd-)
:init as robust-lemmaM07-IH-in [robust-lemmaM07-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-2
:def canStartctf2 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,idCO),sCO0,(imp(mandatory,idIM,iidCO,eidCO,wired,wired,wired) sIM0')) = true .
}
:apply (canStartctf2 rd-)
:init as robust-lemmaM07-IH-in [robust-lemmaM07-IH]
      by {SIM:SetOfImport <- sIM';}
:def isFiidCOctf = :ctf {
  eq isForced(getComponent(sCO0,iidCO)) = true .
}
:apply (isFiidCOctf rd-)
:init as robust-lemmaM07-IH-in [robust-lemmaM07-IH]
      by {SIM:SetOfImport <- getIMsOfECOInTargetStates(sIM0',iidCO,wired);}
:apply (rd-)
-- 2-2-2-3
:def canStartctf3 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,idCO),sCO0,(imp(mandatory,idIM,iidCO,eidCO,wired,unwired,wired) sIM0')) = true .
}
:apply (canStartctf3 rd-)
:init as robust-lemmaM07-IH-in [robust-lemmaM07-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (isFiidCOctf rd-)
:init as robust-lemmaM07-IH-in [robust-lemmaM07-IH]
      by {SIM:SetOfImport <- getIMsOfECOInTargetStates(sIM0',iidCO,wired);}
:apply (rd-)
--> Proof of robust-lemmaM07 done.
-->
show proof
close

--> *********************************************************************
--> Proof of robust-lemmaM08.
-->  eq robust-lemmaM08(CO,IDCO,SCO0,SIM0)
-->    = (makeupIDBag(CO,(cmp(IDCO,started,started,started) SCO0),SIM0) =
-->       makeupIDBag(CO,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
-->    when canStart(IDCO,SCO0,SIM0) .
--> *********************************************************************

open ROBUSTLEMMA .

  -- Sublemmas
  -- eq robust-lemmaM07(SIM,IDCO,SCO0,SIM0)
  --   = (makeupIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
  --      makeupIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
  --   when canStart(IDCO,SCO0,SIM0)
  --    and subset(SIM,SIM0) .
  ceq makeupIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
      makeupIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0)
    if canStart(IDCO,SCO0,SIM0) and
       subset(SIM,SIM0) .

:goal { eq robust-lemmaM08(co, idCO, sCO0, sIM0) = true .}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}

:apply (isFCOctf rd-)
:def canStartctf = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0,mandatory,idCO),sCO0,sIM0) = true .
}
:apply (canStartctf rd-)
--> Proof of robust-lemmaM08 done.
-->
show proof
close

--> *********************************************************
--> Proof of robust-lemmaM10.
-->  eq robust-lemmaM10(SIM,CO,SCO0,SIM0)
-->    = not (cid(id(CO)) in makeupIDBag(SIM,(CO SCO0),SIM0))
-->    when canStart(id(CO),(CO SCO0),SIM0)
-->     and subset(SIM,SIM0)
-->     and allIMNotStablyWired(SIM,(CO SCO0),SIM0) .
--> *********************************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM10-IH :nonexec]:
     robust-lemmaM10(SIM:SetOfImport,co,sCO0,sIM0) = true
     if t(SIM,sCO0,sIM0) <wf t((im sIM'),sCO0,sIM0) .

  -- eq robust-lemmaM09(SIM,IDCO,CO,SCO0,SIM0)
  --   = allIMNotStablyWired(getIMsOfECOInTargetStates(SIM,IDCO,wired),(CO SCO0),SIM0)
  --   when not canStart(IDCO,(CO SCO0),SIM0)
  --    and subset(SIM,SIM0) 
  --    and not (IDCO = id(CO)) .
  ceq allIMNotStablyWired(getIMsOfECOInTargetStates(SIM,IDCO,wired),(CO SCO0),SIM0) = true
    if not canStart(IDCO,(CO SCO0),SIM0) and
       subset(SIM,SIM0) and not (IDCO = id(CO)) .

:goal { eq robust-lemmaM10(sIM, co, sCO0, sIM0) = true .}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def iminSIM0csp = :csp {
  eq (im in sIM0) = false .
  eq sIM0 = (im sIM0') .
}
:apply (iminSIM0csp rd-)
:def sIMsubsIM0csp = :csp {
  eq subset(sIM',im sIM0') = false .
  eq subset(sIM',sIM0') = true .
}
:apply (sIMsubsIM0csp rd-)
:def isFimcsp = :csp {
  eq isForced(im) = false .
  eq im = imp(mandatory,idIM,iidCO,idCO,wired,wired,wired) .
  eq im = imp(mandatory,idIM,iidCO,idCO,wired,unwired,wired) .
}
:apply (isFimcsp)
-- 2-2-2-1
-- allIMNotStablyWired(SIM,(CO SCO0),SIM0) .
:def allIMNSctf1 = :ctf {
  eq allIMNotStablyWired(sIM',(co sCO0),(im sIM0')) = true .
}
:apply (allIMNSctf1 rd-)
-- canStart(id(co),(co sCO0),sIM0) .
:def canStartcoctf1 = :ctf {
  eq allIMStablyWired(
        if ((id(co) = importer(im)) and (mandatory = type(im))) then 
           (im getIMsOfTypeOfICO(sIM0',mandatory,id(co))) else 
           getIMsOfTypeOfICO(sIM0',mandatory,id(co)) fi,
        (co sCO0),(im sIM0')) = true .
}
:apply (canStartcoctf1 rd-)
:init as robust-lemmaM10-IH-in [robust-lemmaM10-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-2
-- allIMNotStablyWired(SIM,(CO SCO0),SIM0) .
:def allIMNSctf2 = :ctf {
  eq allIMNotStablyWired(sIM',(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,wired,wired) sIM0')) = true .
}
:apply (allIMNSctf2 rd-)
:def iidCOctf = :ctf {
  eq id(co) = iidCO .
}
:apply (iidCOctf)
-- canStart(id(co),(co sCO0),sIM0) .
:def canStartcoctf2 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,iidCO),(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,wired,wired) sIM0')) = true .
}
:apply (canStartcoctf2 rd-)
-- canStart(id(co),(co sCO0),sIM0) .
:def canStartcoctf3 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,id(co)),(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,wired,wired) sIM0')) = true .
}
:apply (canStartcoctf3 rd-)
:init as robust-lemmaM10-IH-in [robust-lemmaM10-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
:def isFiidCOctf = :ctf {
  eq isForced(getComponent(sCO0,iidCO)) = true .
}
:apply(isFiidCOctf rd-)
-- isIMStablyWired(im,(co sCO0),sIM0) shoud not hold.
:init ( eq isIMStablyWired(IM:Import,(co sCO0),sIM0) = false . )
   by {IM:Import <- im;}
:init as robust-lemmaM10-IH-in [robust-lemmaM10-IH]
      by {SIM:SetOfImport <- getIMsOfECOInTargetStates(sIM0',iidCO,wired);}
:apply (rd-)
-- 2-2-2-3
-- allIMNotStablyWired(SIM,(CO SCO0),SIM0) .
:def allIMNSctf3 = :ctf {
  eq allIMNotStablyWired(sIM',(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,unwired,wired) sIM0')) = true .
}
:apply (allIMNSctf3 rd-)
:apply (iidCOctf)
-- canStart(id(co),(co sCO0),sIM0) .
:def canStartcoctf4 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,iidCO),(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,unwired,wired) sIM0')) = true .
}
:apply (canStartcoctf4 rd-)
-- canStart(id(co),(co sCO0),sIM0) .
:def canStartcoctf5 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,id(co)),(co sCO0),(imp(mandatory,idIM,iidCO,idCO,wired,unwired,wired) sIM0')) = true .
}
:apply (canStartcoctf5 rd-)
:init as robust-lemmaM10-IH-in [robust-lemmaM10-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
:apply(isFiidCOctf rd-)
-- isIMStablyWired(im,(co sCO0),sIM0) shoud not hold.
:init ( eq isIMStablyWired(IM:Import,(co sCO0),sIM0) = false . )
   by {IM:Import <- im;}
:init as robust-lemmaM10-IH-in [robust-lemmaM10-IH]
      by {SIM:SetOfImport <- getIMsOfECOInTargetStates(sIM0',iidCO,wired);}
:apply (rd-)
--> Proof of robust-lemmaM10 done.
-->
show proof
close

--> *********************************************************
--> Proof of robust-lemmaM11.
-->  eq robust-lemmaM11(CO0,CO,SCO0,SIM0)
-->    = not (cid(id(CO)) in makeupIDBag(CO0,(CO SCO0),SIM0))
-->    when canStart(id(CO),(CO SCO0),SIM0)
-->     and not canStart(id(CO0),(CO SCO0),SIM0) .
--> *********************************************************

open ROBUSTLEMMA .
  -- Sublemmas
  -- eq robust-lemmaM09(SIM,IDCO,CO,SCO0,SIM0)
  --   = allIMNotStablyWired(getIMsOfECOInTargetStates(SIM,IDCO,wired),(CO SCO0),SIM0)
  --   when not canStart(IDCO,(CO SCO0),SIM0)
  --    and subset(SIM,SIM0) 
  --    and not (IDCO = id(CO)) .
  ceq allIMNotStablyWired(getIMsOfECOInTargetStates(SIM,IDCO,wired),(CO SCO0),SIM0) = true
    if not canStart(IDCO,(CO SCO0),SIM0) and
       subset(SIM,SIM0) and not (IDCO = id(CO)) .

  -- eq robust-lemmaM10(SIM,CO,SCO0,SIM0)
  --   = not (cid(id(CO)) in makeupIDBag(SIM,(CO SCO0),SIM0))
  --   when canStart(id(CO),(CO SCO0),SIM0)
  --    and subset(SIM,SIM0)
  --    and allIMNotStablyWired(SIM,(CO SCO0),SIM0) .
  ceq (cid(id(CO)) in makeupIDBag(SIM,(CO SCO0),SIM0)) = false
    if canStart(id(CO),(CO SCO0),SIM0) and
     subset(SIM,SIM0) and
     allIMNotStablyWired(SIM,(CO SCO0),SIM0) .

:goal { eq robust-lemmaM11(co0, co, sCO0, sIM0) = true .}
:csp {
  eq id(co0) = idCO .
}
:def idCOctf = :ctf {
  eq id(co) = idCO .
}
:apply (idCOctf rd-)
:def isForcedCO0csp = :csp {
  eq isForced(co0) = false .
  eq co0 = cmp(idCO,started,started,started) .
  eq co0 = cmp(idCO,started,stopped,started) .
}
:def canStartco0ctf = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0,mandatory,idCO),(co sCO0),sIM0) = true . 
}
:def canStartcoctf = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0,mandatory,id(co)),(co sCO0),sIM0) = true . 
}
:apply (isForcedCO0csp canStartco0ctf canStartcoctf rd-)
--> Proof of robust-lemmaM11 done.
-->
show proof
close

--> *****************************************
--> Proof of robust-lemmaM20.
-->  eq robust-lemmaM20(SIM,CO,CO',SCO0,SIM0)
-->    = makeIDBag(SIM,(CO  SCO0),SIM0) =
-->      makeIDBag(SIM,(CO' SCO0),SIM0)
-->    when id(CO) = id(CO')
-->     and not isForced(CO)
-->     and not isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM20-IH :nonexec]:
     robust-lemmaM20(SIM:SetOfImport,co,co',sCO0,sIM0) = true
     if SIM <wf (im sIM') .

  -- Sublemmas
  -- eq robust-lemmaM01(CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(CO, SCO0,SIM0) =
  --      makeupIDBag(CO',SCO0,SIM0))
  --   when id(CO) = id(CO')
  --    and not isForced(CO)
  --    and not isForced(CO') .
  ceq (makeupIDBag(CO, SCO0,SIM0) =
       makeupIDBag(CO',SCO0,SIM0)) = true
    if id(CO) = id(CO') and
       not isForced(CO) and
       not isForced(CO') .

  -- eq robust-lemmaM03(CO0,CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
  --      makeupIDBag(CO0,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and not isForced(CO)
  --    and not isForced(CO') .
  ceq (makeupIDBag(CO0,(CO  SCO0),SIM0) =
       makeupIDBag(CO0,(CO' SCO0),SIM0)) = true
    if id(CO) = id(CO') and
       not isForced(CO) and
       not isForced(CO') .

:goal { eq robust-lemmaM20(sIM, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:init as robust-lemmaM20-IH-in [robust-lemmaM20-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def isForcingIMctp = :ctf {
  eq isForcing(im) = true .
}
:apply (isForcingIMctp rd-)
:def impIMctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (impIMctf rd-)
--> Proof of robust-lemmaM20 done.
-->
show proof
close

--> *****************************************
--> Proof of robust-lemmaM21.
-->  eq robust-lemmaM21(SIM,CO,CO',SCO0,SIM0)
-->    = makeIDBag(SIM,(CO  SCO0),SIM0) =
-->      makeIDBag(SIM,(CO' SCO0),SIM0)
-->    when id(CO) = id(CO')
-->     and isForced(CO)
-->     and isForced(CO') .
--> *****************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM21-IH :nonexec]:
     robust-lemmaM21(SIM:SetOfImport,co,co',sCO0,sIM0) = true
     if SIM <wf (im sIM') .

  -- Sublemmas
  -- eq robust-lemmaM04(SIM,CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(SIM,(CO  SCO0),SIM0) =
  --      makeupIDBag(SIM,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and isForced(CO)
  --    and isForced(CO') .
  ceq (makeupIDBag(SIM,(CO  SCO0),SIM0) =
       makeupIDBag(SIM,(CO' SCO0),SIM0)) = true
    if id(CO) = id(CO') and
       isForced(CO) and
       isForced(CO') .

  -- eq robust-lemmaM05(CO0,CO,CO',SCO0,SIM0)
  --   = (makeupIDBag(CO0,(CO  SCO0),SIM0) =
  --      makeupIDBag(CO0,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and isForced(CO)
  --    and isForced(CO') .
  ceq (makeupIDBag(CO0,(CO  SCO0),SIM0) =
       makeupIDBag(CO0,(CO' SCO0),SIM0)) = true
    if id(CO) = id(CO') and
       isForced(CO) and
       isForced(CO') .

:goal { eq robust-lemmaM21(sIM, co, co', sCO0, sIM0) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def isFCOctf = :ctf {
  eq isForced(co) = true .
}
:def isFCO'ctf = :ctf {
  eq isForced(co') = true .
}
:apply (idCOctf isFCOctf isFCO'ctf rd-)
:init as robust-lemmaM21-IH-in [robust-lemmaM21-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def isForcingIMctp = :ctf {
  eq isForcing(im) = true .
}
:apply (isForcingIMctp rd-)
:def impIMctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (impIMctf rd-)
--> Proof of robust-lemmaM21 done.
-->
show proof
close

--> ***************************************
--> Proof of robust-lemmaM22.
-->  eq robust-lemmaM22(BID,CO,CO',SCO,SIM)
-->    = fdis(BID,(CO  SCO),SIM) >= 
-->      fdis(BID,(CO' SCO),SIM) 
-->    when id(CO) = id(CO')
-->     and fdis(CO) > fdis(CO') .
--> ***************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ops bID bID' : -> BagOfID .
  ceq [robust-lemmaM22-IH :nonexec]:
     robust-lemmaM22(BID:BagOfID,co,co',sCO,sIM) = true
     if BID <wf bID .

:goal { eq robust-lemmaM22(bID, co, co', sCO, sIM) = true .}
:def idCOctf = :ctf {
  eq id(co') = id(co) .
}
:def fdisctf = :ctf {
  eq (fdis(co) >= fdis(co'))= true .
}
:apply (idCOctf fdisctf rd-)
:init as robust-lemmaM22-IH-in [robust-lemmaM22-IH]
      by {BID:BagOfID <- BID:BagOfID;}
:def bIDcsp = :csp {
  eq bID = empID .
  eq bID = (cid(idCO) bID') .
  eq bID = (iid(idIM) bID') .
}
:apply (bIDcsp rd-)
:def idCOidCOctf = :ctf {
  eq id(co) = idCO .
}
:apply (idCOidCOctf rd-)
--> Proof of robust-lemmaM22 done.
-->
show proof
close

--> ***********************************************
--> Proof of robust-lemmaM23.
-->  eq robust-lemmaM23(SIM,CO,SCO)
-->    = cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM)
-->    when isForced1(CO)
-->     and allFFCOHasFFIIM((CO SCO),SIM)
-->     and allFFIMHasFFECO(SIM,(CO SCO)) .
--> ***********************************************

open ROBUSTLEMMA .

  -- Sublemmas
  -- eq robust-lemmaM06(CO,SCO,SIM)
  --   = subbag(makeupIDBag(CO,(CO SCO),SIM),makeIDBag(SIM,(CO SCO),SIM))
  --   when isForced1(CO)
  --    and allFFCOHasFFIIM((CO SCO),SIM)
  --    and allFFIMHasFFECO(SIM,(CO SCO)) .
  ceq [robust-lemmaM06 :nonexec]:
    (subbag(makeupIDBag(CO,(CO SCO),SIM),makeIDBag(SIM,(CO SCO),SIM))) = true
    if isForced1(CO) and
       allFFCOHasFFIIM((CO SCO),SIM) and
       allFFIMHasFFECO(SIM,(CO SCO)) .

:goal { eq robust-lemmaM23(sIM, co, sCO) = true .}
:def isFCOctf = :ctf {
  eq isForced1(co) = true .
}
:apply (isFCOctf rd-)
:def allFFCOctf = :ctf {
  eq allFFCOHasFFIIM((co sCO), sIM) = true .
}  
:apply (allFFCOctf rd-)
:def allFFIMctf = :ctf {
  eq allFFIMHasFFECO(sIM, (co sCO)) = true .
}  
:apply (allFFIMctf rd-)
:init as robust-lemmaM06-in [robust-lemmaM06]
      by {CO:Component <- co;
          SIM:SetOfImport <- sIM;
          SCO:SetOfComponent <- sCO;}
:init as BagOfIDAxiom2-in [BagOfIDAxiom2]
      by {ID:CIID <- cid(id(co));
	  B1:BagOfID <- makeupIDBag(getIMsOfECOInTargetStates(sIM,id(co),wired),co sCO,sIM);
	  B2:BagOfID <- makeIDBag(sIM,(co sCO),sIM);}
:apply (rd-)
--> Proof of robust-lemmaM23 done.
-->
show proof
close

--> *******************************************************************
--> Proof of robust-lemmaM24.
-->  eq robust-lemmaM24(SIM,IDCO,SCO0,SIM0)
-->    = makeIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
-->      makeIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0)
-->    when canStart(IDCO,SCO0,SIM0)
-->     and subset(SIM,SIM0) .
--> *******************************************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM24-IH :nonexec]:
     robust-lemmaM24(SIM:SetOfImport,idCO,sCO0,sIM0) = true
     if SIM <wf (im sIM') .

  -- Sublemmas
  -- eq robust-lemmaM08(CO,IDCO,SCO0,SIM0)
  --   = (makeupIDBag(CO,(cmp(IDCO,started,started,started) SCO0),SIM0) =
  --      makeupIDBag(CO,(cmp(IDCO,stopped,started,started) SCO0),SIM0))
  --   when canStart(IDCO,SCO0,SIM0) .
  ceq makeupIDBag(CO,(cmp(IDCO,started,started,started) SCO0),SIM0) =
      makeupIDBag(CO,(cmp(IDCO,stopped,started,started) SCO0),SIM0)
    if canStart(IDCO,SCO0,SIM0) .

:goal { eq robust-lemmaM24(sIM, idCO, sCO0,sIM0) = true .}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def iminSIM0csp = :csp {
  eq (im in sIM0) = false .
  eq sIM0 = (im sIM0') .
}
:apply (iminSIM0csp rd-)
:def sIMsubsIM0csp = :csp {
  eq subset(sIM',im sIM0') = false .
  eq subset(sIM',sIM0') = true .
}
:apply (sIMsubsIM0csp rd-)
:def isForcingimcsp = :csp {
  eq isForcing(im) = false .
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,wired,unused) . 
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,unwired,unused) .
}
:apply (isForcingimcsp)
-- 2-2-2-1
:def canStartctf1 = :ctf {
  eq allIMStablyWired((if ((mandatory = type(im)) and (idCO = importer(im))) then (im getIMsOfTypeOfICO(sIM0',mandatory,idCO)) else getIMsOfTypeOfICO(sIM0',mandatory,idCO) fi),sCO0,(im sIM0')) = true .
}
:apply (canStartctf1 rd-)
:init as robust-lemmaM24-IH-in [robust-lemmaM24-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-2
:def idCOctf = :ctf {
  eq iidCO = idCO .
}
:apply (idCOctf rd-)
:def canStartctf2 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,idCO),sCO0,(imp(mandatory,idIM,iidCO,eidCO,wired,wired,unused) sIM0')) = true .
}
:apply (canStartctf2 rd-)
:init as robust-lemmaM24-IH-in [robust-lemmaM24-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-3
:apply (idCOctf rd-)
:def canStartctf3 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,idCO),sCO0,(imp(mandatory,idIM,iidCO,eidCO,wired,unwired,unused) sIM0')) = true .
}
:apply (canStartctf3 rd-)
:init as robust-lemmaM24-IH-in [robust-lemmaM24-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
--> Proof of robust-lemmaM24 done.
-->
show proof
close

--> ******************************************************
--> Proof of robust-lemmaM25.
-->  eq robust-lemmaM25(SIM,CO,SCO0,SIM0)
-->    = not (cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM0))
-->    when canStart(id(CO),(CO SCO0),SIM0)
-->     and subset(SIM,SIM0) .
--> ******************************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ceq [robust-lemmaM25-IH :nonexec]:
     robust-lemmaM25(SIM:SetOfImport,co,sCO0,sIM0) = true
     if SIM <wf (im sIM') .

  -- Sublemmas
  -- eq robust-lemmaM11(CO0,CO,SCO0,SIM0)
  --   = not (cid(id(CO)) in makeupIDBag(CO0,(CO SCO0),SIM0))
  --   when canStart(id(CO),(CO SCO0),SIM0)
  --    and not canStart(id(CO0),(CO SCO0),SIM0) .
  ceq (cid(id(CO)) in makeupIDBag(CO0,(CO SCO0),SIM0)) = false
    if canStart(id(CO),(CO SCO0),SIM0) and
       not canStart(id(CO0),(CO SCO0),SIM0) .

:goal { eq robust-lemmaM25(sIM, co, sCO0, sIM0) = true .}
:def sIMcsp = :csp {
  eq sIM = empIM .
  eq sIM = (im sIM') .
}
:apply (sIMcsp rd-)
:def iminSIM0csp = :csp {
  eq (im in sIM0) = false .
  eq sIM0 = (im sIM0') .
}
:apply (iminSIM0csp rd-)
:def sIMsubsIM0csp = :csp {
  eq subset(sIM',im sIM0') = false .
  eq subset(sIM',sIM0') = true .
}
:apply (sIMsubsIM0csp rd-)
:def isForcingimcsp = :csp {
  eq isForcing(im) = false .
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,wired,unused) . 
  eq im = imp(mandatory,idIM,iidCO,eidCO,wired,unwired,unused) .
}
:apply (isForcingimcsp)
-- 2-2-2-1
:def canStartctf1 = :ctf {
  eq allIMStablyWired((if ((mandatory = type(im)) and (id(co) = importer(im))) then (im getIMsOfTypeOfICO(sIM0',mandatory,id(co))) else getIMsOfTypeOfICO(sIM0',mandatory,id(co)) fi),(co sCO0),(im sIM0')) = true .
}
:apply (canStartctf1 rd-)
:init as robust-lemmaM25-IH-in [robust-lemmaM25-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-2
:def idCOctf = :ctf {
  eq iidCO = id(co) .
}
:apply (idCOctf rd-)
:def canStartctf2 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,id(co)),(co sCO0),(imp(mandatory,idIM,iidCO,eidCO,wired,wired,unused) sIM0')) = true .
}
:apply (canStartctf2 rd-)
:init as robust-lemmaM25-IH-in [robust-lemmaM25-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
-- 2-2-2-3
:apply (idCOctf rd-)
:def canStartctf3 = :ctf {
  eq allIMStablyWired(getIMsOfTypeOfICO(sIM0',mandatory,id(co)),(co sCO0),(imp(mandatory,idIM,iidCO,eidCO,wired,unwired,unused) sIM0')) = true .
}
:apply (canStartctf3 rd-)
:init as robust-lemmaM25-IH-in [robust-lemmaM25-IH]
      by {SIM:SetOfImport <- sIM';}
:apply (rd-)
--> Proof of robust-lemmaM25 done.
-->
show proof
close

--> **************************************************
--> Proof of robust-lemmaM27.
-->  eq robust-lemmaM27(BID,CO,SCO,SIM)
-->    = (fdis(BID,(CO  SCO),SIM) = fdis(BID,SCO,SIM))
-->    when not cid(id(CO)) in BID .
--> **************************************************

open ROBUSTLEMMA .
  -- Induction Hypothesis
  ops bID bID' : -> BagOfID .
  ceq [robust-lemmaM27-IH :nonexec]:
     robust-lemmaM27(BID:BagOfID,co,sCO,sIM) = true
     if BID <wf bID .

:goal { eq robust-lemmaM27(bID, co, sCO, sIM) = true .}
:init as robust-lemmaM27-IH-in [robust-lemmaM27-IH]
      by {BID:BagOfID <- BID:BagOfID;}
:def bIDcsp = :csp {
  eq bID = empID .
  eq bID = (cid(idCO) bID') .
  eq bID = (iid(idIM) bID') .
}
:apply (bIDcsp rd-)
:def idCOidCOctf = :ctf {
  eq id(co) = idCO .
}
:apply (idCOidCOctf rd-)
--> Proof of robust-lemmaM27 done.
-->
show proof
close

--> Totally 17 goals should be proved.
