require PROOF Proof.cafe

--> ***************************
--> (3) init(S) implies inv(S).
--> (4) inv(S) implies inv(SS).
--> ***************************

-- There are 13 wfs's or inv's:
  -- Following 5 wfs's are completely structural and keep to hold if there is no rule changing the sturucture
  -- wfs-uniqCO(S), wfs-uniqIM(S), wfs-allIMHaveICO(S), wfs-allIMHaveECO(S), wfs-iidCOeidCODiffer(S) .
  -- Following 8 wfs's or inv's should be proved as invariants.
  -- wfs-validCurrent(S), wfs-validNext(S), wfs-validTarget(S),
  -- noCOCycleU(S), noCOCycleD(S),
  -- inv-allCOin9States(S), inv-allIMin14States(S), inv-noChangeSstarted(S) .

--> **************************************
--> Proof of wfs-validCurrent.
-->  eq wfs-validCurrent(< SCO, SIM, L >)
-->    = validCurrent(SCO,SIM) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofwfs-validCurrent {
  protecting(PROOF)
  var S : State
  eq invK(S) = wfs-validCurrent(S) .

  -- Lemmas
  vars CO CO' : Component
  vars IDCO IIDCO EIDCO : COID
  vars IM IM' : Import
  var IDIM : IMID
  var TIM : IMType
  vars SCO SCO0 : SetOfComponent
  vars SIM SIM0 : SetOfImport
  var StIM : SetOfIMState

  -- eq robust-lemma01(CO,IDCO,SCO,SIM,StIM) 
  --   = (getECOsOfIMs((CO SCO),getIMsOfICOInStates(SIM,IDCO,StIM)) =
  --      getECOsOfIMs(SCO,     getIMsOfICOInStates(SIM,IDCO,StIM)))
  --     when id(CO) = IDCO and iidCOeidCODiffer(SIM) .
  ceq getECOsOfIMs((CO SCO),getIMsOfICOInStates(SIM,IDCO,StIM)) =
      getECOsOfIMs(SCO,     getIMsOfICOInStates(SIM,IDCO,StIM))
    if id(CO) = IDCO and iidCOeidCODiffer(SIM) .

  -- eq robust-lemmaV03(CO,CO',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,(CO  SCO0),SIM0) implies 
  --     validCurrentComponent(SCO,(CO' SCO0),SIM0)
  --     when changeObjState2(CO,CO') .
  ceq (validCurrentComponent(SCO,(CO  SCO0),SIM0) and
       validCurrentComponent(SCO,(CO' SCO0),SIM0))
     = validCurrentComponent(SCO,(CO  SCO0),SIM0)
    if changeObjState2(CO,CO') .

  -- eq robust-lemmaV03-1(IM,IM',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(IM  SIM0)) implies 
  --     validCurrentComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState2(IM,IM') .
  ceq (validCurrentComponent(SCO,SCO0,(IM  SIM0)) and
       validCurrentComponent(SCO,SCO0,(IM' SIM0)))
     = validCurrentComponent(SCO,SCO0,(IM  SIM0))
    if changeObjState2(IM,IM') .

  -- pred robust-lemmaV04 : Component Component SetOfComponent SetOfComponent SetOfImport
  -- eq robust-lemmaV04(CO,CO',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,(CO  SCO0),SIM0) implies 
  --     validCurrentComponent(SCO,(CO' SCO0),SIM0)
  --     when state(CO') = stopped and changeObjState(CO,CO') and subset(SCO,SCO0) and
  -- 	   uniqCO(CO SCO0) and
  --          getICOsOfIMsInStates(SCO0,
  --                               getIMsOfECOInStates(SIM0,id(CO),(wired swired)),
  --                               (started sstarted)) = empCO .
  ceq (validCurrentComponent(SCO,(CO  SCO0),SIM0) and
       validCurrentComponent(SCO,(CO' SCO0),SIM0))
     = validCurrentComponent(SCO,(CO SCO0),SIM0)
     if state(CO') = stopped and changeObjState(CO,CO') and subset(SCO,SCO0) and
        uniqCO(CO SCO0) and
        getICOsOfIMsInStates(SCO0,
                             getIMsOfECOInStates(SIM0,id(CO),(wired swired)),
                             (started sstarted)) = empCO .

  -- pred robust-lemmaV05 : Component Component SetOfComponent SetOfComponent SetOfImport
  -- eq robust-lemmaV05(CO,CO',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,(CO  SCO0),SIM0) implies 
  --     validCurrentComponent(SCO,(CO' SCO0),SIM0)
  --     when (state(CO') in (started sstarted)) and changeObjState(CO,CO') and subset(SCO,SCO0) and
  --          uniqCO(CO SCO0) and iidCOeidCODiffer(SIM0) and
  --          allCOInStates(getECOsOfIMs(SCO0,getIMsOfICOInStates(SIM0,id(CO),(wired swired))),
  -- 	                 (started sstarted)) .
  ceq (validCurrentComponent(SCO,(CO  SCO0),SIM0) and
       validCurrentComponent(SCO,(CO' SCO0),SIM0))
     = validCurrentComponent(SCO,(CO SCO0),SIM0)
     if (state(CO') in (started sstarted)) and changeObjState(CO,CO') and subset(SCO,SCO0) and
        uniqCO(CO SCO0) and iidCOeidCODiffer(SIM0) and
        allCOInStates(getECOsOfIMs(SCO0,getIMsOfICOInStates(SIM0,id(CO),(wired swired))),
	              (started sstarted)) .

  -- eq robust-lemmaV06(IM,IM',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(IM  SIM0)) implies 
  --     validCurrentComponent(SCO,SCO0,(IM' SIM0))
  --   when changeObjState(IM,IM') and
  --        state(IM') = unwired and type(IM') = optional .
  ceq (validCurrentComponent(SCO,SCO0,(IM  SIM0)) and
       validCurrentComponent(SCO,SCO0,(IM' SIM0)))
     = validCurrentComponent(SCO,SCO0,(IM  SIM0))
     if changeObjState(IM,IM') and
        state(IM') = unwired and type(IM') = optional .

  -- eq robust-lemmaV07(IM,IM',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(IM  SIM0)) implies 
  --     validCurrentComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState(IM,IM') and subset(SCO,SCO0) and
  --          state(getComponent(SCO0,importer(IM))) = stopped .
  ceq (validCurrentComponent(SCO,SCO0,(IM  SIM0)) and
       validCurrentComponent(SCO,SCO0,(IM' SIM0)))
     = validCurrentComponent(SCO,SCO0,(IM  SIM0))
     if changeObjState(IM,IM') and subset(SCO,SCO0) and 
        state(getComponent(SCO0,importer(IM))) = stopped .

  -- eq robust-lemmaV08(IM,IM',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(IM  SIM0)) implies 
  --     validCurrentComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState(IM,IM') and
  --          state(IM') = unused .
  ceq (validCurrentComponent(SCO,SCO0,(IM  SIM0)) and
       validCurrentComponent(SCO,SCO0,(IM' SIM0)))
    = validCurrentComponent(SCO,SCO0,(IM SIM0))
    if changeObjState(IM,IM') and
       state(IM') = unused .

  -- pred robust-lemmaV09 : Import Import SetOfComponent SetOfComponent SetOfImport
  -- eq robust-lemmaV09(IM,IM',SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(IM  SIM0)) implies 
  --     validCurrentComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState(IM,IM') and subset(SCO,SCO0) and
  -- 	   iidCOeidCODiffer(IM SIM0) and
  --          state(getComponent(SCO0,exporter(IM))) in (started sstarted) and
  --          state(IM') = wired .
  ceq (validCurrentComponent(SCO,SCO0,(IM  SIM0)) and
       validCurrentComponent(SCO,SCO0,(IM' SIM0)))
     = validCurrentComponent(SCO,SCO0,(IM  SIM0))
     if changeObjState(IM,IM') and subset(SCO,SCO0) and 
        iidCOeidCODiffer(IM SIM0) and
        state(getComponent(SCO0,exporter(IM))) in (started sstarted) and
	state(IM') = wired .

  -- eq robust-lemmaV10(TIM,IDIM,IIDCO,EIDCO,SCO,SCO0,SIM0)
  --   = validCurrentComponent(SCO,SCO0,(imp(TIM,IDIM,IIDCO,EIDCO, wired,swired,swired) SIM0)) implies
  --     validCurrentComponent(SCO,SCO0,(imp(TIM,IDIM,IIDCO,EIDCO,swired,swired,swired) SIM0)) .
  eq (validCurrentComponent(SCO,SCO0,(imp(TIM,IDIM,IIDCO,EIDCO, wired,swired,swired) SIM0)) and
      validCurrentComponent(SCO,SCO0,(imp(TIM,IDIM,IIDCO,EIDCO,swired,swired,swired) SIM0)))
    = validCurrentComponent(SCO,SCO0,(imp(TIM,IDIM,IIDCO,EIDCO, wired,swired,swired) SIM0)) .

}

--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
-- Since wfs-validCurrent is imposed by init(S), initinv(S) for wfs-validCurrent always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************

-- This goal requires robust-lemmaV03.
open Proofwfs-validCurrent .
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV04.
open Proofwfs-validCurrent .
--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
:def uniqCOctf = :ctf {
  eq uniqCO(cmp(idCO, started, stopped, tCOs) sCO) = true .
}
:apply (uniqCOctf rd-)
--> Proof of RD-stop for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03.
open Proofwfs-validCurrent .
--> *************************************************************************
-->  ctrans [RS-stop2]:
-->     < (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->	  mlog(
-->       (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > 
-->     if CSIM in (wired unused) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, cIMs, unwired, tIMs) sIM),
              lg >) = true .
}
:def cIMscsp = :csp {
  eq cIMs = unused .
  eq cIMs = wired .
}
:apply (cIMscsp rd-)
-- Case 1: unused (RS-sstarted2 may be applied)
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def tIMsctf = :ctf {
  eq tIMs = unused . 
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B tIMsctf rd-)
--> Proof of RS-stop2 for inv-validCurrent done.
-->
show proof
close


-- This goal requires robust-lemmaV03.
open Proofwfs-validCurrent .
--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(stopped,sstarted) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, sstarted) sCO), sIM, 
               lg >) = true .
}
:apply (rd-)
--> Proof of RS-sstart1 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03.
open Proofwfs-validCurrent .
--> ****************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,sstarted) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B rd-)
--> Proof of RS-sstart2 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemma01.
-- This goal requires robust-lemmaV05.
open Proofwfs-validCurrent .
--> ********************************************************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) and
-->       allCOInStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,(wired swired))),(started sstarted)) .
--> ********************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(stopped,started) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, sstarted, sstarted) sCO), sIM,
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-startA = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RD-startB = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def csp4-2RD-startC = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),
                   (started sstarted)) = true .
}
:apply (csp4-2RD-startA csp4-2RD-startB csp4-2RD-startC rd-)
:def differctf = :ctf {
  eq iidCOeidCODiffer(sIM) = true .
}
:apply (differctf rd-)
:def uniqCOctf = :ctf {
  eq existCO(sCO,idCO) = true .
}
:apply (uniqCOctf rd-)
:def uniqCO'ctf = :ctf {
  eq uniqCO(sCO) = true .
}
:apply (uniqCO'ctf rd-)
--> Proof of RD-start for inv-validCurrent done.
-->
show proof
close

open Proofwfs-validCurrent .
--> ********************************************************************************
--> trans [RD-sstart]:
-->    < (cmp(IDCO,  started, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, sstarted, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-sstart:Do Stably Start", cmp(IDCO, sstarted, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, sstarted, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, sstarted, started) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-sstart for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
open Proofwfs-validCurrent .
--> *********************************************************************************************
--> trans [RS-unwire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->      (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, wired, unwired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire1 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV06.
open Proofwfs-validCurrent .
--> ********************************************************************************************
--> trans [RD-unwire1]:
-->    < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< sCO,
              (imp(optional, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire1 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV07.
-- This goal requires robust-lemmaV08.
open Proofwfs-validCurrent .
--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire2 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
open Proofwfs-validCurrent .
--> *********************************************************************************************
--> trans [RS-unused]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused) SIM),
-->      (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, unused) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unused) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,  wired, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unused for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV08.
open Proofwfs-validCurrent .
--> **************************************************************************************
--> trans [RD-unused]:
-->    < SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused) SIM),
-->      (ilog("RD-unused:Do Unwire", imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM)
-->      )) ListLG) > .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unused) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, idCO, eidCO,  wired, unused, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unused for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
-- This goal requires robust-lemmaV06.
open Proofwfs-validCurrent .
--> *********************************************************************************************
--> trans [RS-unwire2]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired) SIM),
-->      (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire2 for inv-validCurrent done.
-->
show proof
close

open Proofwfs-validCurrent .
--> ******************************************************************************************
--> trans [RD-unwire3]:
-->    < SCO, (imp(optional, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(optional, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      (ilog("RD-unwire3:Do Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(optional, idIM, iidCO, eidCO,  unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV07.
-- This goal requires robust-lemmaV08.
open Proofwfs-validCurrent .
--> ************************************************************************************************
-->  trans [RD-unwire4]:
-->     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,  unused, unwired, swired) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired) SIM),
-->       (ilog("RD-unwire4:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired),
-->	  mlog(
-->       (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,   unused, unwired, swired) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *****************************************************************************************
--> Step 4-1: Begin with the most general case which is matched with LHS of the current rule.
--> *****************************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
open Proofwfs-validCurrent .
--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unwired,swired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire1 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
open Proofwfs-validCurrent .
--> ****************************************************************************************
--> trans [RS-swire2]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired) SIM),
-->      (ilog("RS-swire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, swired) SIM)
-->      )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,swired) = true .
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,  wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire2 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV03-1.
-- This goal requires robust-lemmaV04.
open Proofwfs-validCurrent .
--> ********************************************************************************************
--> trans [RS-unwire3]:
-->    < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired) SIM),
-->      (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired),
-->       mlog(
-->      (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(eidCO, started, stopped, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired, wired, swired) sIM),
              lg >) = true .
}
-- Case root: (RD-stop may be applied)
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          (imp(tIM,idIM,iidCO,eidCO,wired,wired,swired) 
                           getIMsOfECOInStates(sIM,eidCO,(wired swired))),
                          (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
:def uniqCOctf = :ctf {
  eq uniqCO(cmp(eidCO, started, stopped, sstarted) sCO) = true .
}
:apply (uniqCOctf rd-)
--> Proof of RS-unwire3 for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV09.
open Proofwfs-validCurrent .
--> ***********************************************************************************
--> trans [RD-wire]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO,   wired, swired, swired) SIM),
-->      (ilog("RD-wire:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM)
-->      )) ListLG) > .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unwired,wired) = true .
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, unwired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
:def Differctp = :ctf {
  eq iidCOeidCODiffer(sIM) = true .
}
:apply (Differctp rd-)
--> Proof of RD-wire for inv-validCurrent done.
-->
show proof
close

-- This goal requires robust-lemmaV10.
open Proofwfs-validCurrent .
--> *******************************************************************************************
--> trans [RD-swire]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired) SIM),
-->      (ilog("RD-swire:Do Stably Wire", imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM)
-->      )) ListLG) > .
--> *******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-swire for inv-validCurrent done.
-->
show proof
close

--> **************************************
--> Proof of wfs-validNext.
-->  eq wfs-validNext(< SCO, SIM, L >)
-->    = validNext(SCO,SIM) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofwfs-validNext {
  protecting(PROOF)
  var S : State
  eq invK(S) = wfs-validNext(S) .

  -- Lemmas
  vars CO CO' : Component
  var IDCO : COID
  vars IM IM' : Import
  var IDIM : IMID
  vars SCO SCO0 : SetOfComponent
  vars SIM SIM0 : SetOfImport
  var StIM : SetOfIMState

}

--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
-- Since wfs-validNext is imposed by init(S), initinv(S) for wfs-validNext always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************

open Proofwfs-validNext .
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
:def noswiredcsp = :csp {
  eq getIMsOfECOInStates(sIM,idCO,swired) = empIM .
  eq sIM = (imp(tIM,idIM,iidCO,idCO,swired,nIMs,tIMs) sIM') .
}
:apply (noswiredcsp rd-)
:def nIMscsp = :csp {
  eq nIMs = unused .
  eq nIMs = wired .
  eq nIMs = swired .
  eq nIMs = unwired .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (nIMscsp tIMscsp rd-)
--> Proof of RS-stop1 for inv-validNext done.
-->
show proof
close

open Proofwfs-validNext .
--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
:def swiredctf = :ctf {
  eq getIMsOfECOInStates(sIM,idCO,swired) = empIM .
}
:apply (swiredctf rd-)
--> Proof of RD-stop for inv-validNext done.
-->
show proof
close

--> **************************************
--> Proof of wfs-validTarget.
-->  eq wfs-validTarget(< SCO, SIM, L >)
-->    = validTarget(SCO,SIM) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofwfs-validTarget {
  protecting(PROOF)
  var S : State
  eq invK(S) = wfs-validTarget(S) .

  -- Lemmas
  vars CO CO' : Component
  vars IM IM' : Import
  vars SCO SCO0 : SetOfComponent
  var SIM0 : SetOfImport

  -- eq robust-lemmaV01(CO,CO',SCO,SCO0,SIM0)
  --   = validTargetComponent(SCO,(CO  SCO0),SIM0) implies 
  --     validTargetComponent(SCO,(CO' SCO0),SIM0)
  --     when changeObjState(CO,CO') .
  ceq (validTargetComponent(SCO,(CO  SCO0),SIM0) and
       validTargetComponent(SCO,(CO' SCO0),SIM0))
     = validTargetComponent(SCO,(CO  SCO0),SIM0)
    if changeObjState(CO,CO') .

  -- eq robust-lemmaV01-2(CO,CO',SCO,SCO0,SIM0)
  --   = validTargetComponent(SCO,(CO  SCO0),SIM0) implies 
  --     validTargetComponent(SCO,(CO' SCO0),SIM0)
  --     when changeObjState2(CO,CO') .
  ceq (validTargetComponent(SCO,(CO  SCO0),SIM0) and
       validTargetComponent(SCO,(CO' SCO0),SIM0))
     = validTargetComponent(SCO,(CO  SCO0),SIM0)
    if changeObjState2(CO,CO') .

  -- eq robust-lemmaV02(CO,CO',SCO0,SIM0)
  --   = validTargetImport(SIM0,(CO  SCO0)) implies 
  --     validTargetImport(SIM0,(CO' SCO0))
  --     when changeObjState(CO,CO') .
  ceq (validTargetImport(SIM0,(CO  SCO0)) and
       validTargetImport(SIM0,(CO' SCO0)))
     = validTargetImport(SIM0,(CO  SCO0))
    if changeObjState(CO,CO') .

  -- eq robust-lemmaV02-2(CO,CO',SCO0,SIM0)
  --   = validTargetImport(SIM0,(CO  SCO0)) implies 
  --     validTargetImport(SIM0,(CO' SCO0))
  --     when changeObjState2(CO,CO') .
  ceq (validTargetImport(SIM0,(CO  SCO0)) and
       validTargetImport(SIM0,(CO' SCO0)))
     = validTargetImport(SIM0,(CO  SCO0))
    if changeObjState2(CO,CO') .

  -- eq robust-lemmaV11(IM,IM',SCO,SCO0,SIM0)
  --   = validTargetComponent(SCO,SCO0,(IM  SIM0)) implies
  --     validTargetComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState(IM,IM') .
  ceq (validTargetComponent(SCO,SCO0,(IM  SIM0)) and
       validTargetComponent(SCO,SCO0,(IM' SIM0)))
     = validTargetComponent(SCO,SCO0,(IM  SIM0))
    if changeObjState(IM,IM') .

  -- eq robust-lemmaV11-1(IM,IM',SCO,SCO0,SIM0)
  --   = validTargetComponent(SCO,SCO0,(IM  SIM0)) implies
  --     validTargetComponent(SCO,SCO0,(IM' SIM0))
  --     when changeObjState2(IM,IM') .
  ceq (validTargetComponent(SCO,SCO0,(IM  SIM0)) and
       validTargetComponent(SCO,SCO0,(IM' SIM0)))
     = validTargetComponent(SCO,SCO0,(IM  SIM0))
    if changeObjState2(IM,IM') .
}

--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
-- Since wfs-validTarget is imposed by init(S), initinv(S) for wfs-validTarget always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
-- This goal requires robust-lemmaV01-2.
-- This goal requires robust-lemmaV02-2.
open Proofwfs-validTarget .
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01.
-- This goal requires robust-lemmaV02.
open Proofwfs-validTarget .
--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
:def tCOscsp = :csp {
  eq tCOs =  stopped .
  eq tCOs =  started .
  eq tCOs = sstarted .
}
:apply (tCOscsp rd-)
--> Proof of RD-stop for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01-2.
-- This goal requires robust-lemmaV02-2.
open Proofwfs-validTarget .
--> *************************************************************************
--> ctrans [RS-stop2]:
-->    < (cmp(IDCO, started, started, sstarted) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->       ListLG >
--> => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->      (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, started, sstarted) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > 
-->     if CSIM in (wired unused) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, cIMs, unwired, tIMs) sIM),
              lg >) = true .
}
:def cIMscsp = :csp {
  eq cIMs = unused .
  eq cIMs = wired .
}
:apply (cIMscsp rd-)
-- Case 1: unused (RS-sstarted2 may be applied)
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def tIMsctf = :ctf {
  eq tIMs = unused . 
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B tIMsctf rd-)
--> Proof of RS-stop2 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01-2.
-- This goal requires robust-lemmaV02-2.
open Proofwfs-validTarget .
--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(stopped,sstarted) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, sstarted) sCO), sIM, 
               lg >) = true .
}
:apply (rd-)
--> Proof of RS-sstart1 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01-2.
-- This goal requires robust-lemmaV02-2.
open Proofwfs-validTarget .
--> ****************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,sstarted) = true .
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B rd-)
--> Proof of RS-sstart2 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01.
-- This goal requires robust-lemmaV02.
open Proofwfs-validTarget .
--> ********************************************************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) and
-->       allCOInStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,(wired swired))),(started sstarted)) .
--> ********************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(stopped,started ) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, sstarted, sstarted) sCO), sIM,
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-startA = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RD-startB = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def csp4-2RD-startC = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),
                   (started sstarted)) = true .
}
:apply (csp4-2RD-startA csp4-2RD-startB csp4-2RD-startC rd-)
--> Proof of RD-start for inv-validTarget done.
-->
show proof
close

open Proofwfs-validTarget .
--> ********************************************************************************
--> trans [RD-sstart]:
-->    < (cmp(IDCO,  started, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, sstarted, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-sstart:Do Stably Start", cmp(IDCO, sstarted, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, sstarted, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(started,sstarted) = true .
:goal {
  eq invinv(< (cmp(idCO, started, sstarted, started) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-sstart for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> *********************************************************************************************
--> trans [RS-unwire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->      (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, wired, unwired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire1 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> ********************************************************************************************
--> trans [RD-unwire1]:
-->    < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< sCO,
              (imp(optional, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire1 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire2 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> *********************************************************************************************
--> trans [RS-unused]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused) SIM),
-->      (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, unused) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unused) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,  wired, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unused for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> **************************************************************************************
--> trans [RD-unused]:
-->    < SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused) SIM),
-->      (ilog("RD-unused:Do Unwire", imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM)
-->      )) ListLG) > .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unused) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, idCO, eidCO,  wired, unused, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unused for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> *********************************************************************************************
--> trans [RS-unwire2]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired) SIM),
-->      (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire2 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> ******************************************************************************************
--> trans [RD-unwire3]:
-->    < SCO, (imp(optional, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(optional, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      (ilog("RD-unwire3:Do Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< sCO, (imp(optional, idIM, iidCO, eidCO,  unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> ************************************************************************************************
-->  trans [RD-unwire4]:
-->     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,  unused, unwired, swired) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired) SIM),
-->       (ilog("RD-unwire4:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired),
-->	  mlog(
-->       (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,   unused, unwired, swired) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *****************************************************************************************
--> Step 4-1: Begin with the most general case which is matched with LHS of the current rule.
--> *****************************************************************************************
-- Set the direction of state change.
eq transitsTo(unused,unwired) = true .
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire4 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unwired,swired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire1 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> ****************************************************************************************
--> trans [RS-swire2]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired) SIM),
-->      (ilog("RS-swire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, swired) SIM)
-->      )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,swired) = true .
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,  wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire2 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV01.
-- This goal requires robust-lemmaV02.
-- This goal requires robust-lemmaV11-1.
open Proofwfs-validTarget .
--> ********************************************************************************************
--> trans [RS-unwire3]:
-->    < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired) SIM),
-->      (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired),
-->       mlog(
-->      (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,unwired) = true .
-- conditonal rule rd-stop may be applied.
eq transitsTo(started,stopped) = true .
:goal {
  eq invinv(< (cmp(eidCO, started, stopped, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired, wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire3 for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> ***********************************************************************************
--> trans [RD-wire]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO,   wired, swired, swired) SIM),
-->      (ilog("RD-wire:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM)
-->      )) ListLG) > .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(unwired,wired) = true .
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, unwired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-wire for inv-validTarget done.
-->
show proof
close

-- This goal requires robust-lemmaV11.
open Proofwfs-validTarget .
--> *******************************************************************************************
--> trans [RD-swire]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired) SIM),
-->      (ilog("RD-swire:Do Stably Wire", imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM)
-->      )) ListLG) > .
--> *******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
-- Set the direction of state change.
eq transitsTo(wired,swired) = true .
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-swire for inv-validTarget done.
-->
show proof
close

--> **************************************
--> Proof of inv-allCOin9States.
-->  eq inv-allCOin9States(< SCO,SIM,L >)
-->    = allCOin9States(SIM) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-allCOin9States {
  protecting(PROOF)
  var S : State
  eq invK(S) = inv-allCOin9States(S) .
}

select Proofinv-allCOin9States
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
-- Since inv-allCOin9States is imposed by init(S), initinv(S) for inv-allCOin9States always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 for inv-allCOin9States done.
-->
show proof

--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
:def tCOscsp = :csp {
  eq tCOs =  stopped .
  eq tCOs =  started .
  eq tCOs = sstarted .
}
:apply (tCOscsp rd-)
--> Proof of RD-stop for inv-allCOin9States done.
-->
show proof

--> *************************************************************************
--> *************************************************************************
-->  ctrans [RS-stop2]:
-->     < (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->	  mlog(
-->       (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > 
-->     if CSIM in (wired unused) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, cIMs, unwired, tIMs) sIM),
              lg >) = true .
}
:def cIMscsp = :csp {
  eq cIMs = unused .
  eq cIMs = wired .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (cIMscsp tIMscsp rd-)
--> Proof of RS-stop2 for inv-allCOin9States done.
-->
show proof

--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, sstarted) sCO), sIM, 
               lg >) = true .
}
:apply (rd-)
--> Proof of RS-sstart1 for inv-allCOin9States done.
-->
show proof

--> ****************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B rd-)
--> Proof of RS-sstart2 for inv-allCOin9States done.
-->
show proof

--> ********************************************************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) and
-->       allCOInStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,(wired swired))),(started sstarted)) .
--> ********************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, sstarted, sstarted) sCO), sIM,
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-startA = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RD-startB = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def csp4-2RD-startC = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),
                   (started sstarted)) = true .
}
:apply (csp4-2RD-startA csp4-2RD-startB csp4-2RD-startC rd-)
--> Proof of RD-start for inv-allCOin9States done.
-->
show proof

--> ********************************************************************************
--> trans [RD-sstart]:
-->    < (cmp(IDCO,  started, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, sstarted, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-sstart:Do Stably Start", cmp(IDCO, sstarted, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, sstarted, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, sstarted, started) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-sstart for inv-allCOin9States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->      (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, wired, unwired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire1 for inv-allCOin9States done.
-->
show proof

--> ********************************************************************************************
--> trans [RD-unwire1]:
-->    < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO,
              (imp(optional, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire1 for inv-allCOin9States done.
-->
show proof

--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire2 for inv-allCOin9States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unused]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused) SIM),
-->      (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, unused) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,  wired, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unused for inv-allCOin9States done.
-->
show proof

--> **************************************************************************************
--> trans [RD-unused]:
-->    < SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused) SIM),
-->      (ilog("RD-unused:Do Unwire", imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM)
-->      )) ListLG) > .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, idCO, eidCO,  wired, unused, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unused for inv-allCOin9States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire2]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired) SIM),
-->      (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire2 for inv-allCOin9States done.
-->
show proof

--> ******************************************************************************************
--> trans [RD-unwire3]:
-->    < SCO, (imp(optional, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(optional, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      (ilog("RD-unwire3:Do Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(optional, idIM, iidCO, eidCO,  unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-allCOin9States done.
-->
show proof

--> ************************************************************************************************
-->  trans [RD-unwire4]:
-->     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,  unused, unwired, swired) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired) SIM),
-->       (ilog("RD-unwire4:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired),
-->	  mlog(
-->       (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,   unused, unwired, swired) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *****************************************************************************************
--> Step 4-1: Begin with the most general case which is matched with LHS of the current rule.
--> *****************************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire4 for inv-allCOin9States done.
-->
show proof

--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire1 for inv-allCOin9States done.
-->
show proof

--> ****************************************************************************************
--> trans [RS-swire2]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired) SIM),
-->      (ilog("RS-swire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, swired) SIM)
-->      )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,  wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire2 for inv-allCOin9States done.
-->
show proof

--> ********************************************************************************************
--> trans [RS-unwire3]:
-->    < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired) SIM),
-->      (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired),
-->       mlog(
-->      (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, started, stopped, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired, wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire3 for inv-allCOin9States done.
-->
show proof

--> ***********************************************************************************
--> trans [RD-wire]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO,   wired, swired, swired) SIM),
-->      (ilog("RD-wire:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM)
-->      )) ListLG) > .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, unwired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-wire for inv-allCOin9States done.
-->
show proof

--> *******************************************************************************************
--> trans [RD-swire]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired) SIM),
-->      (ilog("RD-swire:Do Stably Wire", imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM)
-->      )) ListLG) > .
--> *******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-swire for inv-allCOin9States done.
-->
show proof

--> **************************************
--> Proof of inv-allIMin14States.
-->  eq inv-allIMin14States(< SCO,SIM,L >)
-->    = allIMin14States(SIM) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-allIMin14States {
  protecting(PROOF)
  var S : State
  eq invK(S) = inv-allIMin14States(S) .
}

select Proofinv-allIMin14States
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
-- Since inv-allIMin14States is imposed by init(S), initinv(S) for inv-allIMin14States always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 for inv-allIMin14States done.
-->
show proof

--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
--> Proof of RD-stop for inv-allIMin14States done.
-->
show proof

--> *************************************************************************
--> *************************************************************************
-->  ctrans [RS-stop2]:
-->     < (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->	  mlog(
-->       (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > 
-->     if CSIM in (wired unused) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, cIMs, unwired, tIMs) sIM),
              lg >) = true .
}
:def cIMscsp = :csp {
  eq cIMs = unused .
  eq cIMs = wired .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (cIMscsp tIMscsp rd-)
--> Proof of RS-stop2 for inv-allIMin14States done.
-->
show proof

--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, sstarted) sCO), sIM, 
               lg >) = true .
}
:apply (rd-)
--> Proof of RS-sstart1 for inv-allIMin14States done.
-->
show proof

--> ****************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B rd-)
--> Proof of RS-sstart2 for inv-allIMin14States done.
-->
show proof

--> ********************************************************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) and
-->       allCOInStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,(wired swired))),(started sstarted)) .
--> ********************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, sstarted, sstarted) sCO), sIM,
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-startA = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RD-startB = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def csp4-2RD-startC = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),
                   (started sstarted)) = true .
}
:apply (csp4-2RD-startA csp4-2RD-startB csp4-2RD-startC rd-)
--> Proof of RD-start for inv-allIMin14States done.
-->
show proof

--> ********************************************************************************
--> trans [RD-sstart]:
-->    < (cmp(IDCO,  started, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, sstarted, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-sstart:Do Stably Start", cmp(IDCO, sstarted, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, sstarted, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, sstarted, started) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-sstart for inv-allIMin14States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->      (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, wired, unwired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire1 for inv-allIMin14States done.
-->
show proof

--> ********************************************************************************************
--> trans [RD-unwire1]:
-->    < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO,
              (imp(optional, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire1 for inv-allIMin14States done.
-->
show proof

--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire2 for inv-allIMin14States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unused]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused) SIM),
-->      (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, unused) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,  wired, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unused for inv-allIMin14States done.
-->
show proof

--> **************************************************************************************
--> trans [RD-unused]:
-->    < SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused) SIM),
-->      (ilog("RD-unused:Do Unwire", imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM)
-->      )) ListLG) > .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, idCO, eidCO,  wired, unused, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unused for inv-allIMin14States done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire2]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired) SIM),
-->      (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire2 for inv-allIMin14States done.
-->
show proof

--> ******************************************************************************************
--> trans [RD-unwire3]:
-->    < SCO, (imp(optional, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(optional, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      (ilog("RD-unwire3:Do Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(optional, idIM, iidCO, eidCO,  unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-allIMin14States done.
-->
show proof

--> ************************************************************************************************
-->  trans [RD-unwire4]:
-->     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,  unused, unwired, swired) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired) SIM),
-->       (ilog("RD-unwire4:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired),
-->	  mlog(
-->       (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,   unused, unwired, swired) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *****************************************************************************************
--> Step 4-1: Begin with the most general case which is matched with LHS of the current rule.
--> *****************************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire4 for inv-allIMin14States done.
-->
show proof

--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire1 for inv-allIMin14States done.
-->
show proof

--> ****************************************************************************************
--> trans [RS-swire2]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired) SIM),
-->      (ilog("RS-swire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, swired) SIM)
-->      )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,  wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire2 for inv-allIMin14States done.
-->
show proof

--> ********************************************************************************************
--> trans [RS-unwire3]:
-->    < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired) SIM),
-->      (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired),
-->       mlog(
-->      (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, started, stopped, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired, wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire3 for inv-allIMin14States done.
-->
show proof

--> ***********************************************************************************
--> trans [RD-wire]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO,   wired, swired, swired) SIM),
-->      (ilog("RD-wire:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM)
-->      )) ListLG) > .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, unwired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-wire for inv-allIMin14States done.
-->
show proof

--> *******************************************************************************************
--> trans [RD-swire]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired) SIM),
-->      (ilog("RD-swire:Do Stably Wire", imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM)
-->      )) ListLG) > .
--> *******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-swire for inv-allIMin14States done.
-->
show proof

--> **************************************
--> Proof of inv-noChangeSstarted.
-->  eq inv-noChangeSstarted(< SCO, SIM, L >)
-->    = noChangeSstarted(SCO) .
--> **************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-noChangeSstarted {
  protecting(PROOF)
  var S : State
  eq invK(S) = inv-noChangeSstarted(S) .
}

select Proofinv-noChangeSstarted
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
-- Since inv-noChangeSstarted is imposed by init(S), initinv(S) for inv-noChangeSstarted always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
-->       mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 for inv-noChangeSstarted done.
-->
show proof

--> ************************************************************************
--> ctrans [RD-stop]:
-->    < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->      (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped, TSCO),
-->       mlog(
-->      (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->      )) ListLG) >
-->    if getICOsOfIMsInStates(SCO,
-->                            getIMsOfECOInStates(SIM,IDCO,(wired swired)),
-->                            (started sstarted)) = empCO .
--> ************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-stop = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
}
:apply (csp4-2RD-stop rd-)
--> Proof of RD-stop for inv-noChangeSstarted done.
-->
show proof

--> *************************************************************************
--> *************************************************************************
-->  ctrans [RS-stop2]:
-->     < (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, CSIM, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->	  mlog(
-->       (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > 
-->     if CSIM in (wired unused) .
--> *************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, cIMs, unwired, tIMs) sIM),
              lg >) = true .
}
:def cIMscsp = :csp {
  eq cIMs = unused .
  eq cIMs = wired .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (cIMscsp tIMscsp rd-)
--> Proof of RS-stop2 for inv-noChangeSstarted done.
-->
show proof

--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, sstarted) sCO), sIM, 
               lg >) = true .
}
:apply (rd-)
--> Proof of RS-sstart1 for inv-noChangeSstarted done.
-->
show proof

--> ****************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, sstarted) sCO), sIM, 
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RS-sstart2A = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RS-sstart2B = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:apply (csp4-2RS-sstart2A csp4-2RS-sstart2B rd-)
--> Proof of RS-sstart2 for inv-noChangeSstarted done.
-->
show proof

--> ********************************************************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM
-->      )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) and
-->       allIMInTargetStates(getIMsOfTypeOfICOInStates(SIM,mandatory,IDCO,unused),unused) and
-->       allCOInStates(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,(wired swired))),(started sstarted)) .
--> ********************************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, sstarted, sstarted) sCO), sIM,
              lg >) = true .
}
--> ************************************************************************
--> Step 4-2: When the current rule is conditinal, 
-->  add an axiom representing that the condition holds to the current case.
--> ************************************************************************
:def csp4-2RD-startA = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:def csp4-2RD-startB = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
}
:def csp4-2RD-startC = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),
                   (started sstarted)) = true .
}
:apply (csp4-2RD-startA csp4-2RD-startB csp4-2RD-startC rd-)
--> Proof of RD-start for inv-noChangeSstarted done.
-->
show proof

--> ********************************************************************************
--> trans [RD-sstart]:
-->    < (cmp(IDCO,  started, sstarted, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, sstarted, sstarted, sstarted) SCO), SIM,
-->      (clog("RD-sstart:Do Stably Start", cmp(IDCO, sstarted, sstarted, sstarted),
-->       mlog(
-->      (cmp(IDCO, started, sstarted, sstarted) SCO), SIM
-->      )) ListLG) > .
--> ********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, sstarted, started) sCO), sIM, 
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-sstart for inv-noChangeSstarted done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->      (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, wired, unwired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire1 for inv-noChangeSstarted done.
-->
show proof

--> ********************************************************************************************
--> trans [RD-unwire1]:
-->    < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      SCO,
-->      (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO,
              (imp(optional, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire1 for inv-noChangeSstarted done.
-->
show proof

--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->       mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO,   wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMscsp = :csp {
  eq tIMs = unused .
  eq tIMs = wired .
  eq tIMs = swired .
  eq tIMs = unwired .
}
:apply (tIMscsp rd-)
--> Proof of RD-unwire2 for inv-noChangeSstarted done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unused]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused) SIM),
-->      (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, wired, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, unused) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,  wired, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unused for inv-noChangeSstarted done.
-->
show proof

--> **************************************************************************************
--> trans [RD-unused]:
-->    < SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused) SIM),
-->      (ilog("RD-unused:Do Unwire", imp(TIM, IDIM, IDCO, EIDCO, unused, unused, unused),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IDCO, EIDCO,  wired, unused, unused) SIM)
-->      )) ListLG) > .
--> **************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, idCO, eidCO,  wired, unused, unused) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unused for inv-noChangeSstarted done.
-->
show proof

--> *********************************************************************************************
--> trans [RS-unwire2]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired) SIM),
-->      (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, swired) SIM)
-->      )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire2 for inv-noChangeSstarted done.
-->
show proof

--> ******************************************************************************************
--> trans [RD-unwire3]:
-->    < SCO, (imp(optional, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(optional, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      (ilog("RD-unwire3:Do Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(optional, idIM, iidCO, eidCO,  unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire3 for inv-noChangeSstarted done.
-->
show proof

--> ************************************************************************************************
-->  trans [RD-unwire4]:
-->     < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,  unused, unwired, swired) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired) SIM),
-->       (ilog("RD-unwire4:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, swired),
-->	  mlog(
-->       (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->       (imp(mandatory, IDIM, IDCO, EIDCO,   unused, unwired, swired) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *****************************************************************************************
--> Step 4-1: Begin with the most general case which is matched with LHS of the current rule.
--> *****************************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, unused, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-unwire4 for inv-noChangeSstarted done.
-->
show proof

--> ******************************************************************************************
--> trans [RS-swire1]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  swired, swired) SIM),
-->      (ilog("RS-swire1:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, swired) SIM)
-->      )) ListLG) > .
--> ******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire1 for inv-noChangeSstarted done.
-->
show proof

--> ****************************************************************************************
--> trans [RS-swire2]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,  wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired) SIM),
-->      (ilog("RS-swire2:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, swired) SIM)
-->      )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,  wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-swire2 for inv-noChangeSstarted done.
-->
show proof

--> ********************************************************************************************
--> trans [RS-unwire3]:
-->    < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired) SIM),
-->      (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, swired),
-->       mlog(
-->      (cmp(EIDCO, started, stopped, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, swired) SIM)
-->      )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, started, stopped, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired, wired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RS-unwire3 for inv-noChangeSstarted done.
-->
show proof

--> ***********************************************************************************
--> trans [RD-wire]:
-->    < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM),
-->      ListLG >
--> => < (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO,   wired, swired, swired) SIM),
-->      (ilog("RD-wire:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, swired, swired),
-->       mlog(
-->      (cmp(EIDCO, sstarted, sstarted, sstarted) SCO), 
-->      (imp(TIM, IDIM, IIDCO, EIDCO, unwired, swired, swired) SIM)
-->      )) ListLG) > .
--> ***********************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, sstarted, sstarted, sstarted) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, unwired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-wire for inv-noChangeSstarted done.
-->
show proof

--> *******************************************************************************************
--> trans [RD-swire]:
-->    < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM),
-->      ListLG >
--> => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired) SIM),
-->      (ilog("RD-swire:Do Stably Wire", imp(TIM, IDIM, IIDCO, EIDCO, swired, swired, swired),
-->       mlog(
-->      SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  wired, swired, swired) SIM)
-->      )) ListLG) > .
--> *******************************************************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired, swired, swired) sIM),
              lg >) = true .
}
:apply (rd-)
--> Proof of RD-swire for inv-noChangeSstarted done.
-->
show proof
select
--> Totally 21*6 goals should be proved.
--> Totally 21*6 goals should be proved (currently 105 goals).
