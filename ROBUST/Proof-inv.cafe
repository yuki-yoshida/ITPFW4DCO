require Proof Proof.cafe

--> ***************************
--> (4) init(S) implies inv(S).
--> (5) inv(S) implies inv(SS).
--> ***************************

module ProofInv {
  protecting(ProofBase)
  pred invK : State

  pred initinv : State
  eq initinv(S:State)
     = init(S) implies invK(S) .

  pred iinv : State State .
  eq iinv(S:State,SS:State)
     = inv(S) and invK(S) implies invK(SS) .
  pred invinv : State
  eq invinv(S:State)
     = not (S =(*,1)=>+ SS:State if CC:Bool suchThat
            not ((CC implies iinv(S,SS)) == true)
     	   { S => SS !! CC ! inv(S) ! invK(S) ! invK(SS) }) .

  -- Common lemmas in this domain.
}

--> **************************************
--> Proof of inv-allFFIMHasFFECO.
-->  eq inv-allFFIMHasFFECO(< SCO,SIM,L >)
-->    = allFFIMHasFFECO(SCO,SIM) .
--> **************************************
--> Proof of inv(S) implies inv(SS)
module Proofinv-allFFIMHasFFECO {
  protecting(ProofInv)
  var S : State
  eq invK(S) = inv-allFFIMHasFFECO(S) .

  vars CO CO' : Component
  vars IM IM' : Import
  var SCO : SetOfComponent
  var SIM : SetOfImport

  -- pred robust-lemma12 : SetOfImport SetOfComponent
  -- eq robust-lemma12(SIM,SCO)
  --    = (allFFIMHasFFECO(SIM,SCO) = true)
  --  when stableIMSet(SIM) .
  eq (allFFIMHasFFECO(SIM,SCO) and stableIMSet(SIM))
    = stableIMSet(SIM) .

  -- eq robust-lemma19(SIM,CO,CO',SCO)
  --    = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
  --  when (id(CO) = id(CO')) and 
  --       not isFForced1(CO) and not isFForced1(CO') and
  --       (tdis(CO) > tdis(CO')) .
  ceq (allFFIMHasFFECO(SIM, CO SCO) and allFFIMHasFFECO(SIM, CO' SCO))
    = allFFIMHasFFECO(SIM, CO SCO) 
    if (id(CO) = id(CO')) and 
       not isFForced1(CO) and not isFForced1(CO') and
       (tdis(CO) > tdis(CO')) .

  -- eq robust-lemma20(SIM,CO,CO',SCO)
  --    = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
  --  when (id(CO) = id(CO')) and 
  --       not isFForced1(CO) and isFForced1(CO') and
  --       (fdis(CO) > fdis(CO')) .
  ceq (allFFIMHasFFECO(SIM, CO SCO) and allFFIMHasFFECO(SIM, CO' SCO))
    = allFFIMHasFFECO(SIM, CO SCO)
    if (id(CO) = id(CO')) and 
       not isFForced1(CO) and isFForced1(CO') and
       (fdis(CO) > fdis(CO')) .

  -- eq robust-lemma21(SIM,CO,SCO)
  --    = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, SCO))
  --  when getIMsOfECOInStates(SIM,id(CO),wired) = empIM .
  ceq allFFIMHasFFECO(SIM, CO SCO) = allFFIMHasFFECO(SIM, SCO)
   if getIMsOfECOInStates(SIM,id(CO),wired) = empIM .
  
}

select Proofinv-allFFIMHasFFECO

--> ***************************
--> (4) init(S) implies inv(S).
--> ***************************
--> *******************************************
--> Step 4-1: Begin with the most general case. 
--> *******************************************
:goal {
  eq initinv(< sCO, sIM, lg >) = true .
}
:apply (rd-) 
show proof

--> ***************************
--> (5) inv(S) implies inv(SS).
--> ***************************
--> ***************************************************************************
-->  trans [RS-start1]:
-->     < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->       (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started),
-->	  mlog(
-->       (cmp(IDCO, stopped, stopped, started) SCO), SIM
-->	 )) ListLG) > .
--> ***************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
:apply (rd-)
show proof

--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
--> 	  mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
--> 	 )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM,
              lg >) = true .
}
:apply(rd-)
show proof

--> *************************************************************************
-->  trans [RS-stop2]:
-->     < (cmp(IDCO, started, started, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, started),
-->	  mlog(
-->       (cmp(IDCO, started, started, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > .
--> *************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, started) sCO),
              (imp(mandatory, idIM, idCO, iidCO, wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
:def iidCOctf = :ctf {
  eq idCO = iidCO .
}
:apply (iidCOctf rd-)
show proof

--> *******************************************************************
-->  ctrans [RD-start]:
-->     < (cmp(IDCO, stopped, started, TSCO) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, started, started, TSCO) SCO), SIM,
-->       (clog("RD-start:Do Start", cmp(IDCO, started, started, TSCO),
-->	  mlog(
-->       (cmp(IDCO, stopped, started, TSCO) SCO), SIM
-->	 )) ListLG) >
-->     if canStart(IDCO,SCO,SIM) .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, started, tCOs) sCO), sIM, lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
show proof

--> ***************************************************************************************
-->  trans [RS-wire]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,   wired, wired) SIM),
-->       (ilog("RS-wire:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM)
-->	 )) ListLG) > .
--> ***************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, wired) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************************
-->  trans [RS-unwire1]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->       (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->	 )) ListLG) > .
--> **********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,   wired, unwired) sIM), lg >) = true .
}
:apply (rd-)
show proof

--> ********************************************************************************************
--> trans [RS-unwire2]:
-->     < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, wired) SIM),
-->       (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, wired),
-->	  mlog(
-->       (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, wired) SIM)
-->	 )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(iidCO, started, nCOs, tCOs) cmp(eidCO, started, stopped, started) sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,   wired, wired) sIM),
              lg >) = true .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:def eidCOctf = :ctf {
  eq eidCO = iidCO .
}
:apply (tIM eidCOctf rd-)
show proof

--> *********************************************************************************************
-->  trans [RS-unwire3]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused) SIM),
-->       (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unused) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,   wired, unused) sIM),
              lg >) = true .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (tIM rd-)
show proof

--> *********************************************************************************************
-->  trans [RS-unwire4]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, wired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, wired) SIM),
-->       (ilog("RS-unwire4:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, wired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, wired) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, wired) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> ************************************************************************************************
-->  trans [RS-unused]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  unused, unused) SIM),
-->       (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, unused) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, unused) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
-->  trans [RD-wire1]:
-->     < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, wired) SIM),
-->       (ilog("RD-wire1:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, wired),
-->	  mlog(
-->       (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM)
-->	 )) ListLG) > .
--> **********************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(iidCO, stopped, stopped, tCOs) sCO), 
	      (imp(tIM, idIM, iidCO, eidCO, unwired, wired, wired) sIM),
              lg >) = true .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (tIM rd-)
show proof

--> *******************************************************************
-->  trans [RD-wire2]:
-->     < (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, wired) SIM),
-->       (ilog("RD-wire2:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, wired),
-->	  mlog(
-->       (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM)
-->	 )) ListLG) > .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, started, started, tCOs) sCO), 
	      (imp(tIM, idIM, iidCO, eidCO, unwired, wired, wired) sIM),
	      lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
show proof

--> *******************************************************************
-->  ctrans [RD-unwire1]:
-->     < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->       (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->	  mlog(
-->       (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->	 )) ListLG) >
-->     if not (CSCO = failed) .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, cCOs, cCOs, tCOs) sCO),
	      (imp(optional, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
	      lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
show proof

--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->  mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
--> )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
	      lg >) = true .}

:def existCOctf = :ctf {
  eq existCO(sCO,idCO) = true .
}
:apply (existCOctf rd-)
show proof

--> *********************************************************************************************
-->  trans [RD-unwire3]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, TSIM) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->       (ilog("RD-unwire3:Should UnWire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, TSIM),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, TSIM) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO,  unused, unwired, tIMs) sIM), lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
show proof

--> ****************************************************************************************
-->  trans [RD-remove]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unused, unused) SIM),
-->       (ilog("RD-remove:Do Remove", imp(TIM, IDIM, IIDCO, EIDCO, unused, unused, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused) SIM)
-->	 )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unused, unused) sIM),lg >) = true .
}
:apply (rd-)
show proof

--> ****************************************************************
-->  ctrans [RD-stop]:
-->     < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->       (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped,TSCO),
-->	  mlog(
-->       (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->	 )) ListLG) >
-->     if getIMsOfECOInStates(SIM,IDCO,wired) = empIM .
--> ****************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
:def noWiredIMctf = :ctf {
  eq getIMsOfECOInStates(sIM,idCO,wired) = empIM .
}
:apply (noWiredIMctf rd-)
show proof

--> Proof of inv-allFFIMHasFFECO done.
--> 18 goals should be proved.
select

--> **************************************
--> Proof of inv-allFFCOHasFFIIM.
-->  eq inv-allFFCOHasFFIIM(< SCO,SIM,L >)
-->    = allFFCOHasFFIIM(SCO,SIM) .
--> **************************************
--> Proof of inv(S) implies inv(SS)
module Proofinv-allFFCOHasFFIIM {
  protecting(ProofInv)
  var S : State
  eq invK(S) = inv-allFFCOHasFFIIM(S) .

  var CO : Component
  vars IM IM' : Import
  var SCO : SetOfComponent
  var SIM : SetOfImport

  -- pred robust-lemma11 : SetOfComponent SetOfImport
  -- eq robust-lemma11(SCO,SIM)
  --    = (allFFCOHasFFIIM(SCO,SIM) = true)
  --  when stableCOSet(SCO) .
  eq (allFFCOHasFFIIM(SCO,SIM) and stableCOSet(SCO))
    = stableCOSet(SCO) .

  -- pred robust-lemma13 : SetOfComponent Import Import SetOfImport
  -- eq robust-lemma13(SCO,IM,IM',SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  -- when (importer(IM) = importer(IM')) and 
  --      not isForced(IM) and not isFForced1(IM) and
  --      (tdis(IM) >= tdis(IM')) and
  --      (fdis(IM) > fdis(IM')) .
  ceq (allFFCOHasFFIIM(SCO, IM SIM) and allFFCOHasFFIIM(SCO, IM' SIM))
    = allFFCOHasFFIIM(SCO, IM SIM)
    if (importer(IM) = importer(IM')) and 
       not isForced(IM) and not isFForced1(IM) and
       (tdis(IM) >= tdis(IM')) and
       (fdis(IM) > fdis(IM')) .

  -- pred robust-lemma14 : SetOfComponent Import Import SetOfImport
  -- eq robust-lemma14(SCO,IM,IM',SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  -- when (importer(IM) = importer(IM')) and 
  --      not isForced(IM) and not isFForced1(IM) and
  --      (tdis(IM) > tdis(IM')) and
  --      (fdis(IM) >= fdis(IM')) .
  ceq (allFFCOHasFFIIM(SCO, IM SIM) and allFFCOHasFFIIM(SCO, IM' SIM))
    = allFFCOHasFFIIM(SCO, IM SIM)
    if (importer(IM) = importer(IM')) and 
       not isForced(IM) and not isFForced1(IM) and
       (tdis(IM) > tdis(IM')) and
       (fdis(IM) >= fdis(IM')) .

  -- pred robust-lemma15 : SetOfComponent Import Import SetOfImport
  -- eq robust-lemma15(SCO,IM,IM',SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  -- when (importer(IM) = importer(IM')) and 
  --      isForced(IM) and isForced(IM') and
  --      (tdis(IM) > tdis(IM')) .
  ceq (allFFCOHasFFIIM(SCO, IM SIM) and allFFCOHasFFIIM(SCO, IM' SIM))
    = allFFCOHasFFIIM(SCO, IM SIM)
    if (importer(IM) = importer(IM')) and 
       isForced(IM) and isForced(IM') and
       (tdis(IM) > tdis(IM')) .

  -- pred robust-lemma10 : SetOfComponent Import SetOfImport
  -- eq robust-lemma10(SCO,IM,SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) = allFFCOHasFFIIM(SCO, SIM)) 
  --  when (not existCO(SCO,importer(IM))) .
  ceq allFFCOHasFFIIM(SCO, IM SIM) 
    = allFFCOHasFFIIM(SCO, SIM)
    if (not existCO(SCO,importer(IM))) .

  -- pred robust-lemma17 : SetOfComponent Import Import SetOfImport
  -- eq robust-lemma17(SCO,IM,IM',SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  -- when (importer(IM) = importer(IM')) and 
  --      (state(IM)   = unwired) and
  --      (next(IM)    = wired) and
  --      (target(IM)  = wired) and
  --      (state(IM')  = wired) and
  --      (next(IM')   = wired) and
  --      (target(IM') = wired) .
  ceq (allFFCOHasFFIIM(SCO, IM SIM) and allFFCOHasFFIIM(SCO, IM' SIM))
    = allFFCOHasFFIIM(SCO, IM SIM)
    if (importer(IM) = importer(IM')) and 
       (state(IM)   = unwired) and
       (next(IM)    = wired) and
       (target(IM)  = wired) and
       (state(IM')  = wired) and
       (next(IM')   = wired) and
       (target(IM') = wired) .

  -- pred robust-lemma18 : SetOfComponent Import Import SetOfImport
  -- eq robust-lemma18(SCO,IM,IM',SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  -- when (importer(IM) = importer(IM')) and 
  --      (type(IM)    = optional) and
  --      (state(IM)   = wired) and
  --      (next(IM)    = unwired) and
  --      (target(IM)  = wired) and
  --      (state(IM')  = unwired) and
  --      (next(IM')   = unwired) and
  --      (target(IM') = wired) .
  ceq (allFFCOHasFFIIM(SCO, IM SIM) and allFFCOHasFFIIM(SCO, IM' SIM))
    = allFFCOHasFFIIM(SCO, IM SIM)
    if (importer(IM) = importer(IM')) and 
       (type(IM)    = optional) and
       (state(IM)   = wired) and
       (next(IM)    = unwired) and
       (target(IM)  = wired) and
       (state(IM')  = unwired) and
       (next(IM')   = unwired) and
       (target(IM') = wired) .
}

select Proofinv-allFFCOHasFFIIM

--> ***************************
--> (4) init(S) implies inv(S).
--> ***************************
--> *******************************************
--> Step 4-1: Begin with the most general case. 
--> *******************************************
:goal {
  eq initinv(< sCO, sIM, lg >) = true .
}
:apply (rd-) 
show proof

--> ***************************
--> (5) inv(S) implies inv(SS).
--> ***************************
--> ***************************************************************************
-->  trans [RS-start1]:
-->     < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->       (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started),
-->	  mlog(
-->       (cmp(IDCO, stopped, stopped, started) SCO), SIM
-->	 )) ListLG) > .
--> ***************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
:apply (rd-)
show proof

--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
--> 	  mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
--> 	 )) ListLG) > .
--> ************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, stopped) sCO), sIM,
              lg >) = true .
}
:apply(rd-)
show proof

--> *************************************************************************
-->  trans [RS-stop2]:
-->     < (cmp(IDCO, started, started, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, started),
-->	  mlog(
-->       (cmp(IDCO, started, started, started) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > .
--> *************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, started, started) sCO),
              (imp(mandatory, idIM, idCO, iidCO, wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
show proof

--> *******************************************************************
-->  ctrans [RD-start]:
-->     < (cmp(IDCO, stopped, started, TSCO) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, started, started, TSCO) SCO), SIM,
-->       (clog("RD-start:Do Start", cmp(IDCO, started, started, TSCO),
-->	  mlog(
-->       (cmp(IDCO, stopped, started, TSCO) SCO), SIM
-->	 )) ListLG) >
-->     if canStart(IDCO,SCO,SIM) .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, started, tCOs) sCO), sIM, lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
show proof

--> ***************************************************************************************
-->  trans [RS-wire]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,   wired, wired) SIM),
-->       (ilog("RS-wire:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM)
-->	 )) ListLG) > .
--> ***************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, wired) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************************
-->  trans [RS-unwire1]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired) SIM),
-->       (ilog("RS-unwire1:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unwired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unwired) SIM)
-->	 )) ListLG) > .
--> **********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,   wired, unwired) sIM), lg >) = true .
}
:apply (rd-)
show proof

--> ********************************************************************************************
--> trans [RS-unwire2]:
-->     < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, wired) SIM),
-->       (ilog("RS-unwire2:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, wired),
-->	  mlog(
-->       (cmp(IIDCO, started, NSCO, TSCO) cmp(EIDCO, started, stopped, started) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, wired) SIM)
-->	 )) ListLG) > .
--> ********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(iidCO, started, nCOs, tCOs) cmp(eidCO, started, stopped, tCOs') sCO), 
              (imp(tIM, idIM, iidCO, eidCO, wired,   wired, wired) sIM),
              lg >) = true .
}
:def eidCOctf = :ctf {
  eq eidCO = iidCO .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:def tCOs' = :csp {
  eq tCOs' = started .
  eq tCOs' = stopped .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (eidCOctf nCOs tCOs tCOs' tIM rd-)
show proof

--> *********************************************************************************************
-->  trans [RS-unwire3]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused) SIM),
-->       (ilog("RS-unwire3:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, wired, unwired, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, wired,   wired, unused) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, wired,   wired, unused) sIM),
              lg >) = true .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (tIM rd-)
show proof

--> *********************************************************************************************
-->  trans [RS-unwire4]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, wired) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, wired) SIM),
-->       (ilog("RS-unwire4:Should Unwire", imp(TIM, IDIM, IIDCO, EIDCO, unused, unwired, wired),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unused,  unused, wired) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unused,  unused, wired) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> ************************************************************************************************
-->  trans [RS-unused]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,  unused, unused) SIM),
-->       (ilog("RS-unused:Should be Unused", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, unused) SIM)
-->	 )) ListLG) > .
--> ************************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, unused) sIM),
	      lg >) = true .
}
:apply (rd-)
show proof

--> **********************************************************************************
-->  trans [RD-wire1]:
-->     < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, wired) SIM),
-->       (ilog("RD-wire1:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, wired),
-->	  mlog(
-->       (cmp(IIDCO, stopped, stopped, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM)
-->	 )) ListLG) > .
--> **********************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(iidCO, stopped, stopped, tCOs) sCO), 
	      (imp(tIM, idIM, iidCO, eidCO, unwired, wired, wired) sIM),
              lg >) = true .
}
:def tIM = :csp {
  eq tIM = mandatory .
  eq tIM = optional .
}
:apply (tIM rd-)
show proof

--> *******************************************************************
-->  trans [RD-wire2]:
-->     < (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM),
-->       ListLG >
-->  => < (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO,   wired, wired, wired) SIM),
-->       (ilog("RD-wire2:Do Wire", imp(TIM, IDIM, IIDCO, EIDCO, wired, wired, wired),
-->	  mlog(
-->       (cmp(EIDCO, started, started, TSCO) SCO), 
-->       (imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired) SIM)
-->	 )) ListLG) > .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(eidCO, started, started, tCOs) sCO), 
	      (imp(tIM, idIM, iidCO, eidCO, unwired, wired, wired) sIM),
	      lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
show proof

--> *******************************************************************
-->  ctrans [RD-unwire1]:
-->     < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->       ListLG >
-->  => < (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->       (ilog("RD-unwire1:Do Unwire", imp(optional, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->	  mlog(
-->       (cmp(IDCO, CSCO, CSCO, TSCO) SCO),
-->       (imp(optional, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
-->	 )) ListLG) >
-->     if not (CSCO = failed) .
--> *******************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, cCOs, cCOs, tCOs) sCO),
	      (imp(optional, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
	      lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
show proof

--> *********************************************************************************************
--> trans [RD-unwire2]:
-->    < (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM),
-->      ListLG >
--> => < (cmp(IDCO, stopped, NSCO, TSCO) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->      (ilog("RD-unwire2:Do Unwire", imp(mandatory, IDIM, IDCO, EIDCO, unwired, unwired, TSIM),
-->  mlog(
-->      (cmp(IDCO, stopped, NSCO, TSCO) SCO), 
-->      (imp(mandatory, IDIM, IDCO, EIDCO,   wired, unwired, TSIM) SIM)
--> )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, stopped, nCOs, tCOs) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
	      lg >) = true .}

:def existCOctf = :ctf {
  eq existCO(sCO,idCO) = true .
}
:apply (existCOctf rd-)
show proof

--> *********************************************************************************************
-->  trans [RD-unwire3]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, TSIM) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, TSIM) SIM),
-->       (ilog("RD-unwire3:Should UnWire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, TSIM),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, TSIM) SIM)
-->	 )) ListLG) > .
--> *********************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO,  unused, unwired, tIMs) sIM), lg >) = true .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMs rd-)
show proof

--> ****************************************************************************************
-->  trans [RD-remove]:
-->     < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused) SIM),
-->       ListLG >
-->  => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO,  unused, unused, unused) SIM),
-->       (ilog("RD-remove:Do Remove", imp(TIM, IDIM, IIDCO, EIDCO, unused, unused, unused),
-->	  mlog(
-->       SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused) SIM)
-->	 )) ListLG) > .
--> ****************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unused, unused) sIM),lg >) = true .
}
:apply (rd-)
show proof

--> *************************************************************************************
-->  ctrans [RD-stop]:
-->     < (cmp(IDCO, started, stopped, TSCO) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, stopped, stopped, TSCO) SCO), SIM,
-->       (clog("RD-stop:Do Stop", cmp(IDCO, stopped, stopped,TSCO),
-->	  mlog(
-->       (cmp(IDCO, started, stopped, TSCO) SCO), SIM
-->	 )) ListLG) >
-->     if getIMsOfECOInStates(SIM,IDCO,wired) = empIM .
--> *************************************************************************************
--> *************************************************************************
--> Step 5-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (cmp(idCO, started, stopped, tCOs) sCO), sIM, lg >) = true .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (tCOs rd-)
show proof

--> Proof of inv-allFFCOHasFFIIM done.
--> 18 goals should be proved.
select

--> Totally 36 goals should be proved.
