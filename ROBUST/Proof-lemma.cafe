require Proof Proof.cafe

--> Common lemmas in this domain.

module ROBUSTLEMMA {
  protecting(ProofBase)

  pred (_when _) : Bool Bool { prec: 63 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  -- Nat Axiom
  vars X Y Z Z1 Z2 : Nat

  eq ((X + Z) >= (Y + Z))
    =  (X >= Y) .

  -- eq ((X + Z) = (Y + Z))
  --   =  (X = Y) .

  ceq ((X + Z1) = (Y + Z2))
    =  (Z1 = Z2)
   if  (X = Y) .

  ceq ((X + Z1) >= (Y + Z2))
    =  (X >= Y) 
    if (Z1 >= Z2) .

  -- ceq ((X + Z1) >= (Y + Z2))
  --   =  (X >= Y) 
  --   if (Z1 > Z2) .

  vars CO CO' : Component
  vars SCO SCO' SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  vars CSCO' NSCO' TSCO' : COState
  var StCO : SetOfCOState

  vars IM IM' : Import
  vars SIM SIM' SIM0 : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog

  pred robust-lemma01 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemma01(SIM, IDCO, SCO', SIM')
     = (fdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') =
        fdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .

  pred robust-lemma02 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemma02(SIM, IDCO, SCO', SIM')
     = (tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') =
        tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .

  pred robust-lemma03 : SetOfComponent COID SetOfComponent SetOfImport
  eq robust-lemma03(SCO, IDCO, SCO', SIM')
     = (tdis(SCO, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') = 
        tdis(SCO, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .

  pred robust-lemma04 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemma04(SIM, IDCO, SCO', SIM')
     = (fdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
        fdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .

  pred robust-lemma05 : SetOfImport COID SetOfComponent SetOfImport
  eq robust-lemma05(SIM, IDCO, SCO', SIM')
     = (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
        tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .

  pred robust-lemma06 : SetOfComponent COID SetOfComponent SetOfImport
  eq robust-lemma06(SCO, IDCO, SCO', SIM')
     = (tdis(SCO, (cmp(IDCO,started,started,started) SCO'), SIM') >=
        tdis(SCO, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
}


--> ******************************************************************
--> Proof of robust-lemma01.
--> eq robust-lemma01(SIM, IDCO, SIM)
-->    = (fdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') =
-->       fdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .
--> ******************************************************************
module ROBUSTLEMMA01 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma01-IH :nonexec]:
     robust-lemma01(SIM:SetOfImport, idCO, sCO', sIM') = true
     if SIM <wf (im sIM) .

  var IM : Import
  var SIM : SetOfImport
  eq (getIMsOfECOInTargetStates(sIM',id(getComponent(sCO',importer(IM))),wired)
      <wf (IM SIM) ) = true .
}

select ROBUSTLEMMA01
:goal { eq robust-lemma01(sIM0, idCO, sCO', sIM') = true .}
:init as robust-lemma01-IH-in [robust-lemma01-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisFForcedctf = :ctf {
  eq isFForced(im) = true .
}
:apply (imisFForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = idCO .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma01 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma02.
--> eq robust-lemma02(SIM, IDCO, SIM)
-->    = tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') >=
-->      tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .
--> ******************************************************************
module ROBUSTLEMMA02 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma02-IH :nonexec]:
     robust-lemma02(SIM:SetOfImport, idCO, sCO', sIM') = true
     if SIM <wf (im sIM) .

  var IDCO : COID
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma01(SIM, IDCO, SCO', SIM')
  --    = (fdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') =
  --       fdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM')) .
  eq fdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') 
   = fdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM') .

}

select ROBUSTLEMMA02
:goal { eq robust-lemma02(sIM0, idCO, sCO', sIM') = true .}
:init as robust-lemma02-IH-in [robust-lemma02-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisForcedctf = :ctf {
  eq isForced(im) = true .
}
:apply (imisForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = idCO .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma02 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma03.
--> eq robust-lemma03(SCO, IDCO, SIM)
-->    = tdis(SCO, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') >=
-->      tdis(SCO, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
--> ******************************************************************
module ROBUSTLEMMA03 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma03-IH :nonexec]:
     robust-lemma03(SCO:SetOfComponent, idCO, sCO', sIM') = true
     if SCO <wf (co sCO) .

  var IDCO : COID
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma02(SIM, IDCO, SCO', SIM')
  --    = tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') >=
  --      tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
  eq tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM')
   = tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
}

select ROBUSTLEMMA03
:goal { eq robust-lemma03(sCO0, idCO, sCO', sIM') = true .}
:init as robust-lemma03-IH-in [robust-lemma03-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0 rd-)
--> Proof of robust-lemma03 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma04.
--> eq robust-lemma04(SIM, IDCO, SIM)
-->    = (fdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
-->       fdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
--> ******************************************************************
module ROBUSTLEMMA04 {
  protecting(ROBUSTLEMMA)
  -- A sort SISC of tuples of SetOfImport and SetOfComponent
  [SISC] op t : SetOfImport SetOfComponent -> SISC {constr}
  -- A well-founded binary relation in SISC
  pred _<wf_ : SISC SISC .

  -- Induction Hypothesis
  ceq [robust-lemma04-IH :nonexec]:
     robust-lemma04(SIM:SetOfImport, idCO, sCO', sIM') = true
     if t(SIM,     (cmp(idCO,started,started,started) sCO')) <wf 
        t((im sIM),(cmp(idCO,started,started,started) sCO')) .

  var IM : Import
  var SCO : SetOfComponent
  vars SIM SIM' : SetOfImport
  ceq t(SIM,SCO) <wf t(SIM',SCO) = true 
    if SIM <wf SIM' .

  eq t(getIMsOfECOInTargetStates(sIM',idCO,wired),(cmp(idCO,started,started,started) sCO')) <wf
     t((IM SIM),                                  (cmp(idCO,started,started,started) sCO')) = true .

  eq (getIMsOfECOInTargetStates(sIM',id(getComponent(sCO',importer(IM))),wired)
     <wf (IM SIM) ) = true .
}

select ROBUSTLEMMA04
:goal { eq robust-lemma04(sIM0, idCO, sCO', sIM') = true .}
:init as robust-lemma04-IH-in [robust-lemma04-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisFForcedctf = :ctf {
  eq isFForced(im) = true .
}
:apply (imisFForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = idCO .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma04 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma05.
--> eq robust-lemma05(SIM, IDCO, SIM)
-->    = (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
-->       tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
--> ******************************************************************
module ROBUSTLEMMA05 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma05-IH :nonexec]:
     robust-lemma05(SIM:SetOfImport, idCO, sCO', sIM') = true
     if SIM <wf (im sIM) .

  var IDCO : COID
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma04(SIM, IDCO, SIM)
  --    = (fdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
  --       fdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
  eq (fdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
      fdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) = true .

}

select ROBUSTLEMMA05
:goal { eq robust-lemma05(sIM0, idCO, sCO', sIM') = true .}
:init as robust-lemma05-IH-in [robust-lemma05-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisForcedctf = :ctf {
  eq isForced(im) = true .
}
:apply (imisForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = idCO .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma05 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma06.
--> eq robust-lemma06(SCO, IDCO, SIM)
-->    = (tdis(SCO, (cmp(IDCO,started,started,started) SCO'), SIM') =
-->       tdis(SCO, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
--> ******************************************************************
module ROBUSTLEMMA06 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma06-IH :nonexec]:
     robust-lemma06(SCO:SetOfComponent, idCO, sCO', sIM') = true
     if SCO <wf (co sCO) .

  var IDCO : COID
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma05(SIM, IDCO, SIM)
  --    = (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
  --       tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
  eq (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
      tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) = true .
}

select ROBUSTLEMMA06
:goal { eq robust-lemma06(sCO0, idCO, sCO', sIM') = true .}
:init as robust-lemma06-IH-in [robust-lemma06-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0 rd-)
--> Proof of robust-lemma06 done.
-->
show proof
select

eof
