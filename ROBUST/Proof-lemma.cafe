require PROOF Proof.cafe

module ProofLemma {
  extending(PROOF)

  var S : State
  vars CO CO' : Component
  var IM : Import
  vars SCO SCO' SCO0 : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog
  var LS : LocalState

  -- Cont Lemmas
  pred robust-lemmaC01 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC01(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,stopped,stopped) .

  pred robust-lemmaC02 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC02(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,stopped,sstarted) .

  pred robust-lemmaC03 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC03(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,started,sstarted) .

  pred robust-lemmaC04 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC04(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(stopped,sstarted,sstarted) .

  op ls : -> LocalState .
}

--> Proof of robust-lemmaC01
-->  eq robust-lemmaC01(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,stopped,stopped) .
open ProofLemma .
:goal { eq robust-lemmaC01(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq co in st(started,stopped,stopped) = false . 
  eq co = cmp(idCO,started,stopped,stopped) .
}
:apply (inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 2-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:csp {
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cIMscsp = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-2-2-1-1 started stopped stopped
:init as noCycleLemma-in [noCycleLemma]
  by {O:Component <- co;
      X:Component <- co;
      S:State <- < (co sCO), sIM, lg >;
      LS:LocalState <- st(started,stopped,stopped); }
:apply (rd-)
--> Proof of robust-lemmaC01 done
-->
show proof
close


--> Proof of robust-lemmaC02
-->  eq robust-lemmaC02(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,stopped,sstarted) .
open ProofLemma .
  -- eq robust-lemmaC01(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,stopped,stopped) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,stopped,stopped) and
       cont(< (CO SCO), SIM, L >) = false .
:goal { eq robust-lemmaC02(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq co in st(started,stopped,sstarted) = false . 
  eq co = cmp(idCO,started,stopped,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 2-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:csp {
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cIMscsp = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-2-1-1-1 is discharged by C01
-- Case 2-2-1-1-1-2-4: mandatory wired unwired swired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-4-1-1-3: started stopped sstarted
:init as noCycleLemma-in [noCycleLemma]
  by {O:Component <- co;
      X:Component <- co;
      S:State <- < (co sCO), sIM, lg >;
      LS:LocalState <- st(started,stopped,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC02 done
-->
show proof
close

--> Proof of robust-lemmaC03
-->  eq robust-lemmaC03(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,started,sstarted) .
open ProofLemma .
:goal { eq robust-lemmaC03(co,sCO,sIM,lg) = true . }
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq co in st(started,started,sstarted) = false . 
  eq co = cmp(idCO,started,started,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RS-stop2 or RS-sstart2 should be applied
:def cansstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (cansstartcsp rd-)
-- Case 2-3: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-3-3-4: wired wired swired
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-3-3-4-2-2-2-3: started started sstarted
:init as noCycleLemma-in [noCycleLemma]
  by {O:Component <- co;
      X:Component <- co;
      S:State <- < (co sCO), sIM, lg >;
      LS:LocalState <- st(started,started,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC03 done
-->
show proof
close

--> Proof of robust-lemmaC04
-->  eq robust-lemmaC04(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->           CO in st(stopped,sstarted,sstarted) .
open ProofLemma .
  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,stopped,sstarted) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,stopped,sstarted) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC03(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,started,sstarted) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,started,sstarted) and
       cont(< (CO SCO), SIM, L >) = false .

:goal { eq robust-lemmaC04(co,sCO,sIM,lg) = true . }
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq co in st(stopped,sstarted,sstarted) = false . 
  eq co = cmp(idCO,stopped,sstarted,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RD-start should be applied
:def canstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (canstartcsp rd-)
-- Case 2-2: unwired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-2-4-4: unwired swired swired
-- RD-wire2 should be applied
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-4-4-2-1-3-3: stopped sstarted sstarted
:init as noCycleLemma-in [noCycleLemma]
  by {O:Component <- co;
      X:Component <- co;
      S:State <- < (co sCO), sIM, lg >;
      LS:LocalState <- st(stopped,sstarted,sstarted); }
:apply (rd-)
-- Case 2-2-4-4-2-2-1-3: started stopped sstarted is discharged by C02
-- Case 2-2-4-4-2-2-2-3: started started sstarted is discharged by C03
-- Case 2-3: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-3-3-4: wired wired swired
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-3-3-4-2-1-3-3: stopped sstarted sstarted
:init as noCycleLemma-in [noCycleLemma]
  by {O:Component <- co;
      X:Component <- co;
      S:State <- < (co sCO), sIM, lg >;
      LS:LocalState <- st(stopped,sstarted,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC04 done
-->
show proof
close

--> Totally 4 goals should be proved.
