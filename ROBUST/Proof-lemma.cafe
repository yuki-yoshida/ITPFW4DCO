require PROOF Proof.cafe

module ProofLemma {
  protecting(PROOF)

  var S : State
  vars CO CO' Xc : Component
  var IM : Import
  vars SCO SCO' SCO0 : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog
  var LS : LocalState

  -- for NoCyclic Lemma
  eq [noCycleU :nonexec]:
    noCDLU(CO,Xc,LS,S) = true .
  eq [noCycleD :nonexec]:
    noCDLD(CO,Xc,LS,S) = true .

  -- Cont Lemmas
  pred robust-lemmaC01 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC01(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,stopped,stopped) .

  pred robust-lemmaC02 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC02(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,stopped,sstarted) .

  pred robust-lemmaC03 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC03(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(started,started,sstarted) .

  pred robust-lemmaC04 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC04(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           CO in st(stopped,sstarted,sstarted) .

  op ls : -> LocalState .
}

--> Proof of robust-lemmaC01
-->  eq robust-lemmaC01(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,stopped,stopped) .
open ProofLemma .
--> ***********************************************************************
--> Step 1-1: Begin with the most general representation of a global state.
--> ***********************************************************************
:goal { eq robust-lemmaC01(co,sCO,sIM,lg) = true . }
:csp {
  eq co = cmp(idCO,started,stopped,stopped) .
}
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- rule RD-stop should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
-- The corrent case is already matched with the LHS of rule RD-stop.
--> *********************************************************
--> Step 1-5: Split the current case into cases where
-->  the condition of the current rule does or does not hold. 
--> *********************************************************
-- The condition of RD-stop is getICOsOfIMsInStates(...) = empCO
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 1-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:init ( eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .) .
:def cIMscsp2 = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp2 = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp2 nIMscsp tIMscsp rd-)
-- Case 1-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp2 nCOscsp tCOscsp rd-)
-- Case 1-2-1-1-1-2-2-1-1-1 started stopped stopped
--> ******************************************************************************
--> Step 1-8: When falling in a cyclic situation, use No Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:def noCycleD = :init as noCycleD-in [noCycleD]
  by {CO:Component <- co;
      Xc:Component <- co;
      LS:LocalState <- st(started,stopped,stopped);
      S:State <- (< (co sCO), sIM, lg >);}
:apply (noCycleD rd-)
--> Proof of robust-lemmaC01 done
-->
show proof
close

--> Proof of robust-lemmaC02
-->  eq robust-lemmaC02(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,stopped,sstarted) .
open ProofLemma .
  -- This lemma requres C01:
  -- eq robust-lemmaC01(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,stopped,stopped) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,stopped,stopped) and
       cont(< (CO SCO), SIM, L >) = false .
--> ***********************************************************************
--> Step 1-1: Begin with the most general representation of a global state.
--> ***********************************************************************
:goal { eq robust-lemmaC02(co,sCO,sIM,lg) = true . }
:csp {
  eq co = cmp(idCO,started,stopped,sstarted) .
}
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- rule RD-stop should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
-- The corrent case is already matched with the LHS of rule RD-stop.
--> *********************************************************
--> Step 1-5: Split the current case into cases where
-->  the condition of the current rule does or does not hold. 
--> *********************************************************
-- The condition of RD-stop is getICOsOfIMsInStates(...) = empCO
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 1-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:init ( eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .) .
:def cIMscsp2 = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp2 = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp2 nIMscsp tIMscsp rd-)
-- Case 1-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp2 nCOscsp tCOscsp rd-)
-- Case 1-2-1-1-1-2-2-1-1-1 is discharged by C01
-- Case 1-2-1-1-1-2-4: mandatory wired unwired swired
:apply (cCOscsp2 nCOscsp tCOscsp rd-)
-- Case 1-2-1-1-1-2-4-1-1-3: started stopped sstarted
--> ******************************************************************************
--> Step 1-8: When falling in a cyclic situation, use No Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:def noCycleD = :init as noCycleD-in [noCycleD]
  by {CO:Component <- co;
      Xc:Component <- co;
      LS:LocalState <- st(started,stopped,sstarted);
      S:State <- (< (co sCO), sIM, lg >);}
:apply (noCycleD rd-)
--> Proof of robust-lemmaC02 done
-->
show proof
close

--> Proof of robust-lemmaC03
-->  eq robust-lemmaC03(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        CO in st(started,started,sstarted) .
open ProofLemma .
--> ***********************************************************************
--> Step 1-1: Begin with the most general representation of a global state.
--> ***********************************************************************
:goal { eq robust-lemmaC03(co,sCO,sIM,lg) = true . }
:csp {
  eq co = cmp(idCO,started,started,sstarted) .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- rule RS-stop2 or RS-sstart2 should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
-- The corrent case is already matched with the LHS of rule RS-sstart2.
--> *********************************************************
--> Step 1-5: Split the current case into cases where
-->  the condition of the current rule does or does not hold. 
--> *********************************************************
-- The condition of RS-sstart2 is allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
:def csp1-5-1 = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (csp1-5-1 rd-)
-- Case 1-1: allIMInStates(...)
:def csp1-5-2 = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unused, nIMs, tIMs) sIM') .
}
:apply (csp1-5-2 rd-)
-- Case 1-1-2: sIM = (imp(mandatory, idIM, idCO, eidCO, unused, nIMs, tIMs) sIM')
:def tIMs3csp = :csp {
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:apply (tIMs3csp rd-)
-- Case 1-1-2-3: swired
:apply (nIMscsp rd-)
-- Case 1-3: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 1-3-3-4: wired wired swired
--> **************************************************************************
--> Step 1-7: When there is a dangling link, split the current case into cases
-->  where the linked object does or does not exist.
--> **************************************************************************
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 1-3-3-4-2-2-2-3: started started sstarted
--> ******************************************************************************
--> Step 1-8: When falling in a cyclic situation, use No Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:def noCycleU = :init as noCycleU-in [noCycleU]
  by {CO:Component <- co;
      Xc:Component <- co;
      LS:LocalState <- st(started,started,sstarted);
      S:State <- (< (co sCO), sIM, lg >);}
:apply (noCycleU rd-)
--> Proof of robust-lemmaC03 done
-->
show proof
close

--> Proof of robust-lemmaC04
-->  eq robust-lemmaC04(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->           CO in st(stopped,sstarted,sstarted) .
open ProofLemma .
  -- This lemma requres C02 & C03:
  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,stopped,sstarted) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,stopped,sstarted) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC03(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          CO in st(started,started,sstarted) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if CO in st(started,started,sstarted) and
       cont(< (CO SCO), SIM, L >) = false .

--> ***********************************************************************
--> Step 1-1: Begin with the most general representation of a global state.
--> ***********************************************************************
:goal { eq robust-lemmaC04(co,sCO,sIM,lg) = true . }
:csp {
  eq co = cmp(idCO,stopped,sstarted,sstarted) .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- rule RD-start should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
-- The corrent case is already matched with the LHS of rule RD-start.
--> *********************************************************
--> Step 1-5: Split the current case into cases where
-->  the condition of the current rule does or does not hold. 
--> *********************************************************
-- The condition of RD-start is allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
:def csp1-5-1 = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (csp1-5-1 rd-)
-- Case 1-1: allIMInStates(...)
:def csp1-5-2 = :csp {
  eq allIMInTargetStates(getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,unused),unused) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unused, nIMs, tIMs) sIM') .
}
:apply (csp1-5-2 rd-)
-- Case 1-1-1: allIMInTargetStates(...) 
:def csp1-5-3 = :csp {
  eq allCOInStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,(wired swired))),(started sstarted)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (csp1-5-3 rd-)
-- Case 1-1-1-2: sIM = ...
:def eidCOcsp = :csp {
  eq sCO = (cmp(eidCO,stopped,nCOs,tCOs) sCO') .
}
:def cIMs2csp = :csp {
  eq cIMs = wired .
  eq cIMs = swired .
}
:apply (eidCOcsp cIMs2csp rd-)
-- Case 1-1-1-2-1-1: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 1-1-1-2-1-1-3-4: wired swired
:apply (nCOscsp tCoscsp rd-)
-- Case 1-1-1-2-1-1-3-4-3-3: sstarted sstarted
:def noCycleU = :init as noCycleU-in [noCycleU]
  by {CO:Component <- co;
      Xc:Component <- co;
      LS:LocalState <- st(stopped,sstarted,sstarted);
      S:State <- (< (co sCO), sIM, lg >);}
:apply (noCycleU rd-)
-- Case 1-1-1-2-1-2: swired
:apply (nIMscsp tIMscsp rd-)
-- Case 1-1-2: sIM = (imp(mandatory, idIM, idCO, eidCO, unused, nIMs, tIMs) sIM')
:def tIMs3csp = :csp {
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:apply (tIMs3csp rd-)
-- Case 1-1-2-3: swired
:apply (nIMscsp rd-)
-- Case 1-2: unwired
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- RD-wire should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
:apply (nIMscsp tIMscsp rd-)
-- Case 1-2-4-4: unwired swired swired
--> **************************************************************************
--> Step 1-7: When there is a dangling link, split the current case into cases
-->  where the linked object does or does not exist.
--> **************************************************************************
:apply (exECOcsp rd-)
-- Case 1-2-4-4-2: sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 1-2-4-4-2-2-1-3: started stopped sstarted is discharged by C02
-- Case 1-2-4-4-2-2-2-3: started started sstarted is discharged by C03
-- Case 1-2-4-4-2-1-3-3: stopped sstarted sstarted
--> ******************************************************************************
--> Step 1-8: When falling in a cyclic situation, use No Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:apply (noCycleU rd-)
-- Case 1-3: wired
--> *****************************************************************
--> Step 1-3: Consider which rule can be applied to the current case.
--> *****************************************************************
-- RS-swire2 or RS-unwire3 should be applied
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
:apply (nIMscsp tIMscsp rd-)
-- Case 1-3-3-4: wired wired swired
--> **************************************************************************
--> Step 1-7: When there is a dangling link, split the current case into cases
-->  where the linked object does or does not exist.
--> **************************************************************************
:apply (exECOcsp rd-)
-- Case 1-3-3-4-2: sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO')
--> *************************************************************************************
--> Step 1-4: Split the current case into cases which collectively cover the current case
-->  and one of which is matched with the LHS of the current rule.
--> *************************************************************************************
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 1-3-3-4-2-1-3-3: stopped sstarted sstarted
--> ******************************************************************************
--> Step 1-8: When falling in a cyclic situation, use No Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:apply (noCycleU rd-)
--> Proof of robust-lemmaC04 done
-->
show proof
close

--> Totally 4 goals should be proved.
