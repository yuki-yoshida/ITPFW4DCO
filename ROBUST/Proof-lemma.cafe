require Proof Proof.cafe

module ProofLemma {
  protecting(ProofBase)

  [COSCOSIM] op t : Component SetOfComponent SetOfImport -> COSCOSIM {constr} .
  pred _<wf_ : COSCOSIM COSCOSIM .

  var S : State
  vars CO CO' : Component
  var IM : Import
  vars SCO SCO' SCO0 : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog

  -- The NoCyclic Lemma
  var SLS : SetOfLS
  pred robust-lemmaNOC : Component SetOfComponent SetOfImport ListOfLog SetOfLS
  eq robust-lemmaNOC(CO,SCO,SIM,L,SLS)
    = noCOCycle(< (CO SCO), SIM, L >) and inStates(CO,SLS) 
      implies someCONoCycle((CO SCO),SIM,SLS) .

  -- Cont Lemmas
  pred robust-lemmaC01 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC01(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inStates(CO,st(started,stopped,stopped)) .

  -- pred robust-lemmaC02 : Component SetOfComponent SetOfImport ListOfLog
  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(stopped,stopped,stopped)) .

  pred robust-lemmaC03 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC03(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inStates(CO,st(stopped,sstarted,sstarted)) .

  pred robust-lemmaC04 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC04(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inStates(CO,st(started,stopped,sstarted)) .

  pred robust-lemmaC11 : SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC11(SCO,SIM,L)
    = cont(< SCO, SIM, L >) 
      when inv(< SCO, SIM, L >) and
           equivIMSet(SIM) = false .

  pred robust-lemmaC12 : SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC12(SCO,SIM,L)
    = cont(< SCO, SIM, L >) 
      when inv(< SCO, SIM, L >) and
           equivCOSet(SCO) = false .

  op sls : -> SetOfLS .
}

--> Proof of robust-lemmaC03
-->  eq robust-lemmaC03(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->           inStates(CO,st(stopped,sstarted,sstarted)) .
open ProofLemma .
eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .
:goal { eq robust-lemmaC03(co,sCO,sIM,lg) = true . }
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inStates(co,st(stopped,sstarted,sstarted)) = false . 
  eq co = cmp(idCO,stopped,sstarted,sstarted) .
}
:apply(inStcsp rd-)
-- Case 2: RD-start should be applied
:def canstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply(canstartcsp rd-)
-- Case 2-2: unwired
:apply(nIMscsp tIMscsp rd-)
-- Case 2-2-4-4: unwired swired swired
-- RD-wire2 should be applied
:apply(exECOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-4-4-2-1-3-3: stopped sstarted sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      SLS:SetOfLS <- st(stopped,sstarted,sstarted); }
:apply(rd-)
-- Case 2-2-4-4-2-2-1-3: started stopped sstarted
-- RD-stop should be applied
-- Case 2-2-4-4-2-2-2-3: started started sstarted
eof
-- Case 2-3: wired
--> Proof of robust-lemmaC03 done
-->
show proof
close

--> Proof of robust-lemmaC11
-->  eq robust-lemmaC11(SCO,SIM,L)
-->    = cont(< SCO, SIM, L >) 
-->      when inv(< (SCO, SIM, L >) and
-->           equivIMSet(SIM) = false .
open ProofLemma .
:goal { eq robust-lemmaC11(sCO,sIM,lg) = true . }
:def empIMcsp = :csp  { 
  eq sIM = empIM .
  eq sIM = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def cIMscsp = :csp  { 
  eq cIMs = unused .
  eq cIMs = unwired .
  eq cIMs = wired .
  eq cIMs = swired .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nIMs'csp = :csp  { 
  eq nIMs' = unused .
  eq nIMs' = unwired .
  eq nIMs' = wired .
  eq nIMs' = swired .
}
:def tIMs'csp = :csp  { 
  eq tIMs' = unused .
  eq tIMs' = unwired .
  eq tIMs' = wired .
  eq tIMs' = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def equivIMctf = :ctf  { 
  eq equivIMSet(sIM) = true .
}
:apply(equivIMctf rd-)
-- Case 2: equivIMSet(sIM) = false means that
--          at least one import whose state is not its target.
-- :init eq equivIMSet(sIM) = false .
:init (ceq true = false
	if equivIMSet(SIM:SetOfImport) . ) by {
  SIM:SetOfImport <- sIM;
}
:apply(empIMcsp rd-)
-- Case 2-2:
:init (ceq true = false
	if CIMS:IMState = TIMS:IMState . ) by {
  CIMS:IMState <- cIMs;
  TIMS:IMState <- tIMs;
}
:apply(tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- When (cIMs = tIMs), it is discharged by :init eq (cIMs = tIMs) = false .
-- Case 2-2-1-2-4-4: mandatory unwired swired swired
-- RD-wire2 should be applied
:apply(exECOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-2-4-4-2-1-3-3: stopped sstarted sstarted
-- Case 2-2-1-2-4-4-2-2-1-3: started stopped sstated
-- Case 2-2-1-2-4-4-2-2-2-3: started started sstarted
eof
-- Case 2-2-1-3-2-2: mandatory wired unwired unwired
-- Case 2-2-1-3-2-4: mandatory wired unwired swired
-- Case 2-2-1-3-3-4: mandatory wired wired swired
-- Case 2-2-2-2-4-4: optional unwired swired swired
-- Case 2-2-2-3-3-4: optional wired wired swired
--> Proof of robust-lemmaC11 done
-->
show proof
close

--> Proof of robust-lemmaNOC for DDSCU
--> eq robust-lemmaNOC(CO,SCO,SIM,L,SLS)
-->   = noCOCycle(< (CO SCO), SIM, L >) and inStates(CO,SLS)
-->     implies someCONoCycle((CO SCO),SIM,SLS) .
open ProofLemma .

  -- Define DDSC for robust-lemmaNOC
  eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaNOC-IH :nonexec]:
    (noCOCycle(< (CO SCO), SIM, lg >) and inStates(CO,sls) 
     implies someCONoCycle((CO' SCO'),SIM,sls)) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaNOC
  ceq ( t(CO',SCO',SIM) <wf t(CO,SCO,SIM) ) = true
     if inStates(CO, sls) and
        inStates(CO',sls) and
        subset((CO' SCO'),SCO) and
        CO' in DDSC(CO,SCO,SIM) .

  eq co =  cmp(idCO,cCOs,nCOs,tCOs) .
  eq co' = cmp(eidCO,cCOs',nCOs',tCOs') .

  eq subset(DDSC(CO,SCO,SIM),SCO) = true .

:goal { eq robust-lemmaNOC(co,sCO,sIM,lg,sls) = true . }
:def inStatesctf = :ctf {
  eq inStates(cmp(idCO,cCOs,nCOs,tCOs),sls) = true .
}
:apply(inStatesctf rd-)
:def allCONotcsp = :csp {
  eq allCONotInStates(getECOsOfIMs(sCO,getIMsOfTypeOfICO(sIM,mandatory,idCO)),
        sls) = true .
  eq sIM = (imp(mandatory,idIM,idCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}
:apply(allCONotcsp)
:apply(rd-)
:csp {
  eq sCO = (cmp(eidCO,cCOs',nCOs',tCOs') sCO') .
}
:csp {
  eq inStates(cmp(eidCO,cCOs',nCOs',tCOs'),sls) = true .
}
:ctf {
  eq noCOCycle((< (cmp(eidCO,cCOs',nCOs',tCOs') (cmp(idCO,cCOs,nCOs,tCOs) sCO')), 
                  (imp(mandatory,idIM,idCO,eidCO,cIMs,nIMs,tIMs) sIM') , lg >)) = true . 
}
:init as robust-lemmaNOC-IH-in [robust-lemmaNOC-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(eidCO,cCOs',nCOs',tCOs');
      SCO':SetOfComponent <- sCO'; }
:apply(rd-)
:apply(rd-)
--> Proof of robust-lemmaNOC done
-->
show proof
close

--> Proof of robust-lemmaNOC for DDSCD
--> eq robust-lemmaNOC(CO,SCO,SIM,L,SLS)
-->   = noCOCycle(< (CO SCO), SIM, L >) and inStates(CO,SLS)
-->     implies someCONoCycle((CO SCO),SIM,SLS) .
open ProofLemma .

  -- Define DDSC for robust-lemmaNOC
  eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaNOC-IH :nonexec]:
    (noCOCycle(< (CO SCO), SIM, lg >) and inStates(CO,sls) 
     implies someCONoCycle((CO' SCO'),SIM,sls)) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaNOC
  ceq ( t(CO',SCO',SIM) <wf t(CO,SCO,SIM) ) = true
     if inStates(CO, sls) and
        inStates(CO',sls) and
        subset((CO' SCO'),SCO) and
        CO' in DDSC(CO,SCO,SIM) .

  eq co =  cmp(idCO,cCOs,nCOs,tCOs) .
  eq co' = cmp(eidCO,cCOs',nCOs',tCOs') .

  eq subset(DDSC(CO,SCO,SIM),SCO) = true .

:goal { eq robust-lemmaNOC(co,sCO,sIM,lg,sls) = true . }
:def inStatesctf = :ctf {
  eq inStates(cmp(idCO,cCOs,nCOs,tCOs),sls) = true .
}
:apply(inStatesctf rd-)
:def allCONotcsp = :csp {
  eq allCONotInStates(getICOsOfIMs(sCO,getIMsOfTypeOfECO(sIM,mandatory,idCO)),
        sls) = true .
  eq sIM = (imp(mandatory,idIM,iidCO,idCO,cIMs,nIMs,tIMs) sIM') .
}
:apply(allCONotcsp)
:apply(rd-)
:csp {
  eq sCO = (cmp(iidCO,cCOs',nCOs',tCOs') sCO') .
}
:csp {
  eq inStates(cmp(iidCO,cCOs',nCOs',tCOs'),sls) = true .
}
:ctf {
  eq noCOCycle((< (cmp(iidCO,cCOs',nCOs',tCOs') (cmp(idCO,cCOs,nCOs,tCOs) sCO')), 
                  (imp(mandatory,idIM,iidCO,idCO,cIMs,nIMs,tIMs) sIM') , lg >)) = true . 
}
:init as robust-lemmaNOC-IH-in [robust-lemmaNOC-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(iidCO,cCOs',nCOs',tCOs');
      SCO':SetOfComponent <- sCO'; }
:apply(rd-)
:apply(rd-)
--> Proof of robust-lemmaNOC done
-->
show proof
close

--> Proof of robust-lemmaC01
-->  eq robust-lemmaC01(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        inStates(CO,st(started,stopped,stopped)) .
open ProofLemma .
eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .
:goal { eq robust-lemmaC01(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inStates(co,st(started,stopped,stopped)) = false . 
  eq co = cmp(idCO,started,stopped,stopped) .
}
:apply(inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getIMsOfECOInStates(sIM,idCO,(wired swired)) = empIM .
  eq sIM = (imp(tIM, idIM, iidCO, idCO,  wired, nIMs, tIMs) sIM') .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, swired, nIMs, tIMs) sIM') .
}
:apply(canstopcsp rd-)
-- Case 2-2: wired
:apply(tIMcsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-2-2: mandatory wired unwired unwired
-- RD-unwire2 should be applied
:apply(exICOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-2-2-2-2-1-1: started stopped stopped
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      SLS:SetOfLS <- st(started,stopped,stopped); }
:apply(rd-)
-- Case 2-3: swired
:apply(tIMcsp nIMscsp tIMscsp rd-)
--> Proof of robust-lemmaC01 done
-->
show proof
close

--> Proof of robust-lemmaC04
-->  eq robust-lemmaC04(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        inStates(CO,st(started,stopped,sstarted)) .
open ProofLemma .
eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .
-- eq robust-lemmaC01(CO,SCO,SIM,L)
--   = cont(< (CO SCO), SIM, L >) 
--     when inv(< (CO SCO), SIM, L >) and
--          inStates(CO,st(started,stopped,stopped)) .
ceq inv(< (CO SCO), SIM, L >) = false 
  if inStates(CO,st(started,stopped,stopped)) and
     cont(< (CO SCO), SIM, L >) = false .
:goal { eq robust-lemmaC04(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inStates(co,st(started,stopped,sstarted)) = false . 
  eq co = cmp(idCO,started,stopped,sstarted) .
}
:apply(inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO,  cIMs, nIMs, tIMs) sIM') .
}
:apply(canstopcsp rd-)
:csp {
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cIMscsp = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply(tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired unwired
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired swired
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-4-1-1-3: started stopped sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      SLS:SetOfLS <- st(started,stopped,sstarted); }
:apply(rd-)
--> Proof of robust-lemmaC04 done
-->
show proof
close

--> Totally 4 goals should be proved.
eof

Memo: Dependency of Lemmas
robust-lemmaC11 = cont when inv and equivIMSet = false .
2-2-1-2-4-4: mandatory unwired swired swired
 2-2-1-2-4-4-2-1-3-3: stopped sstarted sstarted  -> C03
 2-2-1-2-4-4-2-2-1-3: started stopped sstated    -> C04
 2-2-1-2-4-4-2-2-2-3: started started sstarted
2-2-1-3-2-2: mandatory wired unwired unwired
2-2-1-3-2-4: mandatory wired unwired swired
2-2-1-3-3-4: mandatory wired wired swired
2-2-2-2-4-4: optional unwired swired swired
2-2-2-3-3-4: optional wired wired swired

robust-lemmaC01 = cont when inv and inStates(CO,st(started,stopped,stopped)) .
DDSCD
2-2-1-2-2-2-2-1-1: started stopped stopped  -> NOC

robust-lemmaC03 = cont when inv and inStates(CO,st(stopped,sstarted,sstarted)) .
DDCSU
2-2: mandatory unwired * *
 2-2-4-4-2-1-3-3: stopped sstarted sstarted -> NOC
 2-2-4-4-2-2-1-3: started stopped sstarted  -> C04
 2-2-4-4-2-2-2-3: started started sstarted
2-3: mandatory wired * *

robust-lemmaC04 = cont when inv and inStates(CO,st(started,stopped,sstarted)) .
DDCSD
2-2-1-1-1-2-4: mandatory wired unwired swired
 2-2-1-1-1-2-4-1-1-3: started stopped sstarted -> NOC


