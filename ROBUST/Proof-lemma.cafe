require Proof Proof.cafe

--> Common lemmas in this domain.

module ROBUSTLEMMA {
  protecting(ProofBase)

  pred (_when _) : Bool Bool { prec: 63 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  -- Nat Axiom
  vars X Y Z Z1 Z2 : Nat

  ceq (X >= Y) = true
    if (X > Y) .

  eq ((X + Z) >= (Y + Z))
    =  (X >= Y) .

  ceq ((X + Z1) = (Y + Z2))
    =  (Z1 = Z2)
   if  (X = Y) .

  ceq ((X + Z1) >= (Y + Z2))
    =  (X >= Y) 
    if (Z1 >= Z2) .

  vars CO CO' : Component
  vars SCO SCO' SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  vars CSCO' NSCO' TSCO' : COState
  var StCO : SetOfCOState

  vars IM IM' : Import
  vars SIM SIM' SIM0 : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog

  pred robust-lemma01 : SetOfImport Component Component SetOfComponent SetOfImport
  -- fdis(SIM) is the same when a non-isFForced Component is changed
  -- because fdis of non-isFForced Components are zero.
  eq robust-lemma01(SIM, CO, CO', SCO', SIM')
     = (fdis(SIM, (CO SCO'), SIM') = fdis(SIM, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .

  pred robust-lemma02 : SetOfImport Component Component SetOfComponent SetOfImport
  -- tdis(SIM) is the same when a non-isFForced Component is changed
  -- because fdis of non-isFForced Components are zero.
  eq robust-lemma02(SIM, CO, CO', SCO', SIM')
     = (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .

  pred robust-lemma03 : SetOfComponent Component Component SetOfComponent SetOfImport
  -- tdis(SCO) is the same when a non-isFForced Component is changed
  -- because tdis and fdis of non-isFForced Components are zero.
  eq robust-lemma03(SCO, CO, CO', SCO', SIM')
     = (tdis(SCO, (CO SCO'), SIM') = tdis(SCO, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .

  pred robust-lemma04 : SetOfImport Component Component SetOfComponent SetOfImport
  -- fdis(SIM) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  eq robust-lemma04(SIM, CO, CO', SCO', SIM')
     = (fdis(SIM, (CO SCO'), SIM') >= fdis(SIM, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  pred robust-lemma05 : SetOfImport Component Component SetOfComponent SetOfImport
  -- tdis(SIM) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  eq robust-lemma05(SIM, CO, CO', SCO', SIM')
     = (tdis(SIM, (CO SCO'), SIM') >= tdis(SIM, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  pred robust-lemma06 : SetOfComponent Component Component SetOfComponent SetOfImport
  -- tdis(SCO) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  eq robust-lemma06(SCO, CO, CO', SCO', SIM')
     = (tdis(SCO, (CO SCO'), SIM') >= tdis(SCO, (CO' SCO'), SIM'))
   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  pred robust-lemma11 : SetOfComponent SetOfImport
  eq robust-lemma11(SCO,SIM)
     = (allFFCOHasFFIIM(SCO,SIM) = true)
   when stableCOSet(SCO) .

  pred robust-lemma12 : SetOfImport SetOfComponent
  eq robust-lemma12(SIM,SCO)
     = (allFFIMHasFFECO(SIM,SCO) = true)
   when stableIMSet(SIM) .

  pred robust-lemma13 : SetOfComponent Import Import SetOfImport
  eq robust-lemma13(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
  when (importer(IM) = importer(IM')) and 
       not isForced(IM) and not isFForced1(IM) and
       not isForced(IM') and not isFForced1(IM') .
}

--> **************************************************************************
--> Proof of robust-lemma01.
-->  ceq robust-lemma01(SIM, CO, CO', SCO', SIM')
-->     = (fdis(SIM, (CO  SCO'), SIM') = fdis(SIM, (CO' SCO'), SIM'))
-->   if (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
--> **************************************************************************
module ROBUSTLEMMA01 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma01-IH :nonexec]:
     robust-lemma01(SIM:SetOfImport, co, co', sCO', sIM') = true
     if SIM <wf (im sIM) .

  var IM : Import
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  eq (getIMsOfECOInTargetStates(SIM',id(getComponent(SCO',importer(IM))),wired)
      <wf (IM SIM) ) = true .
}

select ROBUSTLEMMA01
:goal { eq robust-lemma01(sIM0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma01-IH-in [robust-lemma01-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisFForcedctf = :ctf {
  eq isFForced(im) = true .
}
:apply (imisFForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = id(co) .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma01 done.
-->
show proof
select

--> ****************************************************************************
--> Proof of robust-lemma02.
-->  eq robust-lemma02(SIM, CO, CO', SCO', SIM')
-->     = (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM'))
-->   when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
--> ****************************************************************************
module ROBUSTLEMMA02 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma02-IH :nonexec]:
     robust-lemma02(SIM:SetOfImport, co, co', sCO', sIM') = true
     if SIM <wf (im sIM) .

  vars CO CO' : Component
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- pred robust-lemma01 : SetOfImport Component Component SetOfComponent SetOfImport
  -- eq robust-lemma01(SIM, CO, CO', SCO', SIM')
  --   = (fdis(SIM, (CO SCO'), SIM') = fdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
  ceq (fdis(SIM, (CO SCO'), SIM') = fdis(SIM, (CO' SCO'), SIM')) = true
    if (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
}

select ROBUSTLEMMA02
:goal { eq robust-lemma02(sIM0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma02-IH-in [robust-lemma02-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisForcedctf = :ctf {
  eq isForced(im) = true .
}
:apply (imisForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = id(co) .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma02 done.
-->
show proof
select

--> ****************************************************************************
--> Proof of robust-lemma03.
-->  eq robust-lemma03(SCO, CO, CO', SCO', SIM')
-->     = (tdis(SCO, (CO SCO'), SIM') = tdis(SCO, (CO' SCO'), SIM'))
-->   when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
--> ****************************************************************************
module ROBUSTLEMMA03 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma03-IH :nonexec]:
     robust-lemma03(SCO:SetOfComponent, co, co', sCO', sIM') = true
     if SCO <wf (co0 sCO) .

  vars CO CO' : Component
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- pred robust-lemma02 : SetOfImport Component Component SetOfComponent SetOfImport
  -- eq robust-lemma02(SIM, CO, CO', SCO', SIM')
  --   = (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
  ceq (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM')) = true
    if (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
}

select ROBUSTLEMMA03
:goal { eq robust-lemma03(sCO0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma03-IH-in [robust-lemma03-IH]
      by {SCO:SetOfComponent <- SCo:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co0 sCO) .
}
:apply (sCO0 rd-)
--> Proof of robust-lemma03 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma04.
-->  eq robust-lemma04(SIM, CO, CO', SCO', SIM')
-->     = (fdis(SIM, (CO SCO'), SIM') >= fdis(SIM, (CO' SCO'), SIM'))
-->   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
-->        and isFForced(CO) and isFForced(CO') .
--> ******************************************************************
module ROBUSTLEMMA04 {
  protecting(ROBUSTLEMMA)
  -- A sort SISC of tuples of SetOfImport and SetOfComponent
  [SISC] op t : SetOfImport SetOfComponent -> SISC {constr}
  -- A well-founded binary relation in SISC
  pred _<wf_ : SISC SISC .

  -- Induction Hypothesis
  ceq [robust-lemma04-IH :nonexec]:
     robust-lemma04(SIM:SetOfImport, co, co', sCO', sIM') = true
     if t(SIM,     (co  sCO')) <wf t((im sIM),(co sCO')) .

  var IM : Import
  var SCO : SetOfComponent
  vars SIM SIM' : SetOfImport
  ceq t(SIM,SCO) <wf t(SIM',SCO) = true 
    if SIM <wf SIM' .

  ceq t(getIMsOfECOInTargetStates(sIM',id(co),wired),(co sCO')) <wf
      t((IM SIM),                                  (co sCO')) = true 
   if id(co) = importer(IM) .

  eq (getIMsOfECOInTargetStates(sIM',id(getComponent(sCO',importer(IM))),wired)
     <wf (IM SIM) ) = true .
}

select ROBUSTLEMMA04
:goal { eq robust-lemma04(sIM0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def fdiscoctf = :ctf {
  eq (fdis(co) > fdis(co')) = true .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf fdiscoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma04-IH-in [robust-lemma04-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisFForcedctf = :ctf {
  eq isFForced(im) = true .
}
:apply (imisFForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = id(co) .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma04 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma05.
-->  eq robust-lemma05(SIM, CO, CO', SCO', SIM')
-->     = (tdis(SIM, (CO SCO'), SIM') >= tdis(SIM, (CO' SCO'), SIM'))
-->   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
-->        and isFForced(CO) and isFForced(CO') .
--> ******************************************************************
module ROBUSTLEMMA05 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma05-IH :nonexec]:
     robust-lemma05(SIM:SetOfImport, co, co', sCO', sIM') = true
     if SIM <wf (im sIM) .

  vars CO CO' : Component
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma04(SIM, CO, CO', SCO', SIM')
  --    = (fdis(SIM, (CO SCO'), SIM') >= fdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
  --       and isFForced(CO) and isFForced(CO') .
  ceq (fdis(SIM, (CO  SCO'), SIM') >=
       fdis(SIM, (CO' SCO'), SIM')) = true
   if (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
       and isFForced(CO) and isFForced(CO') .
}

select ROBUSTLEMMA05
:goal { eq robust-lemma05(sIM0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def fdiscoctf = :ctf {
  eq (fdis(co) > fdis(co')) = true .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf fdiscoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma05-IH-in [robust-lemma05-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def imisForcedctf = :ctf {
  eq isForced(im) = true .
}
:apply (imisForcedctf rd-)
:def idcoisImporterctf = :ctf {
  eq importer(im) = id(co) .
}
:apply(idcoisImporterctf rd-)
:def importerisFForcedctf = :ctf {
  eq isFForced(getComponent(sCO',importer(im))) = true .
}
:apply(importerisFForcedctf rd-)
--> Proof of robust-lemma05 done.
-->
show proof
select

--> ******************************************************************
--> Proof of robust-lemma06.
-->  eq robust-lemma06(SCO, CO, CO', SCO', SIM')
-->     = (tdis(SCO, (CO SCO'), SIM') >= tdis(SCO, (CO' SCO'), SIM'))
-->   when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
-->        and isFForced(CO) and isFForced(CO') .
--> ******************************************************************
module ROBUSTLEMMA06 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma06-IH :nonexec]:
     robust-lemma06(SCO:SetOfComponent, co, co', sCO', sIM') = true
     if SCO <wf (co sCO) .

  vars CO CO' : Component
  var SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  -- eq robust-lemma05(SIM, CO, CO', SCO', SIM')
  --    = (tdis(SIM, (CO SCO'), SIM') >= tdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
  --       and isFForced(CO) and isFForced(CO') .
  ceq (tdis(SIM, (CO  SCO'), SIM') >=
       tdis(SIM, (CO' SCO'), SIM')) = true
   if (id(CO) = id(CO')) and fdis(CO) > fdis(CO')
       and isFForced(CO) and isFForced(CO') .
}

select ROBUSTLEMMA06
:goal { eq robust-lemma06(sCO0, co, co', sCO', sIM') = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def fdiscoctf = :ctf {
  eq (fdis(co) > fdis(co')) = true .
}
:def isFFcoctf = :ctf {
  eq isFForced(co) = true .
}
:def isFFco'ctf = :ctf {
  eq isFForced(co') = true .
}
:apply(idcoctf fdiscoctf isFFcoctf isFFco'ctf rd-)
:init as robust-lemma06-IH-in [robust-lemma06-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0 rd-)
--> Proof of robust-lemma06 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma11.
-->  ceq robust-lemma11(SCO,SIM)
-->     = (allFFCOHasFFIIM(SCO,SIM) = true)
-->   if stableCOSet(SCO) .
--> **************************************************************************
module ROBUSTLEMMA11 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma11-IH :nonexec]:
     robust-lemma11(SCO:SetOfComponent, sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA11
:goal { eq robust-lemma11(sCO0, sIM) = true .}
:init as robust-lemma11-IH-in [robust-lemma11-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (sCO0 cCOs nCOs tCOs rd-)
--> Proof of robust-lemma11 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma12.
-->  ceq robust-lemma12(SIM,SCO)
-->     = (allFFIMHasFFECO(SIM,SCO) = true)
-->   if stableIMSet(SIM) .
--> **************************************************************************
module ROBUSTLEMMA12 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma12-IH :nonexec]:
     robust-lemma12(SIM:SetOfImport, sCO) = true
     if SIM <wf (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}

select ROBUSTLEMMA12
:goal { eq robust-lemma12(sIM0, sCO) = true .}
:init as robust-lemma12-IH-in [robust-lemma12-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}
:def cIMs = :csp {
  eq cIMs = wired .
  eq cIMs = unwired .
  eq cIMs = unused .
}
:def nIMs = :csp {
  eq nIMs = wired .
  eq nIMs = unwired .
  eq nIMs = unused .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (sIM0 cIMs nIMs tIMs rd-)
--> Proof of robust-lemma12 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma13.
-->  ceq robust-lemma13(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->   if (importer(IM) = importer(IM') and 
-->       not isForced(IM) and not isFForced1(IM) and
-->       not isForced(IM') and not isFForced1(IM') .
--> **************************************************************************
module ROBUSTLEMMA13 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma13-IH :nonexec]:
     robust-lemma13(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA13
:goal { eq robust-lemma13(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:def isFimctf = :ctf {
  eq isForced(im) = true .
}
:def isFF1imctf = :ctf {
  eq isFForced1(im) = true .
}
:def isFim'ctf = :ctf {
  eq isForced(im') = true .
}
:def isFF1im'ctf = :ctf {
  eq isFForced1(im') = true .
}
:apply(importerimctf isFimctf isFF1imctf isFim'ctf isFF1im'ctf rd-)
:init as robust-lemma13-IH-in [robust-lemma13-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
:apply (sCO0 rd-)
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (cCOs nCOs tCOs rd-)
:def idCOctf = :ctf {
  eq idCO = importer(im) .
}
-- Note that existFFctf differs for each case of idCOctf.
:apply (idCOctf)
:def existFF1ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:apply (existFF1ctf rd-)
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,idCO)) = true .
}
:apply (existFF2ctf rd-)
--> Proof of robust-lemma13 done.
-->
show proof
select

--> Totally 9 goals should be proved.
