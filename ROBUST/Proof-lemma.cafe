require PROOF Proof.cafe

module ProofLemma {
  protecting(PROOF)

  [COSCOSIM] op t : Component SetOfComponent SetOfImport -> COSCOSIM {constr} .
  pred _<wf_ : COSCOSIM COSCOSIM .

  var S : State
  vars CO CO' : Component
  var IM : Import
  vars SCO SCO' SCO0 : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog
  var LS : LocalState

  -- The NoCyclic Lemma
  pred robust-lemmaNOC : Component SetOfComponent SetOfImport ListOfLog LocalState
  eq robust-lemmaNOC(CO,SCO,SIM,L,LS)
    = noCOCycle(< (CO SCO), SIM, L >) and inState(CO,LS) 
      implies someCONoCycle((CO SCO),SIM,LS) .

  op ls : -> LocalState .
}

module ProofContLemma {
  protecting(ProofLemma)

  var S : State
  vars CO CO' : Component
  var IM : Import
  vars SCO SCO' SCO0 : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog
  var LS : LocalState

  -- The NoCyclic Lemma
  -- eq robust-lemmaNOC(CO,SCO,SIM,L,LS)
  --   = noCOCycle(< (CO SCO), SIM, L >) and inState(CO,LS) 
  --     implies someCONoCycle((CO SCO),SIM,LS) .
  -- This lemma can be used with specifying DDSCU or DDSCD as DDSC.
  
  -- someCONoCycle((CO SCO),SIM,LS) means that
  --  there exists a CO' in (CO SCO) such that isCONoCycle(CO',(CO SCO),SIM,LS) .
  -- When we can select an arbitrary CO and therefor select the CO',
  -- we can assume as follows:
  ceq [robust-lemmaNOC :nonexec]:
    noCOCycle(< (CO SCO), SIM, L >) = false
    if inState(CO,LS) and
       isCONoCycle(CO,(CO SCO),SIM,LS) = false .

  -- Cont Lemmas
  pred robust-lemmaC01 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC01(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inState(CO,st(started,stopped,stopped)) .

  pred robust-lemmaC02 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC02(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inState(CO,st(started,stopped,sstarted)) .

  pred robust-lemmaC03 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC03(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inState(CO,st(started,started,sstarted)) .

  pred robust-lemmaC04 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC04(CO,SCO,SIM,L)
    = cont(< (CO SCO), SIM, L >) 
      when inv(< (CO SCO), SIM, L >) and
           inState(CO,st(stopped,sstarted,sstarted)) .

}

--> Proof of robust-lemmaNOC for DDSCU
--> eq robust-lemmaNOC(CO,SCO,SIM,L,LS)
-->   = noCOCycle(< (CO SCO), SIM, L >) and inState(CO,LS)
-->     implies someCONoCycle((CO SCO),SIM,LS) .
open ProofLemma .

  -- Define DDSC for robust-lemmaNOC
  eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaNOC-IH :nonexec]:
    (noCOCycle(< (CO SCO), SIM, lg >) and inState(CO,ls) 
     implies someCONoCycle((CO' SCO'),SIM,ls)) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaNOC
  ceq ( t(CO',SCO',SIM) <wf t(CO,SCO,SIM) ) = true
     if inState(CO, ls) and
        inState(CO',ls) and
        subset((CO' SCO'),SCO) and
        CO' in DDSC(CO,SCO,SIM) .

  eq co =  cmp(idCO,cCOs,nCOs,tCOs) .
  eq co' = cmp(eidCO,cCOs',nCOs',tCOs') .

  eq subset(DDSC(CO,SCO,SIM),SCO) = true .

:goal { eq robust-lemmaNOC(co,sCO,sIM,lg,ls) = true . }
:def inStatectf = :ctf {
  eq inState(cmp(idCO,cCOs,nCOs,tCOs),ls) = true .
}
:apply (inStatectf rd-)
:def allCONotcsp = :csp {
  eq allCONotInState(getECOsOfIMs(sCO,getIMsOfTypeOfICO(sIM,mandatory,idCO)),
        ls) = true .
  eq sIM = (imp(mandatory,idIM,idCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}
:apply (allCONotcsp)
:apply (rd-)
:csp {
  eq sCO = (cmp(eidCO,cCOs',nCOs',tCOs') sCO') .
}
:csp {
  eq inState(cmp(eidCO,cCOs',nCOs',tCOs'),ls) = true .
}
:ctf {
  eq noCOCycle((< (cmp(eidCO,cCOs',nCOs',tCOs') (cmp(idCO,cCOs,nCOs,tCOs) sCO')), 
                  (imp(mandatory,idIM,idCO,eidCO,cIMs,nIMs,tIMs) sIM') , lg >)) = true . 
}
:init as robust-lemmaNOC-IH-in [robust-lemmaNOC-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(eidCO,cCOs',nCOs',tCOs');
      SCO':SetOfComponent <- sCO'; }
:apply (rd-)
:apply (rd-)
--> Proof of robust-lemmaNOC done
-->
show proof
close

--> Proof of robust-lemmaNOC for DDSCD
--> eq robust-lemmaNOC(CO,SCO,SIM,L,LS)
-->   = noCOCycle(< (CO SCO), SIM, L >) and inState(CO,LS)
-->     implies someCONoCycle((CO SCO),SIM,LS) .
open ProofLemma .

  -- Define DDSC for robust-lemmaNOC
  eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaNOC-IH :nonexec]:
    (noCOCycle(< (CO SCO), SIM, lg >) and inState(CO,ls) 
     implies someCONoCycle((CO' SCO'),SIM,ls)) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaNOC
  ceq ( t(CO',SCO',SIM) <wf t(CO,SCO,SIM) ) = true
     if inState(CO, ls) and
        inState(CO',ls) and
        subset((CO' SCO'),SCO) and
        CO' in DDSC(CO,SCO,SIM) .

  eq co =  cmp(idCO,cCOs,nCOs,tCOs) .
  eq co' = cmp(eidCO,cCOs',nCOs',tCOs') .

  eq subset(DDSC(CO,SCO,SIM),SCO) = true .

:goal { eq robust-lemmaNOC(co,sCO,sIM,lg,ls) = true . }
:def inStatectf = :ctf {
  eq inState(cmp(idCO,cCOs,nCOs,tCOs),ls) = true .
}
:apply (inStatectf rd-)
:def allCONotcsp = :csp {
  eq allCONotInState(getICOsOfIMs(sCO,getIMsOfTypeOfECO(sIM,mandatory,idCO)),
        ls) = true .
  eq sIM = (imp(mandatory,idIM,iidCO,idCO,cIMs,nIMs,tIMs) sIM') .
}
:apply (allCONotcsp)
:apply (rd-)
:csp {
  eq sCO = (cmp(iidCO,cCOs',nCOs',tCOs') sCO') .
}
:csp {
  eq inState(cmp(iidCO,cCOs',nCOs',tCOs'),ls) = true .
}
:ctf {
  eq noCOCycle((< (cmp(iidCO,cCOs',nCOs',tCOs') (cmp(idCO,cCOs,nCOs,tCOs) sCO')), 
                  (imp(mandatory,idIM,iidCO,idCO,cIMs,nIMs,tIMs) sIM') , lg >)) = true . 
}
:init as robust-lemmaNOC-IH-in [robust-lemmaNOC-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(iidCO,cCOs',nCOs',tCOs');
      SCO':SetOfComponent <- sCO'; }
:apply (rd-)
:apply (rd-)
--> Proof of robust-lemmaNOC done
-->
show proof
close

--> Proof of robust-lemmaC01
-->  eq robust-lemmaC01(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        inState(CO,st(started,stopped,stopped)) .
open ProofContLemma .
eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .
:goal { eq robust-lemmaC01(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inState(co,st(started,stopped,stopped)) = false . 
  eq co = cmp(idCO,started,stopped,stopped) .
}
:apply (inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 2-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:csp {
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cIMscsp = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-2-2-1-1 started stopped stopped
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      LS:LocalState <- st(started,stopped,stopped); }
:apply (rd-)
--> Proof of robust-lemmaC01 done
-->
show proof
close


--> Proof of robust-lemmaC02
-->  eq robust-lemmaC02(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        inState(CO,st(started,stopped,sstarted)) .
open ProofContLemma .
eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .
  -- eq robust-lemmaC01(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inState(CO,st(started,stopped,stopped)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inState(CO,st(started,stopped,stopped)) and
       cont(< (CO SCO), SIM, L >) = false .
:goal { eq robust-lemmaC02(co,sCO,sIM,lg) = true . }
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inState(co,st(started,stopped,sstarted)) = false . 
  eq co = cmp(idCO,started,stopped,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RD-stop should be applied
:def canstopcsp = :csp {
  eq getICOsOfIMsInStates(sCO,
                          getIMsOfECOInStates(sIM,idCO,(wired swired)),
                         (started sstarted)) = empCO .
  eq sIM = (imp(tIM, idIM, iidCO, idCO, cIMs, nIMs, tIMs) sIM') .
}
:apply (canstopcsp rd-)
-- Case 2-2: RD-stop can not be applied
-- which means that
--   idIM is currently wired or swired and
--   idIM has an importer component that is currently started or sstarted
:csp {
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cIMscsp = :csp  { 
  eq cIMs = wired .
  eq cIMs = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = started .
  eq cCOs = sstarted .
}
:apply (tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- Case 2-2-1-1-1-2-2: mandatory wired unwired unwired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-2-1-1-1 is discharged by C01
-- Case 2-2-1-1-1-2-4: mandatory wired unwired swired
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-1-1-2-4-1-1-3: started stopped sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      LS:LocalState <- st(started,stopped,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC02 done
-->
show proof
close

--> Proof of robust-lemmaC03
-->  eq robust-lemmaC03(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->        inState(CO,st(started,started,sstarted)) .
open ProofContLemma .
eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .
:goal { eq robust-lemmaC03(co,sCO,sIM,lg) = true . }
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inState(co,st(started,started,sstarted)) = false . 
  eq co = cmp(idCO,started,started,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RS-stop2 or RS-sstart2 should be applied
:def cansstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (cansstartcsp rd-)
-- Case 2-3: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-3-3-4: wired wired swired
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-3-3-4-2-2-2-3: started started sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      LS:LocalState <- st(started,started,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC03 done
-->
show proof
close

--> Proof of robust-lemmaC04
-->  eq robust-lemmaC04(CO,SCO,SIM,L)
-->    = cont(< (CO SCO), SIM, L >) 
-->      when inv(< (CO SCO), SIM, L >) and
-->           inState(CO,st(stopped,sstarted,sstarted)) .
open ProofContLemma .
eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .
  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inState(CO,st(started,stopped,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inState(CO,st(started,stopped,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

  -- eq robust-lemmaC03(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inState(CO,st(started,started,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inState(CO,st(started,started,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

:goal { eq robust-lemmaC04(co,sCO,sIM,lg) = true . }
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def inStcsp = :csp {
  eq inState(co,st(stopped,sstarted,sstarted)) = false . 
  eq co = cmp(idCO,stopped,sstarted,sstarted) .
}
:apply (inStcsp rd-)
-- Case 2: RD-start should be applied
:def canstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO, unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, eidCO,   wired, nIMs, tIMs) sIM') .
}
:apply (canstartcsp rd-)
-- Case 2-2: unwired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-2-4-4: unwired swired swired
-- RD-wire2 should be applied
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-4-4-2-1-3-3: stopped sstarted sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      LS:LocalState <- st(stopped,sstarted,sstarted); }
:apply (rd-)
-- Case 2-2-4-4-2-2-1-3: started stopped sstarted is discharged by C02
-- Case 2-2-4-4-2-2-2-3: started started sstarted is discharged by C03
-- Case 2-3: wired
:apply (nIMscsp tIMscsp rd-)
-- Case 2-3-3-4: wired wired swired
:apply (exECOcsp rd-)
:apply (cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-3-3-4-2-1-3-3: stopped sstarted sstarted
:init as robust-lemmaNOC-in [robust-lemmaNOC]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      L:ListOfLog <- lg;
      LS:LocalState <- st(stopped,sstarted,sstarted); }
:apply (rd-)
--> Proof of robust-lemmaC04 done
-->
show proof
close

--> Totally 6 goals should be proved.
eof

Memo: Dependency of Lemmas
robust-lemmaC01 = cont when inv and inState(CO,st(started,stopped,stopped)) .
DDSCD
2-2-1-2-2-2-2-1-1: started stopped stopped  -> NOC

robust-lemmaC02 = cont when inv and inState(CO,st(started,stopped,sstarted)) .
DDCSD
2-2-1-1-1-2-2: mandatory wired unwired unwired
 2-2-1-1-1-2-2-1-1-1: stated stopped stopped -> C01
2-2-1-1-1-2-4: mandatory wired unwired swired
 2-2-1-1-1-2-4-1-1-1: stated stopped stopped -> C01
 2-2-1-1-1-2-4-1-1-3: started stopped sstarted -> NOC

robust-lemmaC03 = cont when inv and inState(CO,st(started,started,sstarted)) .
DDCSU
2-3-3-4-2-2-2-3: started started sstarted -> NOC

robust-lemmaC04 = cont when inv and inState(CO,st(stopped,sstarted,sstarted)) .
DDCSU
2-2-4-4: mandatory unwired swired swired
 2-2-4-4-2-1-3-3: stopped sstarted sstarted -> NOC
 2-2-4-4-2-2-1-3: started stopped sstarted  -> C02
 2-2-4-4-2-2-2-3: started started sstarted  -> C03
2-3-3-4: mandatory wired wired swired
 2-3-3-4-2-1-3-3: stopped sstarted sstarted -> NOC
