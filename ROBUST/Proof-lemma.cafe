require Proof Proof.cafe

--> Common lemmas in this domain.

module ROBUSTLEMMA {
  protecting(ProofBase)

  pred (_when _) : Bool Bool { prec: 63 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  -- Nat Axiom
  vars X X1 X2 Y Y1 Y2 Z Z1 Z2 : Nat

  ceq (X >= Y) = true
    if (X > Y) .

  eq ((X + Z) >= (Y + Z))
    =  (X >= Y) .

  ceq ((X + Z1) = (Y + Z2))
    =  (Z1 = Z2)
   if  (X = Y) .

  ceq ((X + Z1) >= (Y + Z2))
    =  (X >= Y) 
    if (Z1 >= Z2) .

  ceq ((X1 + Y1) > (X2 + Y2)) = true
    if (X1 >= X2) and (Y1 > Y2) .
  
  ceq ((X1 + Y1) >= (X2 + Y2)) = true
    if (X1 >= X2) and (Y1 >= Y2) .
  
  vars CO CO' CO0 : Component
  vars SCO SCO' SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  vars CSCO' NSCO' TSCO' : COState
  var StCO : SetOfCOState

  vars IM IM' IM0 : Import
  vars SIM SIM' SIM0 : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog

  pred robust-lemma10 : SetOfComponent Import SetOfImport
  eq robust-lemma10(SCO,IM,SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) = allFFCOHasFFIIM(SCO, SIM)) 
   when (not existCO(SCO,importer(IM))) .

  pred robust-lemma11 : SetOfComponent SetOfImport
  eq robust-lemma11(SCO,SIM)
     = (allFFCOHasFFIIM(SCO,SIM) = true)
   when stableCOSet(SCO) .

  pred robust-lemma12 : SetOfImport SetOfComponent
  eq robust-lemma12(SIM,SCO)
     = (allFFIMHasFFECO(SIM,SCO) = true)
   when stableIMSet(SIM) .

  pred robust-lemma13 : SetOfComponent Import Import SetOfImport
  eq robust-lemma13(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM'))
    and not isForcing1(IM)
    and not isForced1(IM)
    and (tdis(IM) >= tdis(IM'))
    and (fdis(IM) > fdis(IM')) .

  pred robust-lemma14 : SetOfComponent Import Import SetOfImport
  eq robust-lemma14(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM')) and 
        not isForcing1(IM) and not isForced1(IM) and
        (tdis(IM) > tdis(IM')) and
        (fdis(IM) >= fdis(IM')) .

  pred robust-lemma15 : SetOfComponent Import Import SetOfImport
  eq robust-lemma15(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM')) and 
        isForcing1(IM) and isForcing1(IM') and
        (tdis(IM) > tdis(IM')) .

  -- This lemma is not necessary.
  pred robust-lemma16 : SetOfComponent Import Import SetOfImport
  eq robust-lemma16(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM')) and 
        uniqCO(SCO) and allIMHaveICO(IM,SCO) and
        not isForced1(getComponent(SCO,importer(IM))) and
        (fdis(IM) > fdis(IM')) .

  pred robust-lemma17 : SetOfComponent Import Import SetOfImport
  eq robust-lemma17(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM')) and 
        (state(IM)   = unwired) and
        (next(IM)    = wired) and
        (target(IM)  = wired) and
       (state(IM')  = wired) and
       (next(IM')   = wired) and
       (target(IM') = wired) .

  pred robust-lemma18 : SetOfComponent Import Import SetOfImport
  eq robust-lemma18(SCO,IM,IM',SIM)
     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
   when (importer(IM) = importer(IM')) and 
        (type(IM)    = optional) and
        (state(IM)   = wired) and
        (next(IM)    = unwired) and
        (target(IM)  = wired) and
        (state(IM')  = unwired) and
        (next(IM')   = unwired) and
        (target(IM') = wired) .

  pred robust-lemma19 : SetOfImport Component Component SetOfComponent
  eq robust-lemma19(SIM,CO,CO',SCO)
     = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
   when (id(CO) = id(CO')) and 
        not isForced1(CO) and not isForced1(CO') and
        (tdis(CO) > tdis(CO')) .

  pred robust-lemma20 : SetOfImport Component Component SetOfComponent
  eq robust-lemma20(SIM,CO,CO',SCO)
     = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
   when (id(CO) = id(CO')) and 
        not isForced1(CO) and isForced1(CO') and
        (fdis(CO) > fdis(CO')) .

  pred robust-lemma21 : SetOfImport Component SetOfComponent
  eq robust-lemma21(SIM,CO,SCO)
     = (allFFIMHasFFECO(SIM, CO SCO) = allFFIMHasFFECO(SIM, SCO))
   when getIMsOfECOInStates(SIM,id(CO),wired) = empIM .

}

--> **************************************************************************
--> Proof of robust-lemma10.
-->  eq robust-lemma10(SCO,IM,SIM)
-->     = (allFFCOHasFFIIM(SCO,IM SIM) = allFFCOHasFFIIM(SCO,SIM))
-->   when (not existCO(SCO,importer(IM))) .
--> **************************************************************************
module ROBUSTLEMMA10 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma10-IH :nonexec]:
     robust-lemma10(SCO:SetOfComponent, im, sIM) = true
     if SCO <wf (co sCO) .
}

select ROBUSTLEMMA10
:goal { eq robust-lemma10(sCO0, im, sIM) = true .}
:init as robust-lemma10-IH-in [robust-lemma10-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0)
:apply (rd-)
:def idcoctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (idcoctf)
:apply (rd-)
:def isFF1coctf = :ctf {
  eq isForced1(co) = true .
}
:apply (isFF1coctf rd-)
:def existFFctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,id(co))) = true .
}
:apply (existFFctf rd-)
--> Proof of robust-lemma10 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma11.
-->  ceq robust-lemma11(SCO,SIM)
-->     = (allFFCOHasFFIIM(SCO,SIM) = true)
-->   when stableCOSet(SCO) .
--> **************************************************************************
module ROBUSTLEMMA11 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma11-IH :nonexec]:
     robust-lemma11(SCO:SetOfComponent, sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA11
:goal { eq robust-lemma11(sCO0, sIM) = true .}
:init as robust-lemma11-IH-in [robust-lemma11-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (sCO0 cCOs nCOs tCOs rd-)
--> Proof of robust-lemma11 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma12.
-->  ceq robust-lemma12(SIM,SCO)
-->     = (allFFIMHasFFECO(SIM,SCO) = true)
-->   when stableIMSet(SIM) .
--> **************************************************************************
module ROBUSTLEMMA12 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma12-IH :nonexec]:
     robust-lemma12(SIM:SetOfImport, sCO) = true
     if SIM <wf (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}

select ROBUSTLEMMA12
:goal { eq robust-lemma12(sIM0, sCO) = true .}
:init as robust-lemma12-IH-in [robust-lemma12-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}
:def cIMs = :csp {
  eq cIMs = wired .
  eq cIMs = unwired .
  eq cIMs = unused .
}
:def nIMs = :csp {
  eq nIMs = wired .
  eq nIMs = unwired .
  eq nIMs = unused .
}
:def tIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (sIM0 cIMs nIMs tIMs rd-)
--> Proof of robust-lemma12 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma13.
-->  ceq robust-lemma13(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->    if (importer(IM) = importer(IM') and 
-->       not isForcing1(IM) and not isForced1(IM) and
-->       (tdis(IM) >= tdis(IM')) and
-->       (fdis(IM) > fdis(IM')) .
--> **************************************************************************
module ROBUSTLEMMA13 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma13-IH :nonexec]:
     robust-lemma13(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA13
:goal { eq robust-lemma13(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:def isF1imctf = :ctf {
  eq isForcing1(im) = true .
}
:def isFF1imctf = :ctf {
  eq isForced1(im) = true .
}
:apply (importerimctf isF1imctf isFF1imctf rd-)
:init as robust-lemma13-IH-in [robust-lemma13-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
:apply (sCO0)
:apply (rd-)
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (cCOs nCOs tCOs rd-)
:def idCOctf = :ctf {
  eq idCO = importer(im) .
}
-- Note that existFFctf differs for each case of idCOctf.
:apply (idCOctf)
:def existFFimctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:apply (existFFimctf rd-)
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,idCO)) = true .
}
:apply (existFF2ctf rd-)
--> Proof of robust-lemma13 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma14.
-->  ceq robust-lemma14(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->    if (importer(IM) = importer(IM') and 
-->       not isForcing1(IM) and not isForced1(IM) .
-->       (fdis(IM) > fdis(IM')) and (fdis(IM') > 0) .
--> **************************************************************************
module ROBUSTLEMMA14 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma14-IH :nonexec]:
     robust-lemma14(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA14
:goal { eq robust-lemma14(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:def isF1imctf = :ctf {
  eq isForcing1(im) = true .
}
:def isFF1imctf = :ctf {
  eq isForced1(im) = true .
}
:apply (importerimctf isF1imctf isFF1imctf rd-)
:init as robust-lemma14-IH-in [robust-lemma14-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
:apply (sCO0 rd-)
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (cCOs nCOs tCOs rd-)
:def idCOctf = :ctf {
  eq idCO = importer(im) .
}
-- Note that existFFctf differs for each case of idCOctf.
:apply (idCOctf)
:def existFFimctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:apply (existFFimctf rd-)
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,idCO)) = true .
}
:apply (existFF2ctf rd-)
--> Proof of robust-lemma14 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma15.
-->  ceq robust-lemma15(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->    if (importer(IM) = importer(IM') and 
-->       isForcing1(IM) and isForcing1(IM') .
-->       (tdis(IM) > tdis(IM')) .
--> **************************************************************************
module ROBUSTLEMMA15 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma15-IH :nonexec]:
     robust-lemma15(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA15
:goal { eq robust-lemma15(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:def isF1imctf = :ctf {
  eq isForcing1(im) = true .
}
:def isF1im'ctf = :ctf {
  eq isForcing1(im') = true .
}
:apply (importerimctf isF1imctf isF1im'ctf rd-)
:init as robust-lemma15-IH-in [robust-lemma15-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}
-- Proof for case 1-1-1
:apply (sCO0 rd-)
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (cCOs nCOs tCOs rd-)
:def idCOctf = :ctf {
  eq idCO = importer(im) .
}
-- Note that existFFctf differs for each case of idCOctf.
:def existFFimctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,idCO)) = true .
}
:apply (idCOctf)
:apply (existFFimctf rd-)
:apply (existFF2ctf rd-)
--> Proof of robust-lemma15 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma16.
-->  pred robust-lemma16 : SetOfComponent Import Import SetOfImport
-->  eq robust-lemma16(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->   when (importer(IM) = importer(IM')) and 
-->        uniqCO(SCO) and allIMHaveICO(IM,SCO) and
-->        not isForced1(getComponent(SCO,importer(IM))) and
-->        (fdis(IM) > fdis(IM')) .
--> **************************************************************************
module ROBUSTLEMMA16 {
  protecting(ROBUSTLEMMA)

  var SCO : SetOfComponent
  var SIM : SetOfImport
  var IM : Import

  -- eq robust-lemma10(SCO,IM,SIM)
  --    = (allFFCOHasFFIIM(SCO, IM SIM) = allFFCOHasFFIIM(SCO, SIM)) 
  --  when (not existCO(SCO,importer(IM))) .
  ceq allFFCOHasFFIIM(SCO, IM SIM) = allFFCOHasFFIIM(SCO, SIM)
     if (not existCO(SCO,importer(IM))) .
}

select ROBUSTLEMMA16
:goal { eq robust-lemma16(sCO, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:apply (importerimctf rd-)
:def IMHaveICOcsp = :csp {
  eq allIMHaveICO(im,sCO) = false .
  eq sCO = (cmp(importer(im),cCOs,nCOs,tCOs) sCO') .
}
:apply (IMHaveICOcsp)
:apply (rd-)
:def existCOctf = :ctf {
  eq existCO(sCO',importer(im)) = true .
}
:apply (existCOctf)
**> It takes 3 minutes. <**
:apply (rd-)
:def cCOs = :csp {
  eq cCOs = started .
  eq cCOs = stopped .
}
:def nCOs = :csp {
  eq nCOs = started .
  eq nCOs = stopped .
}
:def tCOs = :csp {
  eq tCOs = started .
  eq tCOs = stopped .
}
:apply (cCOs nCOs tCOs rd-)
--> Proof of robust-lemma16 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma17.
-->  eq robust-lemma17(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->   when (importer(IM) = importer(IM')) and 
-->        (state(IM)   = unwired) and
-->        (next(IM)    = wired) and
-->        (target(IM)  = wired) and
-->        (state(IM')  = wired) and
-->        (next(IM')   = wired) and
-->        (target(IM') = wired) .
--> **************************************************************************
module ROBUSTLEMMA17 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma17-IH :nonexec]:
     robust-lemma17(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA17
:goal { eq robust-lemma17(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:apply (importerimctf rd-)
:def stateim = :csp {
  eq state(im) = wired .
  eq state(im) = unwired .
  eq state(im) = unused .
}
:apply (stateim rd-)
:def nextim = :csp {
  eq next(im) = wired .
  eq next(im) = unwired .
  eq next(im) = unused .
}
:apply (nextim rd-)
:def targetim = :csp {
  eq target(im) = wired .
  eq target(im) = unwired .
  eq target(im) = unused .
}
:apply (targetim rd-)
:def stateim' = :csp {
  eq state(im') = wired .
  eq state(im') = unwired .
  eq state(im') = unused .
}
:apply (stateim' rd-)
:def nextim' = :csp {
  eq next(im') = wired .
  eq next(im') = unwired .
  eq next(im') = unused .
}
:apply (nextim' rd-)
:def targetim' = :csp {
  eq target(im') = wired .
  eq target(im') = unwired .
  eq target(im') = unused .
}
:apply (targetim' rd-)
:init as robust-lemma17-IH-in [robust-lemma17-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0 rd-)
:def isFF1coctf = :ctf {
  eq isForced1(co) = true .
}
:apply (isFF1coctf rd-)
:def idcoctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (idcOctf)
:def existFFimctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:apply (existFFimctf rd-)
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,id(co))) = true .
}
:apply (existFF2ctf rd-)
--> Proof of robust-lemma17 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma18.
-->  eq robust-lemma18(SCO,IM,IM',SIM)
-->     = (allFFCOHasFFIIM(SCO, IM SIM) implies allFFCOHasFFIIM(SCO, IM' SIM))
-->   when (importer(IM) = importer(IM')) and 
-->        (type(IM)    = optional) and
-->        (state(IM)   = wired) and
-->        (next(IM)    = unwired) and
-->        (target(IM)  = wired) and
-->        (state(IM')  = unwired) and
-->        (next(IM')   = unwired) and
-->        (target(IM') = wired) .
--> **************************************************************************
module ROBUSTLEMMA18 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma18-IH :nonexec]:
     robust-lemma18(SCO:SetOfComponent, im, im', sIM) = true
     if SCO <wf (cmp(idCO,cCOs,nCOs,tCOs) sCO) .
}

select ROBUSTLEMMA18
:goal { eq robust-lemma18(sCO0, im, im', sIM) = true .}
:def importerimctf = :ctf {
  eq importer(im') = importer(im) .
}
:apply (importerimctf rd-)
:def typeim = :csp {
  eq type(im) = mandatory .
  eq type(im) = optional .
}
:apply (typeim rd-)
:def stateim = :csp {
  eq state(im) = wired .
  eq state(im) = unwired .
  eq state(im) = unused .
}
:apply (stateim rd-)
:def nextim = :csp {
  eq next(im) = wired .
  eq next(im) = unwired .
  eq next(im) = unused .
}
:apply (nextim rd-)
:def targetim = :csp {
  eq target(im) = wired .
  eq target(im) = unwired .
  eq target(im) = unused .
}
:apply (targetim rd-)
:def stateim' = :csp {
  eq state(im') = wired .
  eq state(im') = unwired .
  eq state(im') = unused .
}
:apply (stateim' rd-)
:def nextim' = :csp {
  eq next(im') = wired .
  eq next(im') = unwired .
  eq next(im') = unused .
}
:apply (nextim' rd-)
:def targetim' = :csp {
  eq target(im') = wired .
  eq target(im') = unwired .
  eq target(im') = unused .
}
:apply (targetim' rd-)
:init as robust-lemma18-IH-in [robust-lemma18-IH]
      by {SCO:SetOfComponent <- SCO:SetOfComponent;}
:def sCO0 = :csp {
  eq sCO0 = empCO .
  eq sCO0 = (co sCO) .
}
:apply (sCO0 rd-)
:def isFF1coctf = :ctf {
  eq isForced1(co) = true .
}
:apply (isFF1coctf rd-)
:def idcoctf = :ctf {
  eq id(co) = importer(im) .
}
:apply (idcOctf)
:def existFFimctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,importer(im))) = true .
}
:apply (existFFimctf rd-)
:def existFF2ctf = :ctf { 
  eq existFFIM(getIMsOfICO(sIM,id(co))) = true .
}
:apply (existFF2ctf rd-)
--> Proof of robust-lemma18 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma19.
-->  eq robust-lemma19(SIM,CO,Co',SCO)
-->     = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
-->   when (id(CO) = id(CO')) and 
-->        not isForced1(CO) and not isForced1(CO') and
-->        (tdis(IM) > tdis(IM')) .
--> **************************************************************************
module ROBUSTLEMMA19 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma19-IH :nonexec]:
     robust-lemma19(SIM:SetOfImport, co, co', sCO) = true
     if SIM <wf (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}

select ROBUSTLEMMA19
:goal { eq robust-lemma19(sIM0, co, co', sCO) = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def isFF1coctf = :ctf {
  eq isForced1(co) = true .
}
:def isFF1co'ctf = :ctf {
  eq isForced1(co') = true .
}
:apply (idcoctf isFF1coctf isFF1co'ctf rd-)
:init as robust-lemma19-IH-in [robust-lemma19-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def idcoisExporterctf = :ctf {
  eq id(co) = exporter(im) .
}
:def isFFimctf = :ctf {
  eq isForced1(im) = true .
}
:apply (idcoisExporterctf isFFimctf rd-)
:def isFF1imcoctf = :ctf {
  eq isForced1(getComponent(sCO,exporter(im))) = true .
}
:apply (isFF1imcoctf rd-)
--> Proof of robust-lemma19 done.
-->
show proof
select

--> **************************************************************************
--> Proof of robust-lemma20.
-->  eq robust-lemma20(SIM,CO,Co',SCO)
-->     = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
-->   when (id(CO) = id(CO')) and 
-->        not isForced1(CO) and isForced1(CO') and
-->        (fdis(CO) > fdis(CO')) .
--> **************************************************************************
module ROBUSTLEMMA20 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma20-IH :nonexec]:
     robust-lemma20(SIM:SetOfImport, co, co', sCO) = true
     if SIM <wf (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM) .
}

select ROBUSTLEMMA20
:goal { eq robust-lemma20(sIM0, co, co', sCO) = true .}
:def idcoctf = :ctf {
  eq id(co') = id(co) .
}
:def isFF1coctf = :ctf {
  eq isForced1(co) = true .
}
:def isFF1co'ctf = :ctf {
  eq isForced1(co') = true .
}
:apply (idcoctf isFF1coctf isFF1co'ctf rd-)
:init as robust-lemma20-IH-in [robust-lemma20-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def idcoisExporterctf = :ctf {
  eq id(co) = exporter(im) .
}
:def isFFimctf = :ctf {
  eq isForced1(im) = true .
}
:apply (idcoisExporterctf isFFimctf rd-)
:def isFF1imcoctf = :ctf {
  eq isForced1(getComponent(sCO,exporter(im))) = true .
}
:apply (isFF1imcoctf rd-)
--> Proof of robust-lemma20 done.
-->
show proof

--> **********************************************************************
--> Proof of robust-lemma21.
-->  eq robust-lemma21(SIM,CO,SCO)
-->     = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, SCO))
-->   when getIMsOfECOInStates(SIM,id(CO),wired) = empIM .
--> **********************************************************************
module ROBUSTLEMMA21 {
  protecting(ROBUSTLEMMA)
  -- Induction Hypothesis
  ceq [robust-lemma21-IH :nonexec]:
     robust-lemma21(SIM:SetOfImport, co, sCO) = true
     if SIM <wf (im sIM) .
}

select ROBUSTLEMMA21
:goal { eq robust-lemma21(sIM0, co, sCO) = true .}
:init as robust-lemma21-IH-in [robust-lemma21-IH]
      by {SIM:SetOfImport <- SIM:SetOfImport;}
:def sIM0 = :csp {
  eq sIM0 = empIM .
  eq sIM0 = (im sIM) .
}
:apply (sIM0 rd-)
:def idcoisExporterctf = :ctf {
  eq exporter(im) = id(co) .
}
:def imWiredctf = :ctf {
  eq state(im) = wired .
}
:apply (idcoisExporterctf imWiredctf rd-)
:def isFF1imctf = :ctf {
  eq isForced1(im) = true .
}
:apply (isFF1imctf rd-)
:def isFF1ExpCoctf = :ctf {
  eq isForced1(getComponent(sCO,exporter(im))) = true .
}
:apply (isFF1ExpCoctf rd-)
--> Proof of robust-lemma21 done.
-->
show proof

select

--> Totally 12 goals should be proved.
