require Proof Proof.cafe

module ProofLemma {
  protecting(ProofBase)

  [COSCOSIM] op t : Component SetOfComponent SetOfImport -> COSCOSIM {constr} .
  pred _<wf_ : COSCOSIM COSCOSIM .

  var S : State
  vars CO CO' : Component
  var IM : Import
  vars SCO SCO' : SetOfComponent
  vars SIM SIM' : SetOfImport
  var L : ListOfLog

  -- Cont Lemmas
  pred robust-lemmaC01 : SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC01(SCO,SIM,L)
    = cont(< SCO, SIM, L >) 
      when inv(< SCO, SIM, L >) and
           equivIMSet(SIM) = false .

  pred robust-lemmaC02 : SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaC02(SCO,SIM,L)
    = cont(< SCO, SIM, L >) 
      when inv(< SCO, SIM, L >) and
           equivCOSet(SCO) = false .

  -- NoCyclic Lemmas
  pred robust-lemmaN01 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaN01(CO,SCO,SIM,L)
    = wfs(< (CO SCO), SIM, L >) and inStates(CO,st(started,started,sstarted)) 
      implies someCONoCycle((CO SCO),SIM,st(started,started,sstarted)) .

  pred robust-lemmaN02 : Component SetOfComponent SetOfImport ListOfLog
  eq robust-lemmaN02(CO,SCO,SIM,L)
    = wfs(< (CO SCO), SIM, L >) and inStates(CO,st(started,stopped,stopped)) 
      implies someCONoCycle((CO SCO),SIM,st(started,stopped,stopped)) .
}

--> Proof of robust-lemmaC01
-->  eq robust-lemmaC01(SCO,SIM,L)
-->    = cont(< SCO, SIM, L >) 
-->      when inv(< (SCO, SIM, L >) and
-->           equivIMSet(SIM) = false .
open ProofLemma .
:goal { eq robust-lemmaC01(sCO,sIM,lg) = true . }
:def empIMcsp = :csp  { 
  eq sIM = empIM .
  eq sIM = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}
:def tIMcsp = :csp  { 
  eq tIM = mandatory .
  eq tIM = optional .
}
:def cIMscsp = :csp  { 
  eq cIMs = unused .
  eq cIMs = unwired .
  eq cIMs = wired .
  eq cIMs = swired .
}
:def nIMscsp = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
  eq nIMs = swired .
}
:def tIMscsp = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
  eq tIMs = swired .
}
:def nIMs'csp = :csp  { 
  eq nIMs' = unused .
  eq nIMs' = unwired .
  eq nIMs' = wired .
  eq nIMs' = swired .
}
:def tIMs'csp = :csp  { 
  eq tIMs' = unused .
  eq tIMs' = unwired .
  eq tIMs' = wired .
  eq tIMs' = swired .
}
:def cCOscsp = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
  eq cCOs = sstarted .
}
:def nCOscsp = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
  eq nCOs = sstarted .
}
:def tCOscsp = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
  eq tCOs = sstarted .
}
:def exICOcsp = :csp  { 
  eq existCO(sCO,iidCO) = false .
  eq sCO = (cmp(iidCO,cCOs,nCOs,tCOs) sCO') .
}
:def exECOcsp = :csp  { 
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:def equivIMctf = :ctf  { 
  eq equivIMSet(sIM) = true .
}
:apply(equivIMctf rd-)
-- Case 2: equivIMSet(sIM) = false means that
--          at least one import whose state is not target.
-- :init eq equivIMSet(sIM) = false .
:init (ceq true = false
	if equivIMSet(SIM:SetOfImport) . ) by {
  SIM:SetOfImport <- sIM;
}
:apply(empIMcsp rd-)
-- Case 2-2:
:init (ceq true = false
	if CIMS:IMState = TIMS:IMState . ) by {
  CIMS:IMState <- cIMs;
  TIMS:IMState <- tIMs;
}
:apply(tIMcsp cIMscsp nIMscsp tIMscsp rd-)
-- When (cIMs = tIMs), it is discharged by :init eq (cIMs = tIMs) = false .
-- Case 2-2-1-2-4-4: mandatory unwired swired swired
-- RD-wire2 should be applied
:apply(exECOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-2-4-4-2-1-3-3: stopped sstarted sstarted
-- RD-start should be applied
:def cansstartcsp = :csp {
  eq allIMInStates(getIMsOfTypeOfICO(sIM',mandatory,eidCO),(swired unused)) = true .
  eq sIM' = (imp(mandatory, idIM', idCO, iidCO, unwired, nIMs', tIMs') sIM'') .
  eq sIM' = (imp(mandatory, idIM', idCO, iidCO,   wired, nIMs', tIMs') sIM'') .
}
:apply(cansstartcsp rd-)
:apply(nIMs'csp tIMs'csp rd-)
eof
-- Case 2-2-1-2-4-4-2-2-1-3: started stopped sstarted
-- RD-stop should be applied
-- Case 2-2-1-2-4-4-2-2-2-3: started started sstarted
-- RS-sstart2 or RSstop2 should be applied
-- RD-wire1 should be applied
:apply(exICOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 2-2-1-2-4-4-2-1-3-3: stopped sstarted sstarted
-- RD-start cannot be applied
eof
-- Case 2-2-1-3-2-2: mandatory wired unwired unwired
-- Case 2-2-1-3-2-4: mandatory wired unwired swired
-- Case 2-2-1-3-3-4: mandatory wired wired swired
-- Case 2-2-2-2-4-4: optional unwired swired swired
-- Case 2-2-2-3-3-4: optional wired wired swired

-- Case 3-2-3-3-4:wired,wired,swired
:apply(exECOcsp rd-)
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 3-2-3-3-4-1: wfs-allIMHaveECO is false.
-- Case 3-2-3-3-4-2:
:apply(cCOscsp nCOscsp tCOscsp rd-)
-- Case 3-2-3-3-4-2-2-2-3: it is discharged by robust-lemmaIC .
--> Proof of (1) init(S) implies cont(S) done
-->
eof
--> Proof of robust-lemmaC01 done
-->
show proof
close
eof
--> Proof of robust-lemmaN01
-->  eq robust-lemmaN01(CO,SCO,SIM,L)
-->    = wfs(< (CO SCO), SIM, L >) and inStates(CO,st(started,started,sstarted)) 
-->      implies someCONoCycle((CO SCO),SIM,st(started,started,sstarted)) .
open ProofLemma .
  -- Define DDSC for robust-lemmaN01
  eq DDSC(CO,SCO,SIM) = DDSCU(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaN01-IH :nonexec]:
    (wfs(< (CO SCO), SIM, lg >) and inStates(CO,st(started,started,sstarted))
     implies someCONoCycle((CO' SCO'),SIM,st(started,started,sstarted))) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaN02
  ceq ( t(CO',SCO',(IM SIM')) <wf t(CO,SCO,(IM SIM')) ) = true
     if inStates(CO, st(started,started,sstarted)) and
        inStates(CO',st(started,started,sstarted)) and
        importer(IM) = id(CO) and exporter(IM) = id(CO') and
        type(IM) = mandatory and state(IM) = wired and target(IM) = swired and 
        SCO' <wf SCO .

  eq co = cmp(idCO,cCOs,nCOs,tCOs) .
  -- for debug
  -- op lst : -> LocalState .
  -- eq lst = st(started,started,sstarted) .

:goal { eq robust-lemmaN01(co,sCO,sIM,lg) = true . }
:def cCOsctf = :ctf { eq cCOs = started . } :apply(cCOsctf rd-)
:def nCOsctf = :ctf { eq nCOs = started . } :apply(nCOsctf rd-)
:def tCOsctf = :ctf { eq tCOs = sstarted . } :apply(tCOsctf rd-)
-- Case 1-1-1: (started,stared,sstarted) 
:def hasECOcsp = :csp {
  eq allCONotInStates(
        getECOsOfIMs(sCO,
                     getIMsOfICOInTargetStates(
                          getIMsOfTypeOfICOInStates(sIM,mandatory,idCO,wired),
                          idCO,swired)),
        st(started,started,sstarted)) = true .
  eq sIM = (imp(mandatory,idIM,idCO,eidCO,wired,nIMs,swired) sIM') .
}
:apply(hasECOcsp rd-)
-- 1-1-1-2: imp(mandatory,idIM,idCO,eidCO,wired,nIMs,swired)
:csp {
  eq sCO = (cmp(eidCO,started,started,sstarted) sCO') .
}
:init as robust-lemmaN01-IH-in [robust-lemmaN01-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(eidCO,started,started,sstarted);
      SCO':SetOfComponent <- sCO'; }
:apply(rd-)

--> Proof of robust-lemmaN01 done
-->
show proof
close

--> Proof of robust-lemmaN02
-->  eq robust-lemmaN02(CO,SCO,SIM,L)
-->    = wfs(< (CO SCO), SIM, L >) and inStates(CO,st(started,stopped,stopped)) 
-->      implies someCONoCycle((CO SCO),SIM,st(started,stopped,stopped)) .
open ProofLemma .
  -- Define DDSC for robust-lemmaN02
  eq DDSC(CO,SCO,SIM) = DDSCD(CO,SCO,SIM) .

  -- Induction Hypothesis
  ceq [robust-lemmaN02-IH :nonexec]:
    (wfs(< (CO SCO), SIM, lg >) and inStates(CO,st(started,stopped,stopped))
     implies someCONoCycle((CO' SCO'),SIM,st(started,stopped,stopped))) = true
    if t(CO',SCO',SIM) <wf t(CO,SCO,SIM) .

  -- Define <wf for robust-lemmaN02
  ceq ( t(CO',SCO',(IM SIM')) <wf t(CO,SCO,(IM SIM')) ) = true
     if inStates(CO, st(started,stopped,stopped)) and
        inStates(CO',st(started,stopped,stopped)) and
        exporter(IM) = id(CO) and importer(IM) = id(CO') and type(IM) = mandatory and
        SCO' <wf SCO .

  eq co = cmp(idCO,cCOs,nCOs,tCOs) .
  -- for debug
  -- op lst : -> LocalState .
  -- eq lst = st(started,started,sstarted) .

:goal { eq robust-lemmaN02(co,sCO,sIM,lg) = true . }
:def cCOsctf = :ctf { eq cCOs = started . } :apply(cCOsctf rd-)
:def nCOsctf = :ctf { eq nCOs = stopped . } :apply(nCOsctf rd-)
:def tCOsctf = :ctf { eq tCOs = stopped . } :apply(tCOsctf rd-)
-- Case 1-1-1: (started,stopped,stopped) 
:def hasICOcsp = :csp {
  eq allCONotInStates(
       getICOsOfIMs(sCO,
         getIMsOfTypeOfECOInStates(sIM,mandatory,idCO,wired)),
       st(started,stopped,stopped)) = true .
  eq sIM = (imp(mandatory,idIM,iidCO,idCO,wired,nIMs,tIMs) sIM') .
}
:apply(hasICOcsp rd-)
-- 1-1-1-2: imp(mandatory,idIM,idCO,eidCO,wired,nIMs,tIMs)
:csp {
  eq sCO = (cmp(iidCO,started,stopped,stopped) sCO') .
}
:init as robust-lemmaN02-IH-in [robust-lemmaN02-IH]
  by {CO:Component <- co;
      SCO:SetOfComponent <- sCO;
      SIM:SetOfImport <- sIM;
      CO':Component <- cmp(iidCO,started,stopped,stopped);
      SCO':SetOfComponent <- sCO'; }
:apply(rd-)

--> Proof of robust-lemmaN02 done
-->
show proof
close

--> Totally 2 goals should be proved.
