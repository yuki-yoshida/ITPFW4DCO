require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> ************************************************************************************
--> ctrans [RS-sstart2]:
-->    < (cmp(IDCO, started,  started, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart2:Should Stably Start", cmp(IDCO, started, sstarted, sstarted),
-->         mlog(
-->      (cmp(IDCO, started,  started, sstarted) SCO), SIM
-->        )) ListLG) >
-->    if allIMInStates(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(swired unused)) .
--> ************************************************************************************

open ProofContCont .
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< (cmp(idCO, started,  started, sstarted) sCO), sIM, lg >) = true .
}
--> ******************************************************
--> Step 2-2: Split the current case for a rule into cases
--> where the condition of the rule does or does not hold.
--> ******************************************************
:def ctf2-2RS-sstart2 = :ctf {
  eq allIMInStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(swired unused)) = true .
}
:apply (ctf2-2RS-sstart2 rd-)
:apply (rd-)
--> Proof of (2) inv(S) and not final(S) and inv(SS) implies cont(SS) or final(SS).
-->   for Rule RS-sstart2 done
-->
show proof
close

--> Totally 1 goal should be proved.
