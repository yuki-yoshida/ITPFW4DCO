require NatAxiom ../lib/NatAxiom.cafe
require Proof Proof.cafe

--> *************************************************
--> (3) inv(S) and not final(S) implies m(S) > m(SS).
--> *************************************************

module ProofMeasure {
  protecting(ProofBase)

--> *************************************
--> Step 3-0: Use natural number axioms.
--> *************************************
  protecting(NATAXIOM)

--> ******************************************
--> Step 3-1: Define a predicate to be proved.
--> ******************************************
  vars S SS : State
  var CC : Bool

  pred mmes : State State .
  eq mmes(S,SS)
     = inv(S) and not final(S) implies m(S) > m(SS) .

  pred mesmes : State .
  eq mesmes(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies mmes(S,SS)) == true)
     	   { S => SS !! CC ! inv(S) ! final(S) ! (m(S) > m(SS)) }) .

  vars CO CO' CO0 : Component
  var IDCO : COID
  vars SCO SCO' SCO0 SCO1 : SetOfComponent
  vars IM IM' IM0 : Import
  vars SIM SIM' SIM0 SIM1 : SetOfImport

  vars BID BID' : BagOfID

  vars X X1 X2 Y Y1 Y2 Z1 Z2 : Nat

  -- Nat Axioms
  ceq ((X1 + Y1) > (X2 + Y2)) = true
    if (X1 >= X2) and (Y1 > Y2) .
  
  -- ceq ((X1 + Y1) >= (X2 + Y2)) = true
  --   if (X1 >= X2) and (Y1 >= Y2) .
  
  ceq ((X + Z1) > (Y + Z2)) =  (X > Y) 
    if Z1 = Z2 .

  -- Lemmas

  -- eq robust-lemmaM20(SIM,CO,CO',SCO0,SIM0)
  --   = (makeIDBag(SIM,(CO  SCO0),SIM0) =
  --      makeIDBag(SIM,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and not isForced(CO)
  --    and not isForced(CO') .
  ceq (makeIDBag(SIM,(CO  SCO0),SIM0) =
       makeIDBag(SIM,(CO' SCO0),SIM0)) = true 
    if id(CO) = id(CO') and
       not isForced(CO) and
       not isForced(CO') .

  -- eq robust-lemmaM21(SIM,CO,CO',SCO0,SIM0)
  --   = (makeIDBag(SIM,(CO  SCO0),SIM0) =
  --      makeIDBag(SIM,(CO' SCO0),SIM0))
  --   when id(CO) = id(CO')
  --    and isForced(CO)
  --    and isForced(CO') .
  ceq [robust-lemmaM21 :nonexec]:
      makeIDBag(SIM,(CO  SCO0),SIM0)
      = makeIDBag(SIM,(CO' SCO0),SIM0)
    if id(CO) = id(CO') and
       isForced(CO) and
       isForced(CO') .

  -- eq robust-lemmaM22(BID,CO,CO',SCO,SIM)
  --   = fdis(BID,(CO  SCO),SIM) >= 
  --     fdis(BID,(CO' SCO),SIM) 
  --   when id(CO) = id(CO')
  --    and fdis(CO) >= fdis(CO') .
  ceq (fdis(BID, (CO  SCO),SIM) >= 
       fdis(BID',(CO' SCO),SIM) ) = true
    if BID = BID' and
       id(CO) = id(CO') and
       fdis(CO) >= fdis(CO') .

  -- Additional fresh constants
  op bID : -> BagOfID
  -- eq robust-lemmaM23(SIM,CO,SCO)
  --   = cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM)
  --   when isForced1(CO)
  --    and allFFCOHasFFIIM((CO SCO),SIM)
  --    and allFFIMHasFFECO(SIM,(CO SCO)) .
  ceq [robust-lemmaM23 :nonexec]:
      makeIDBag(SIM,(CO SCO),SIM) = (cid(id(CO)) BID)
    if isForced1(CO) and
       allFFCOHasFFIIM((CO SCO),SIM) and
       allFFIMHasFFECO(SIM,(CO SCO)) . 

  -- eq robust-lemmaM24(SIM,IDCO,SCO0,SIM0)
  --   = makeIDBag(SIM,(cmp(IDCO,started,started,started) SCO0),SIM0) =
  --     makeIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO0),SIM0)
  --   when canStart(IDCO,SCO0,SIM0)
  --    and subset(SIM,SIM0) .
  ceq makeIDBag(SIM,(cmp(IDCO,started,started,started) SCO),SIM) =
      makeIDBag(SIM,(cmp(IDCO,stopped,started,started) SCO),SIM)
    if canStart(IDCO,SCO,SIM) .

  -- eq robust-lemmaM25(SIM,CO,SCO)
  --   = not (cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM))
  --  when canStart(id(CO),(CO SCO0),SIM0)
  --   and subset(SIM,SIM0) .
  ceq [robust-lemmaM25 :nonexec]:
      (cid(id(CO)) in makeIDBag(SIM,(CO SCO),SIM)) = false
    if canStart(id(CO),(CO SCO),SIM) .

  -- eq robust-lemmaM26(CO,SCO0,SIM0)
  --    = (canStart(id(CO),(CO SCO0),SIM0) = canStart(id(CO),SCO0,SIM0)) .
  ceq canStart(idCO,(CO SCO0),SIM0) = canStart(idCO,SCO0,SIM0) 
    if idCO = id(CO) .

  -- eq robust-lemmaM27(BID,CO,SCO,SIM)
  --   = (fdis(BID,(CO  SCO),SIM) = fdis(BID,SCO,SIM))
  --   when not cid(id(CO)) in BID .
  ceq fdis(BID,(CO SCO),SIM) = fdis(BID,SCO,SIM)
    if not cid(id(CO)) in BID .

  -- eq robust-lemma20(SIM,CO,CO',SCO)
  --    = (allFFIMHasFFECO(SIM, CO SCO) implies allFFIMHasFFECO(SIM, CO' SCO))
  --  when (id(CO) = id(CO')) and 
  --       not isForced1(CO) and isForced1(CO') and
  --       (fdis(CO) > fdis(CO')) .
  ceq allFFIMHasFFECO(SIM, cmp(IDCO, started, stopped, started) SCO) = true
    if allFFIMHasFFECO(SIM, cmp(IDCO, started, started, started) SCO) .

}

--> **************************************************************************
--> trans [RS-start1]:
-->    < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->      (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started),
--> 	  mlog(
-->      (cmp(IDCO, stopped, stopped, started) SCO), SIM
--> 	 )) ListLG) > .
--> **************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-start1 done.
-->
show proof
select

--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
--> 	  mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, stopped) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 done.
-->
show proof
select

--> ************************************************************************
--> trans [RS-stop2]:
-->    < (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       ListLG >
--> => < (cmp(IDCO, started, stopped, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->      (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, started),
--> 	  mlog(
-->      (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, started) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
              lg >) = true .
}
:init as robust-lemmaM21-in [robust-lemmaM21] by
  {CO:Component  <- cmp(idCO,started,started,started);
   CO':Component <- cmp(idCO,started,stopped,started);}
:def tIMscsp = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMscsp rd-)
:def allFFCOctf = :ctf {
  eq allFFCOHasFFIIM(sCO,(imp(mandatory,idIM,idCO,eidCO,wired,unwired,wired) sIM)) = true .
}  
:def allFFIMctf = :ctf {
  eq allFFIMHasFFECO((imp(mandatory,idIM,idCO,eidCO,wired,unwired,wired) sIM),
		     (cmp(idCO, started, started, started) sCO)) = true .
}  
:apply (allFFCOctf allFFIMctf rd-)
:init as robust-lemmaM23-in [robust-lemmaM23] by
  {SIM:SetOfImport <- (imp(mandatory,idIM,idCO,eidCO,wired,unwired,wired) sIM);
   CO:Component  <- cmp(idCO,started,stopped,started);
   BID:BagOfID <- bID;}
:apply (rd-)
--> Proof of RS-stop2 done.
-->
show proof
select

--> ******************************************************************
--> ctrans [RD-start]:
-->    < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, started, started) SCO), SIM,
-->      (clog("RD-start:Do Start", cmp(IDCO, started, started, started),
-->	  mlog(
-->       (cmp(IDCO, stopped, started, started) SCO), SIM
-->	 )) ListLG) >
-->     if canStart(IDCO,SCO,SIM) .
--> ******************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, stopped, started, started) sCO), sIM,
              lg >) = true .
}
:init as robust-lemmaM25-in [robust-lemmaM25] by
  {CO:Component  <- cmp(idCO,stopped,started,started);}
:def canStartctf = :ctf  {
  eq canStart(idCO, sCO, sIM) = true .
}
:apply (canStartctf rd-)
--> Proof of RD-start done.
-->
show proof
select

--> Totally 4 goals should be proved.
eof
--> ****************************************************************************************
--> trans [RS-wire]:
-->      < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM),
-->        ListLG >
-->   => < SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired,   wired, wired) SIM),
-->        (ilog("RS-wire:Should Wire", imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired),
--> 	  mlog(
-->        SCO, (imp(TIM, IDIM, IIDCO, EIDCO, unwired, unwired, wired) SIM)
--> 	 )) ListLG) > .
--> ****************************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< sCO, (imp(tIM, idIM, iidCO, eidCO, unwired, unwired, wired) sIM), lg >) = true .
}
:apply (rd-)
--> Proof of RS-wire done.
-->
show proof
select

