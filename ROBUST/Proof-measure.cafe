require NatAxiom ../lib/NatAxiom.cafe
require Proof Proof.cafe

--> *************************************************
--> (3) inv(S) and not final(S) implies m(S) > m(SS).
--> *************************************************

module ProofMeasure {
  protecting(ProofBase)

--> *************************************
--> Step 3-0: Use natural number axioms.
--> *************************************
  protecting(NATAXIOM)

--> ******************************************
--> Step 3-1: Define a predicate to be proved.
--> ******************************************
  vars S SS : State
  var CC : Bool

  pred mmes : State State .
  eq mmes(S,SS)
     = inv(S) and not final(S) implies m(S) > m(SS) .

  pred mesmes : State .
  eq mesmes(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies mmes(S,SS)) == true)
     	   { S => SS !! CC ! inv(S) ! final(S) ! (m(S) > m(SS)) }) .


  vars X Y Z Z1 Z2 : Nat

  ceq ((X + Z1) > (Y + Z2))
    =  (X > Y) 
   if (Z1 = Z2) .

  -- eq ((X + Z) = (Y + Z))
  --   =  (X = Y) .

  -- ceq ((X + Z1) >= (Y + Z2))
  --   =  (X >= Y) 
  --   if (Z1 >= Z2) .

  -- ceq ((X + Z1) > (Y + Z2))
  --   =  (X >= Y) 
  --   if (Z1 > Z2) .

  -- ceq ((X + Z1) = (Y + Z2))
  --   =  (X = Y) 
  --   if (Z1 = Z2) .

  vars CO CO' : Component
  var IDCO : COID
  vars SCO SCO' : SetOfComponent
  vars IM IM' : Import
  vars SIM SIM' : SetOfImport

  -- eq robust-lemma02(SIM, IDCO, SCO', SIM')
  --    = tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') >=
  --      tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
  eq tdis(SIM, (cmp(IDCO,stopped,stopped,started) SCO'), SIM')
   = tdis(SIM, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
  -- Another Version
  eq tdis(SIM, (cmp(IDCO,started,started,stopped) SCO'), SIM')
   = tdis(SIM, (cmp(IDCO,started,stopped,stopped) SCO'), SIM') .
  -- General Version
  -- ceq (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM')) = true
  --   if id(CO) = id(CO') and isFForced(CO) = false and isFForced(CO') = false .

  -- eq robust-lemma03(SCO, IDCO, SCO', SIM')
  --    = tdis(SCO, (cmp(IDCO,stopped,stopped,started) SCO'), SIM') >= 
  --      tdis(SCO, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
  eq tdis(SCO, (cmp(IDCO,stopped,stopped,started) SCO'), SIM')
   = tdis(SCO, (cmp(IDCO,stopped,started,started) SCO'), SIM') .
  -- Another Version
  eq tdis(SCO, (cmp(IDCO,started,started,stopped) SCO'), SIM')
   = tdis(SCO, (cmp(IDCO,started,stopped,stopped) SCO'), SIM') .
  -- General Version
  -- ceq (tdis(SCO, (CO SCO'), SIM') = tdis(SCO, (CO' SCO'), SIM') ) = true
  --   if id(CO) = id(CO') and isFForced(CO) = false and isFForced(CO') = false .

  -- eq robust-lemma05(SIM, IDCO, SIM)
  --    = (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
  --       tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
  eq (tdis(SIM, (cmp(IDCO,started,started,started) SCO'), SIM') >=
      tdis(SIM, (cmp(IDCO,started,stopped,started) SCO'), SIM')) = true .

  -- pred robust-lemma06 : SetOfComponent COID SetOfComponent SetOfImport
  -- eq robust-lemma06(SCO, IDCO, SCO', SIM')
  --    = (tdis(SCO, (cmp(IDCO,started,started,started) SCO'), SIM') >=
  --       tdis(SCO, (cmp(IDCO,started,stopped,started) SCO'), SIM')) .
  eq (tdis(SCO, (cmp(IDCO,started,started,started) SCO'), SIM') >=
      tdis(SCO, (cmp(IDCO,started,stopped,started) SCO'), SIM')) = true .
}

--> **************************************************************************
--> trans [RS-start1]:
-->    < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->      (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started),
--> 	  mlog(
-->      (cmp(IDCO, stopped, stopped, started) SCO), SIM
--> 	 )) ListLG) > .
--> **************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-start1 done.
-->
show proof
select

--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
--> 	  mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, stopped) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 done.
-->
show proof
select

--> ************************************************************************
--> trans [RS-stop2]:
-->    < (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       ListLG >
--> => < (cmp(IDCO, started, stopped, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->      (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, started),
--> 	  mlog(
-->      (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, started) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def ctfidCO = :ctf {
  eq idCO = eidCO .
}
:apply (ctfidCO rd-)
:def csptIMs = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (csptIMs rd-)
show proof
eof
select
--> Totally 3 goals should be proved.
