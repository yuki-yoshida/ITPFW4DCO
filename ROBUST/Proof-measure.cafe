require NatAxiom ../lib/NatAxiom.cafe
require Proof Proof.cafe

--> *************************************************
--> (3) inv(S) and not final(S) implies m(S) > m(SS).
--> *************************************************

module ProofMeasure {
  protecting(ProofBase)

--> *************************************
--> Step 3-0: Use natural number axioms.
--> *************************************
  protecting(NATAXIOM)

--> ******************************************
--> Step 3-1: Define a predicate to be proved.
--> ******************************************
  vars S SS : State
  var CC : Bool

  pred mmes : State State .
  eq mmes(S,SS)
     = inv(S) and not final(S) implies m(S) > m(SS) .

  pred mesmes : State .
  eq mesmes(S)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC implies mmes(S,SS)) == true)
     	   { S => SS !! CC ! inv(S) ! final(S) ! (m(S) > m(SS)) }) .

  vars X Y Z : Nat
  vars CO CO' : Component
  var IDCO : COID
  vars SCO SCO' SCO0 SCO1 : SetOfComponent
  vars IM IM' : Import
  vars SIM SIM' SIM0 SIM1 : SetOfImport

--  vars X X1 X2 Y Y1 Y2 Z1 Z2 : Nat

--  ceq ((X1 + Y1) > (X2 + Y2)) = true
--    if (X1 >= X2) and (Y1 > Y2) .
  
  eq ((X + Z) > (Y + Z))
    =  (X > Y) .

  ceq ((X + tdis(SCO,SCO0,SIM0)) > (Y + tdis(SCO,SCO1,SIM1)))
    =  (X > Y) 
   if (tdis(SCO,SCO0,SIM0) >= tdis(SCO,SCO1,SIM1)) .

  ceq ((X + tdis(SIM,SCO0,SIM0)) > (Y + tdis(SIM,SCO1,SIM1)))
    =  (X > Y) 
   if (tdis(SIM,SCO0,SIM0) >= tdis(SIM,SCO1,SIM1)) .

  ceq ((X + fdis(SIM,SCO0,SIM0)) > (Y + fdis(SIM,SCO1,SIM1)))
    =  (X > Y) 
   if (fdis(SIM,SCO0,SIM0) >= fdis(SIM,SCO1,SIM1)) .

  -- pred robust-lemma02 : SetOfImport Component Component SetOfComponent SetOfImport
  -- tdis(SIM) is the same when a non-isFForced Component is changed
  -- because fdis of non-isFForced Components are zero.
  -- eq robust-lemma02(SIM, CO, CO', SCO', SIM')
  --   = (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
  ceq (tdis(SIM, (CO SCO'), SIM') = tdis(SIM, (CO' SCO'), SIM')) = true
    if (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .

  -- pred robust-lemma03 : SetOfComponent Component Component SetOfComponent SetOfImport
  -- tdis(SCO) is the same when a non-isFForced Component is changed
  -- because tdis and fdis of non-isFForced Components are zero.
  -- eq robust-lemma03(SCO, CO, CO', SCO', SIM')
  --   = (tdis(SCO, (CO SCO'), SIM') = tdis(SCO, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .
  ceq (tdis(SCO, (CO SCO'), SIM') = tdis(SCO, (CO' SCO'), SIM')) = true
    if (id(CO) = id(CO')) and (not isFForced(CO)) and (not isFForced(CO')) .

  -- pred robust-lemma04 : SetOfImport Component Component SetOfComponent SetOfImport
  -- fdis(SIM) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  -- eq robust-lemma04(SIM, CO, CO', SCO', SIM')
  --    = (fdis(SIM, (CO SCO'), SIM') >= fdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (fdis(Co) > fdis(CO'))
  --       and isFForced(CO) and isFForced(CO') .
  ceq (fdis(SIM, (CO SCO'), SIM') >= fdis(SIM, (CO' SCO'), SIM')) = true
   if (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  -- pred robust-lemma05 : SetOfImport Component Component SetOfComponent SetOfImport
  -- tdis(SIM) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  -- eq robust-lemma05(SIM, CO, CO', SCO', SIM')
  --    = (tdis(SIM, (CO SCO'), SIM') >= tdis(SIM, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
  --       and isFForced(CO) and isFForced(CO') .
  ceq (tdis(SIM, (CO SCO'), SIM') >= tdis(SIM, (CO' SCO'), SIM')) = true
   if (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  -- pred robust-lemma06 : SetOfComponent Component Component SetOfComponent SetOfImport
  -- tdis(SCO) may decrease when an isFForced Component is changed
  -- and fdis of the component decreases.
  -- eq robust-lemma06(SCO, CO, CO', SCO', SIM')
  --    = (tdis(SCO, (CO SCO'), SIM') >= tdis(SCO, (CO' SCO'), SIM'))
  --  when (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
  --       and isFForced(CO) and isFForced(CO') .
  ceq (tdis(SCO, (CO SCO'), SIM') >= tdis(SCO, (CO' SCO'), SIM')) = true
   if (id(CO) = id(CO')) and (fdis(CO) > fdis(CO'))
        and isFForced(CO) and isFForced(CO') .

  -- pred robust-lemma30 : Component Component Import  SetOfComponent SetOfImport
  -- eq robust-lemma30(CO,CO',IM,SCO,SIM)
  --    = fdis(getComponent((CO  SCO),importer(IM)),(CO  SCO),SIM) >
  --      fdis(getComponent((CO' SCO),importer(IM)),(CO' SCO),SIM)
  --  when isMandatoryClientOf(CO,IM,(CO SCO),SIM) and
  --       id(CO) = id(CO') and
  -- 	isFForced0(CO) and
  -- 	isFForced1(CO') and
  -- 	isForced(IM) .
  ceq (fdis(getComponent((CO  SCO),importer(IM)),(CO  SCO),SIM) >
       fdis(getComponent((CO' SCO),importer(IM)),(CO' SCO),SIM)) = true
     if isMandatoryClientOf(CO,IM,(CO SCO),SIM) and
        id(CO) = id(CO') and
	isFForced0(CO) and
	isFForced1(CO') and
	isForced(IM) .
}

--> ************************************************************************
--> trans [RS-stop2]:
-->    < (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       ListLG >
--> => < (cmp(IDCO, started, stopped, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->      (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, started),
--> 	  mlog(
-->      (cmp(IDCO, started, started, started) SCO),
-->      (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, started) sCO), 
              (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
              lg >) = true .
}
:def ctfidCO = :ctf {
  eq idCO = eidCO .
}
:apply (ctfidCO)
:apply (rd-)
:def eidCOcsp = :csp {
  eq existCO(sCO,eidCO) = false .
  eq sCO = (cmp(eidCO,cCOs,nCOs,tCOs) sCO') .
}
:apply (eidCOcsp)
:apply (rd-)
:def tIMscsp = :csp {
  eq tIMs = wired .
  eq tIMs = unwired .
  eq tIMs = unused .
}
:apply (tIMscsp rd-)
:def isFFeidCOctf = :ctf {
  eq isFForced1(cmp(eidCO,cCOs,nCOs,tCOs)) = true .
}
:apply(isFFeidCOctf rd-)
:def existFFIMcsp = :csp {
  eq existFFIM(getIMsOfICO(sIM,eidCO)) = false .
  eq sIM = (imp(mandatory, idIM', iidCO, idCO', wired, nIMs, unused) sIM') .
}
:apply (existFFIMcsp rd-)
:def idCO'csp = :csp {
  eq existCO(sCO',idCO') = false .
  eq sCO' = (cmp(idCO',cCOs',nCOs',tCOs') sCO'') .
}
:apply (idCO'csp rd-)
eof
-- It should be isForced(idIM') and isMandatoryClientOf(idCO,idIM').

:def existFFIMcsp = :csp {
  eq existFFIM(getIMsOfICO(sIM,eidCO)) = false .
  eq sIM = (imp(mandatory, idIM', eidCO, idCO', wired, wired, unused) sIM') .
}
:apply(existFFIMcsp rd-)
:def eidCOidCO'ctf = :ctf {
  eq eidCO = idCO' .
}
:apply(eidCOidCO'ctf)
:apply(rd-)
:def isForcedidIM'csp = :csp {
  eq isFForced1(imp(mandatory, idIM', eidCO, idCO', cIMs, nIMs, tIMs')) = true .
  eq isForced(imp(mandatory, idIM', eidCO, idCO', cIMs, nIMs, tIMs')) = true .
}
:def idCOidCO'ctf = :ctf {
  eq idCO = idCO' .
}
:apply(isForcedidIM'csp idCOidCO'ctf rd-)
:select 2-2-1-1-2-2-2-2
:def existidCO'csp = :csp {
  eq existCO(sCO',idCO') = false .
  eq sCO' = (cmp(idCO', cCOs', nCOs', tCOs') sCO'') .
}
:apply(existidCO'csp rd-)
eof
:goal { ** 2-2-1-1-2-2-1-2 -----------------------------------------
  -- context module: ProofMeasure
  -- introduced axioms
    eq [ctfidCO]: (idCO = eidCO) = false .
    eq [eidCOcsp]: sCO = cmp(eidCO, 
       cCOs, nCOs, tCOs) sCO' .
    eq [tIMscsp]: tIMs = wired .
    eq [isFFeidCOctf]: isFForced1(cmp(eidCO, 
       cCOs, nCOs, tCOs)) = true .
    eq [existFFIMcsp]: sIM = imp(mandatory, 
       idIM', 
       eidCO, idCO', cIMs, nIMs, tIMs') sIM' .
    eq [eidCOidCO'ctf]: (eidCO = idCO') = false .
    eq [isForcedidIM'csp]: isFForced1(imp(mandatory, 
       idIM', 
       eidCO, idCO', cIMs, nIMs, tIMs'))
        = true .
    eq [idCOidCO'ctf]: (idCO = idCO') = false .
  -- sentence to be proved
    eq mesmes(< (cmp(idCO, started, started, started) sCO) ,
        (imp(mandatory, 
       idIM, 
       idCO, eidCO, wired, unwired, tIMs) sIM) , lg >)
        = true .
}
    cmp(idCO,started,started,started)
FF1:imp(mandatory,idIM,idCO,eidCO,wired,unwired,wired) 
FF1:cmp(eidCO,cCOs,nCOs,tCOs)
FF1:imp(mandatory,idIM',eidCO,idCO',cIMs,nIMs,tIMs')

select

--> **************************************************************************
--> trans [RS-start1]:
-->    < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->      (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started),
--> 	  mlog(
-->      (cmp(IDCO, stopped, stopped, started) SCO), SIM
--> 	 )) ListLG) > .
--> **************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-start1 done.
-->
show proof
select

--> ************************************************************************
--> trans [RS-stop1]:
-->    < (cmp(IDCO, started, started, stopped) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, started, stopped, stopped) SCO), SIM,
-->      (clog("RS-stop1:Should Stop", cmp(IDCO, started, stopped, stopped),
--> 	  mlog(
-->      (cmp(IDCO, started, started, stopped) SCO), SIM
--> 	 )) ListLG) > .
--> ************************************************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (cmp(idCO, started, started, stopped) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of RS-stop1 done.
-->
show proof
select
eof
--> Totally 3 goals should be proved.
