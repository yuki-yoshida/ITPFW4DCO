require DomainModel DomainModel.cafe
provide Proof

module ProofBase {
  protecting(STATERules)

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  var SCO : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  var SIM : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

--  pred inv-ifCOStartedThenIMReady : State
--  eq inv-ifCOStartedThenIMReady(< SCO,SIM,L >)
--     = ifCOInStatesThenIMInStates(SCO,started,SIM,ready) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Target Distance
  op tdis : Component -> Nat
  op tdis : Import -> Nat
  op tdis : SetOfComponent SetOfComponent SetOfImport -> Nat
  op tdis : SetOfImport SetOfComponent SetOfImport -> Nat

  -- Forced Distance
  -- Forced to become stopped temporally
  op fdis : Component -> Nat
  op fdis : Component SetOfComponent SetOfImport -> Nat
  -- Forced to become unwired temporally
  op fdis : Import -> Nat
  op fdis : SetOfImport SetOfComponent SetOfImport -> Nat

  pred isFForced : Component
  pred isFForced : Import
  pred isForced : Import
  eq isFForced(cmp(IDCO,started,started,started)) = true . -- case (C)
  eq isFForced(cmp(IDCO,started,stopped,started)) = true . -- case (C)

  eq isForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = true . -- Case (A)
  eq isForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = true . -- Case (A)
  eq isFForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired, wired)) = true . -- case (B)
  eq isFForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired, wired)) = true . -- case (B)

  var SCO0 : SetOfComponent
  var SIM0 : SetOfImport

  eq tdis(cmp(IDCO,started,started,stopped)) = 2 .
  eq tdis(cmp(IDCO,started,stopped,stopped)) = 1 .
  eq tdis(cmp(IDCO,stopped,stopped,stopped)) = 0 .
  eq tdis(cmp(IDCO,stopped,started,stopped)) = 100 . -- do not happen
  eq tdis(cmp(IDCO,stopped,stopped,started)) = 2 .
  eq tdis(cmp(IDCO,stopped,started,started)) = 1 .
  eq tdis(cmp(IDCO,started,started,started)) = 0 .
  eq tdis(cmp(IDCO,started,stopped,started)) = 0 .

  eq tdis(empCO,SCO0,SIM0) = 0 .
  eq tdis((CO SCO),SCO0,SIM0) = tdis(CO,SCO0,SIM0) + tdis(SCO,SCO0,SIM0) .

  eq tdis(cmp(IDCO,CSCO,NSCO,TSCO),SCO0,SIM0)
    = tdis(cmp(IDCO,CSCO,NSCO,TSCO)) + tdis(getIMsOfECO(SIM0,IDCO),SCO0,SIM0) .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unwired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unwired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unwired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,  wired)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,  wired)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,  wired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,  wired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,  wired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,  wired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,  wired)) = 0 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unused)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unused)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unused)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unused)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unused)) = 100 .

  eq tdis(empIM,SCO0,SIM0) = 0 .
  eq tdis((IM SIM),SCO0,SIM0) = tdis(IM,SCO0,SIM0) + tdis(SIM,SCO0,SIM0) .

  ceq tdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM),SCO0,SIM0) 
    = tdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) 
    + fdis(getComponent(SCO0,IIDCO),SCO0,SIM0)
  if isForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) .

  ceq tdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM),SCO0,SIM0) 
    = tdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) 
  if not (isForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) == true) .

  ceq fdis(cmp(IDCO,CSCO,NSCO,TSCO)) = 0
    if not (CSCO = started) or not (TSCO = started) .
  eq fdis(cmp(IDCO,started,started,started)) = 4 .
  eq fdis(cmp(IDCO,started,stopped,started)) = 3 .

  ceq fdis(cmp(IDCO,CSCO,NSCO,TSCO),SCO0,SIM0) 
     = fdis(cmp(IDCO,CSCO,NSCO,TSCO)) 
     + fdis(getIMsOfECOInTargetStates(SIM0,IDCO,wired),SCO0,SIM0)
  if isFForced(cmp(IDCO,CSCO,NSCO,TSCO)) .

  ceq fdis(cmp(IDCO,CSCO,NSCO,TSCO),SCO0,SIM0) 
     = fdis(cmp(IDCO,CSCO,NSCO,TSCO)) 
  if not (isFForced(cmp(IDCO,CSCO,NSCO,TSCO)) == true) .

  ceq fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM))
     = 0 if not (CSIM == wired) or not (TSIM in (wired unused)) .

  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,wired)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,wired)) = 3 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .

  eq fdis(empIM,SCO0,SIM0) = 0 .
  eq fdis((IM SIM),SCO0,SIM0) = fdis(IM,SCO0,SIM0) + fdis(SIM,SCO0,SIM0) .

  ceq fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM),SCO0,SIM0) 
    = fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) 
    + fdis(getComponent(SCO0,IIDCO),SCO0,SIM0)
  if isForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) 
  or isFForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) .

  ceq fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM),SCO0,SIM0) 
    = fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) 
  if not (isForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) == true)
  and not (isFForced(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM)) == true) .

  eq m(< SCO,SIM,L >)
    = tdis(SCO, SCO, SIM) .
  eq mlog(SCO, SIM)
    = tdis(SCO, SCO, SIM) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-uniqCO(S) .
  ceq wfs(S) = false if not wfs-uniqIM(S) .
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq wfs(S) = false if not wfs-validCurrent(S) .
  ceq inv(S) = false if not wfs(S) .

  -- inv-*:
--  ceq inv(S) = false if not inv-ifCOStartedThenIMReady(S) .
--  ceq inv(S) = false if not noCOCycle(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COID
  ops idIM idIM' : -> IMID
  ops sCO sCO' : -> SetOfComponent
  ops sIM sIM' : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  op x : -> Component

  ops lg lg' : -> ListOfLog

  -- idCO1 is a COID different from idCO.
  op idCO1 : -> COID
  eq (idCO1 = idCO) = false .

  op cCOs1 : -> COState
  eq (cCOs = cCOs1) = false .

  op tCOs1 : -> COState
  eq (tCOs = tCOs1) = false .

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe
