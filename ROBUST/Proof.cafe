require DomainModel DomainModel.cafe
provide Proof

module ProofBase {
  protecting(STATERules)

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  var SCO : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  var SIM : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

--  pred inv-ifCOStartedThenIMReady : State
--  eq inv-ifCOStartedThenIMReady(< SCO,SIM,L >)
--     = ifCOInStatesThenIMInStates(SCO,started,SIM,ready) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Next Distance
  op ndis : Component State -> Nat
  op ndis : Import State -> Nat
  -- Total Next Distance
  op tndis : SetOfComponent SetOfCOState State -> Nat
  op tndis : SetOfImport SetOfIMState State -> Nat

  -- When CSCO is already NSCO
  eq ndis(cmp(IDCO,NSCO,NSCO,TSCO),S) = 0 .

  -- When a rule changing (CSCO,NSCO,TSCO) to (NSCO,NSCO,TSCO) is applied
  -- RD-start: (stopped,started) to (started,started)
  eq ndis(cmp(IDCO,stopped,started,TSCO),< SCO, SIM, L >) 
     = 1
     + tndis(getIMsOfTypeOfICO(SIM,mandatory,IDCO),(wired unused),< SCO, SIM, L >)
     + tndis(getECOsOfIMs(SCO,getIMsOfICOInStates(SIM,IDCO,wired)),started,< SCO, SIM, L >) .

  -- RD-stop: (started,stopped) to (stopped,stopped)
  eq ndis(cmp(IDCO, started, stopped, TSCO),< SCO, SIM, L >) 
     = 1
     + tndis(getICOsOfIMs(SCO,getIMsOfECOInStates(SIM,IDCO,wired)),stopped,< SCO, SIM, L >) .

  -- RD-wire1: (unwired,wired) to (wired,wired)
  eq ndis(imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired),
	  < (cmp(IIDCO, CSCO, NSCO, TSCO) SCO), SIM, L >)
     = 1 
     + tdis(cmp(IIDCO,CSCO,NSCO,stopped),< SCO, SIM, L >) .

  -- RD-wire2: (unwired,wired) to (wired,wired)
  eq ndis(imp(TIM, IDIM, IIDCO, EIDCO, unwired, wired, wired),
	  < (cmp(EIDCO, CSCO, NSCO, TSCO) SCO), SIM, L >)
     = 1 
     + tdis(cmp(EIDCO,CSCO,NSCO,started),< SCO, SIM, L >) .

  -- RD-unwire1: (wired,unwired) to (unwired,unwired)
  ceq ndis(imp(optional, IDIM, IDCO, EIDCO, wired, unwired, TSIM),
	  < (cmp(IDCO, CSCO, CSCO, TSCO) SCO), SIM, L >)
     = 1 
     if not (CSCO = failed) .

  -- RD-unwire2: (wired,unwired) to (unwired,unwired)
  eq ndis(imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM),
	  < (cmp(IDCO, CSCO, NSCO, TSCO) SCO), SIM, L >)
     = 1 
     + tdis(cmp(IDCO,CSCO,NSCO,stopped),< SCO, SIM, L >) .

  -- RD-unwire3: (unused,unwired) to (unwired,unwired)
  eq ndis(imp(TIM, IDIM, IIDCO, EIDCO,  unused, unwired, TSIM),< SCO, SIM, L >)
     = 1 .

  -- RD-remove: (unwired,unused) to (unused,unsued)
  eq ndis(imp(TIM, IDIM, IIDCO, EIDCO, unwired, unused, unused),< SCO, SIM, L >)
     = 1 .

  -- There is no rule which changes
  -- (unused,wired) to (wired,wired)
  -- (wired,unused) to (unused,unsued)

  -- When CSIM is already NSIM
  eq ndis(imp(TIM,IDIM,IIDCO,IDCO,NSIM,NSIM,TSIM),S) = 0 .

  -- Target Distance
  op tdis : Component State -> Nat
  op tdis : Import State -> Nat
-- tdis(TS,TS,TS) = 0 .
-- tdis(CS,CS,TS)
--   = ndis(CS,CS,TS) + tdis(CS,NS,TS) . for some NS.
-- tdis(CS,TS,TS)
--   = ndis(CS,TS,TS) .
-- tdis(CS,NS,CS)
--   = ndis(CS,NS',TS) + tdis(NS',NS,TS) . for some NS'
-- tdis(CS,NS,TS)
--   = ndis(CS,NS,TS) + tdis(NS,NS',TS) . for some NS'.

  -- tdis(TS,TS,TS) = 0 .
  eq tdis(cmp(IDCO,TSCO,TSCO,TSCO),S)
    = 0 .

  -- tdis(CS,CS,TS)
  --   = ndis(CS,CS,TS) + tdis(CS,NS,TS) . for some NS.
  -- RS-stop1: started,started,stopped -> started,stopped,stopped
  -- RS-start1: stopped,stopped,started -> stopped,started,started
  ceq tdis(cmp(IDCO,CSCO,CSCO,TSCO),S)
    = ndis(cmp(IDCO,CSCO,TSCO,TSCO),S) 
    + tdis(cmp(IDCO,CSCO,TSCO,TSCO),S)
    if not (CSCO = TSCO) .

  -- When the component should transit to the target.
  ceq tdis(cmp(IDCO,CSCO,TSCO,TSCO),S)
    = ndis(cmp(IDCO,CSCO,TSCO,TSCO),S) 
    if not (CSCO = TSCO) .

  -- When the component should temporally transit.
  eq tdis(cmp(IDCO,started,stopped,started),S)
    = ndis(cmp(IDCO,started,stopped,started),S) 
    + tdis(cmp(IDCO,stopped,stopped,started),S) .


  -- When already reached to the target state.
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,TSIM,TSIM,TSIM),S)
    = 0 .

  -- When NSIM should be set as TSIM.
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,wired,  wired,unwired),S)
    = ndis(imp(TIM,IDIM,IIDCO,IDCO,wired,unwired,unwired),S) 
    + tdis(imp(TIM,IDIM,IIDCO,IDCO,wired,unwired,unwired),S) .

  -- When the import should transit to the target.
  ceq tdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM,TSIM),S)
    = ndis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,TSIM,TSIM),S) 
    if not (CSIM = TSIM) .

  -- When the component should temporally transit.

  -- Total Target Distance
  op ttdis : SetOfComponent State -> Nat
  op ttdis : SetOfImport State -> Nat
  eq ttdis(empCO,S) = 0 .
  eq ttdis((CO SCO),S) = tdis(CO,S) + ttdis(SCO,S) .
  eq ttdis(empIM,S) = 0 .
  eq ttdis((IM SIM),S) = tdis(IM,S) + ttdis(SIM,S) .
  op m : State -> Nat
  eq m(< SCO,SIM,L >)
    = ttdis(SCO, < SCO,SIM,L >) + ttdis(SIM, < SCO,SIM,L >) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq inv(S) = false if not wfs(S) .

  -- inv-*:
--  ceq inv(S) = false if not inv-ifCOStartedThenIMReady(S) .
--  ceq inv(S) = false if not noCOCycle(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COID
  ops idIM idIM' : -> IMID
  ops sCO sCO' : -> SetOfComponent
  ops sIM sIM' : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  op x : -> Component

  ops lg lg' : -> ListOfLog

  -- idCO1 is a COID different from idCO.
  op idCO1 : -> COID
  eq (idCO1 = idCO) = false .

  op cCOs1 : -> COState
  eq (cCOs = cCOs1) = false .

  op tCOs1 : -> COState
  eq (tCOs = tCOs1) = false .

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe
