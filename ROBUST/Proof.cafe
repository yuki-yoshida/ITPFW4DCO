require DomainModel DomainModel.cafe
require BAG ../lib/BAG.cafe
provide Proof

module! CMPIMPID {
  protecting(LINKS)
  [CIID]
  op cid : COID -> CIID {constr}
  op iid : IMID -> CIID {constr}

  vars IDCO IDCO' : COID
  vars IDIM IDIM' : IMID
  eq (cid(IDCO) = iid(IDIM)) = false .
  eq (cid(IDCO) = cid(IDCO'))
    = (IDCO = IDCO').
  eq (iid(IDIM) = iid(IDIM'))
    = (IDIM = IDIM').
}

module ProofBase {
  protecting(STATERules)
  including(BAG(CMPIMPID {sort Elt -> CIID})
      * {sort Bag -> BagOfID,
	 op empty -> empID})

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  vars SCO SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  vars SIM SIM0 SIM' : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

  pred iidCOeidCODiffer : SetOfImport
  eq iidCOeidCODiffer(empIM) = true .
  eq iidCOeidCODiffer(IM SIM)
    = not (importer(IM) = exporter(IM)) and iidCOeidCODiffer(SIM) .

  pred wfs-iidCOeidCODiffer : State
  eq wfs-iidCOeidCODiffer(< SCO,SIM,L >)
    = iidCOeidCODiffer(SIM) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Target Distance
  op tdis : SetOfComponent -> Nat
  op tdis : SetOfImport    -> Nat

  eq tdis(empCO) = 0 .
  eq tdis((CO SCO)) = tdis(CO) + tdis(SCO) .

  eq tdis(cmp(IDCO, started, started, stopped)) = 2 .
  eq tdis(cmp(IDCO, started, stopped, stopped)) = 1 .
  eq tdis(cmp(IDCO, stopped, stopped, stopped)) = 0 .

  eq tdis(cmp(IDCO, started, started,sstarted)) = 5 .
  eq tdis(cmp(IDCO, started, stopped,sstarted)) = 4 .
  eq tdis(cmp(IDCO, stopped, stopped,sstarted)) = 3 .
  eq tdis(cmp(IDCO, stopped,sstarted,sstarted)) = 2 .
  eq tdis(cmp(IDCO, started,sstarted,sstarted)) = 1 .
  eq tdis(cmp(IDCO,sstarted,sstarted,sstarted)) = 0 .

  eq tdis(empIM) = 0 .
  eq tdis((IM SIM)) = tdis(IM) + tdis(SIM) .

  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,  wired,unwired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,unwired,unwired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired,unwired)) = 0 .

  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,  wired, unused)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired, unused, unused)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO, unused, unused, unused)) = 0 .

  -- following states never occur.
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,unwired, unused)) = 14 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired, unused)) = 13 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,unwired, unused, unused)) = 12 .

  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO, unused, unused, swired)) = 5 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO, unused,unwired, swired)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,unwired,unwired, swired)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,unwired, swired, swired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired, swired, swired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO, swired, swired, swired)) = 0 .

  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,  wired, swired)) = 5 .
  eq tdis(imp(TIM,IDIM,IIDCO,EIDCO,  wired,unwired, swired)) = 4 .

  eq m(< SCO,SIM,L >)
    = tdis(SCO) + tdis(SIM) .
  eq mlog(SCO, SIM)
    = tdis(SCO) + tdis(SIM) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-uniqCO(S) .
  ceq wfs(S) = false if not wfs-uniqIM(S) .
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq wfs(S) = false if not wfs-validCurrent(S) .
  ceq wfs(S) = false if not wfs-iidCOeidCODiffer(S) .

  -- inv-*:
  ceq inv(S) = false if not wfs(S) .
  ceq inv(S) = false if not noCOCycle(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COIDLt
  ops idIM idIM' : -> IMIDLt
  ops sCO sCO' sCO'' sCO0 sCO0' : -> SetOfComponent
  ops sIM sIM' sIM'' sIM0 sIM0' : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  ops co co' co0 co1 : -> Component
  ops im im' im0 im1 : -> Import

  ops lg lg' : -> ListOfLog

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe

