require DomainModel DomainModel.cafe
provide Proof

module ProofBase {
  protecting(STATERules)

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  var SCO : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  var SIM : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

--  pred inv-ifCOStartedThenIMReady : State
--  eq inv-ifCOStartedThenIMReady(< SCO,SIM,L >)
--     = ifCOInStatesThenIMInStates(SCO,started,SIM,ready) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Target Distance
  op tdis : SetOfComponent State -> Nat
  op tdis : SetOfImport State -> Nat

  -- Forced Distance
  -- Forced to become stopped temporally
  op fdis : SetOfComponent State -> Nat
  -- Forced to become unwired temporally
  op fdis : SetOfImport State -> Nat

  eq tdis(empCO,S) = 0 .
  eq tdis((CO SCO),S) = tdis(CO,S) + tdis(SCO,S) .
  eq tdis(empIM,S) = 0 .
  eq tdis((IM SIM),S) = tdis(IM,S) + tdis(SIM,S) .
  eq fdis(empCO,S) = 0 .
  eq fdis((CO SCO),S) = fdis(CO,S) + fdis(SCO,S) .
  eq fdis(empIM,S) = 0 .
  eq fdis((IM SIM),S) = fdis(IM,S) + fdis(SIM,S) .

  eq tdis(cmp(IDCO,TSCO,TSCO,TSCO),S) = 0 .
  eq tdis(cmp(IDCO,started,started,stopped),S) = 2 .
  eq tdis(cmp(IDCO,started,stopped,stopped),S) = 1 .
  eq tdis(cmp(IDCO,stopped,stopped,started),S) = 2 .
  eq tdis(cmp(IDCO,stopped,started,started),S) = 1 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,TSIM,TSIM,TSIM),S) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,wired,  wired,unwired),S) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,wired,unwired,unwired),S) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,wired),S) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,wired),S) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,wired),S) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,wired),S) = 1 .

  eq tdis(imp(optional,IDIM,IIDCO,IDCO,  wired,  wired,unused),S) = 4 .
  eq tdis(imp(optional,IDIM,IIDCO,IDCO,  wired,unwired,unused),S) = 3 .
  eq tdis(imp(optional,IDIM,IIDCO,IDCO,unwired,unwired,unused),S) = 2 .
  eq tdis(imp(optional,IDIM,IIDCO,IDCO,unwired, unused,unused),S) = 1 .

  -- When a mandatory Import is unwired, the Component which wires it should be stopped.
  eq tdis(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired,unused),< SCO,SIM,L >) 
     = 4 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq tdis(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired,unused),< SCO,SIM,L >) 
     = 3 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq tdis(imp(mandatory,IDIM,IIDCO,IDCO,unwired,unwired,unused),S) = 2 .
  eq tdis(imp(mandatory,IDIM,IIDCO,IDCO,unwired, unused,unused),S) = 1 .

  -- When a Component is stopped, any Import wiring to it should be unwired.
  eq fdis(cmp(IDCO,started,started,started),< SCO,SIM,L >) 
     = 4 + fdis(getIMsOfECOInStates(SIM,IDCO,wired),< SCO,SIM,L >) .
  eq fdis(cmp(IDCO,started,stopped,started),< SCO,SIM,L >) 
     = 3 + fdis(getIMsOfECOInStates(SIM,IDCO,wired),< SCO,SIM,L >) .
  ceq fdis(cmp(IDCO,CSCO,NSCO,TSCO),S) = 0
    if not (NSCO = started) or not (TSCO = started) .

  -- When a mandatory Import is unwired, the Component which wires it should be stopped.
  eq fdis(imp(mandatory,IDIM,IIDCO,IDCO,wired,  wired,wired),< SCO,SIM,L >) 
     = 4 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq fdis(imp(mandatory,IDIM,IIDCO,IDCO,wired,unwired,wired),< SCO,SIM,L >) 
     = 3 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq fdis(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired,unused),< SCO,SIM,L >) 
     = 4 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq fdis(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired,unused),< SCO,SIM,L >) 
     = 3 + fdis(getComponent(SCO,IIDCO),< SCO,SIM,L >) .
  eq fdis(imp(mandatory,IDIM,IIDCO,IDCO,wired,NSIM,unwired),S) = 0 .
  eq fdis(imp(optional,IDIM,IIDCO,IDCO,wired,NSIM,TSIM),S) = 0 .

  op m : State -> Nat
  eq m(< SCO,SIM,L >)
    = tdis(SCO, < SCO,SIM,L >) + tdis(SIM, < SCO,SIM,L >) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-uniqCO(S) .
  ceq wfs(S) = false if not wfs-uniqIM(S) .
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq wfs(S) = false if not wfs-validCurrent(S) .
  ceq inv(S) = false if not wfs(S) .

  -- inv-*:
--  ceq inv(S) = false if not inv-ifCOStartedThenIMReady(S) .
--  ceq inv(S) = false if not noCOCycle(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COID
  ops idIM idIM' : -> IMID
  ops sCO sCO' : -> SetOfComponent
  ops sIM sIM' : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  op x : -> Component

  ops lg lg' : -> ListOfLog

  -- idCO1 is a COID different from idCO.
  op idCO1 : -> COID
  eq (idCO1 = idCO) = false .

  op cCOs1 : -> COState
  eq (cCOs = cCOs1) = false .

  op tCOs1 : -> COState
  eq (tCOs = tCOs1) = false .

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe
