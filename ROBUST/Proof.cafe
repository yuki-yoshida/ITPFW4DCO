require DomainModel DomainModel.cafe
require BAG ../lib/BAG.cafe
provide Proof

module! CMPIMPID {
  protecting(LINKS)
  [CID IID < CIID]
  op cid : COID -> CID {constr}
  op iid : IMID -> IID {constr}
}

module ProofBase {
  protecting(STATERules)
  including(BAG(CMPIMPID {sort Elt -> CIID})
      * {sort Bag -> BagOfID,
	 op empty -> empID})

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  vars SCO SCO0 : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  vars SIM SIM0 SIM' : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  var BG : BagOfID

  -- isForced(IM) means that IM is forced to be unwired temporally.
  -- isForced0(IM) means that IM is Forced but keeps stable.
  -- isForced1(IM) means that IM is Forced and is not already stable.
  pred isForced : Import
  pred isForced0 : Import
  pred isForced1 : Import

  -- isFForced(IM) means that IM may be Forced because its exporter is FForced.
  -- isFForced0(IM) means that IM is FForced but keeps stable.
  -- isFForced1(IM) means that IM is FForced and is not yet stable.
  pred isFForced : Import
  pred isFForced0 : Import
  pred isFForced1 : Import

  -- isFForced(CO) means that CO may be forced to be stopped temporally
  --               because an IM importing the CO is Forced or FForced.
  -- isFForced0(CO) means that CO is FForced but keeps stable.
  -- isFForced1(CO) means that CO is FForced and is not yet stable.
  pred isFForced : Component
  pred isFForced0 : Component
  pred isFForced1 : Component

  -- eq isForced0(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = true . -- Case (A)
  eq isForced0(IM) =
    (type(IM)   = mandatory) and
    (state(IM)  = wired) and
    (next(IM)   = wired) and
    (target(IM) = unused) .
  -- eq isForced1(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = true . -- Case (A)
  eq isForced1(IM) =
    (type(IM)   = mandatory) and
    (state(IM)  = wired) and
    (next(IM)   = unwired) and
    (target(IM) = unused) .
  eq isForced(IM) = isForced0(IM) or isForced1(IM) .

  -- eq isFForced0(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired, wired)) = true . -- case (B)
  eq isFForced0(IM) =
    (type(IM)   = mandatory) and
    (state(IM)  = wired) and
    (next(IM)   = wired) and
    (target(IM) = wired) .
  -- eq isFForced1(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired, wired)) = true . -- case (B)
  eq isFForced1(IM) =
    (type(IM)   = mandatory) and
    (state(IM)  = wired) and
    (next(IM)   = unwired) and
    (target(IM) = wired) .
  eq isFForced(IM) = isForced(IM) or isFForced0(IM) or isFForced1(IM) .

  -- eq isFForced0(cmp(IDCO,started,started,started)) = true . -- case (C)
  eq isFForced0(CO) =
    (state(CO)  = started) and
    (next(CO)   = started) and
    (target(CO) = started) .
  -- eq isFForced1(cmp(IDCO,started,stopped,started)) = true . -- case (C)
  eq isFForced1(CO) =
    (state(CO)  = started) and
    (next(CO)   = stopped) and
    (target(CO) = started) .
  eq isFForced(CO) = isFForced0(CO) or isFForced1(CO) .

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

  pred iidCOeidCODiffer : SetOfImport
  eq iidCOeidCODiffer(empIM) = true .
  eq iidCOeidCODiffer(IM SIM)
    = not (importer(IM) = exporter(IM)) and iidCOeidCODiffer(SIM) .

  pred wfs-iidCOeidCODiffer : State
  eq wfs-iidCOeidCODiffer(< SCO,SIM,L >)
    = iidCOeidCODiffer(SIM) .

  pred allFFIMHasFFECO : SetOfImport SetOfComponent
  eq allFFIMHasFFECO(empIM, SCO) = true .
  eq allFFIMHasFFECO(IM SIM,SCO)
    = (isFForced1(IM) implies isFForced1(getComponent(SCO,exporter(IM)))) and
      allFFIMHasFFECO(SIM,SCO) .

  pred inv-allFFIMHasFFECO : State
  eq inv-allFFIMHasFFECO(< SCO,SIM,L >)
    = allFFIMHasFFECO(SIM,SCO) .

  pred existFFIM : SetOfImport
  eq existFFIM(IM SIM)
    = isFForced1(IM) or isForced1(IM) or existFFIM(SIM) .

  pred allFFCOHasFFIIM : SetOfComponent SetOfImport
  eq allFFCOHasFFIIM(empCO,SIM) = true .
  eq allFFCOHasFFIIM(CO SCO,SIM)
    = (isFForced1(CO) implies existFFIM(getIMsOfICO(SIM,CO))) and
      allFFCOHasFFIIM(SCO,SIM) .

  pred inv-allFFCOHasFFIIM : State
  eq inv-allFFCOHasFFIIM(< SCO,SIM,L >)
    = allFFCOHasFFIIM(SCO,SIM) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Target Distance
  op tdis : Component -> Nat
  op tdis : Import -> Nat
  op tdis : SetOfComponent SetOfComponent SetOfImport -> Nat
  op tdis : SetOfImport SetOfComponent SetOfImport -> Nat

  -- Forced Distance 
  -- Forced to become stopped temporally
  op fdis : Component -> Nat
  -- Forced to become unwired temporally
  op fdis : Import -> Nat
  op fdis : BagOfID SetOfComponent SetOfImport -> Nat

  eq tdis(cmp(IDCO,started,started,stopped)) = 2 .
  eq tdis(cmp(IDCO,started,stopped,stopped)) = 1 .
  eq tdis(cmp(IDCO,stopped,stopped,stopped)) = 0 .
  eq tdis(cmp(IDCO,stopped,started,stopped)) = 100 . -- do not happen
  eq tdis(cmp(IDCO,stopped,stopped,started)) = 2 .
  eq tdis(cmp(IDCO,stopped,started,started)) = 1 .
  eq tdis(cmp(IDCO,started,started,started)) = 0 .
  eq tdis(cmp(IDCO,started,stopped,started)) = 0 .

  eq tdis(empCO,SCO0,SIM0) = 0 .
  eq tdis((CO SCO),SCO0,SIM0) = tdis(CO) + tdis(SCO,SCO0,SIM0) .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unwired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unwired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unwired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,  wired)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,  wired)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,  wired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,  wired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,  wired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,  wired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,  wired)) = 0 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unused)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unused)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unused)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unused)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unused)) = 100 .

  eq tdis(empIM,SCO0,SIM0) = 0 .
  eq tdis((IM SIM),SCO0,SIM0) = tdis(IM) + tdis(SIM,SCO0,SIM0) .

  ceq fdis(CO) = 0 if not isFForced(CO) .
  eq fdis(cmp(IDCO,started,started,started)) = 4 .
  eq fdis(cmp(IDCO,started,stopped,started)) = 3 .

  ceq fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM))
     = 0 if not (CSIM = wired) or not (TSIM in (wired unused)) .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,wired)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,wired)) = 3 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .

  eq fdis(empID,SCO0,SIM0) = 0 .
  eq fdis((cid(IDCO) BG),SCO0,SIM0)
    = fdis(getComponent(SCO0,IDCO)) + fdis(BG,SCO0,SIM0) .
  eq fdis((iid(IDIM) BG),SCO0,SIM0)
    = fdis(getImport(SIM0,IDIM)) + fdis(BG,SCO0,SIM0) .

  op makeIDBag : SetOfImport SetOfComponent SetOfImport -> BagOfID
  op makeupIDBag : SetOfImport SetOfComponent SetOfImport -> BagOfID
  op makeupIDBag : Component SetOfComponent SetOfImport -> BagOfID

  eq makeIDBag(empIM,SCO0,SIM0) = empID .
  ceq makeIDBag((IM SIM),SCO0,SIM0)
    = makeIDBag(SIM,SCO0,SIM0) 
    if not isForced(IM) .
  ceq makeIDBag((IM SIM),SCO0,SIM0)
    = (makeupIDBag(getComponent(SCO0,importer(IM)),SCO0,SIM0) makeIDBag(SIM,SCO0,SIM0))
    if isForced(IM) .

  eq makeupIDBag(empIM,SCO0,SIM0) = empID .
  ceq makeupIDBag((IM SIM),SCO0,SIM0)
    = (iid(id(IM)) makeupIDBag(SIM,SCO0,SIM0))
    if not isFForced(IM) .
  ceq makeupIDBag((IM SIM),SCO0,SIM0)
    = (iid(id(IM)) makeupIDBag(getComponent(SCO0,importer(IM)),SCO0,SIM0) makeupIDBag(SIM,SCO0,SIM0))
    if isFForced(IM) .

  ceq makeupIDBag(CO,SCO0,SIM0)
    = cid(id(CO))
    if not isFForced(CO) .
  ceq makeupIDBag(CO,SCO0,SIM0)
    = (cid(id(CO)) makeupIDBag(getIMsOfECOInTargetStates(SIM0,CO,wired),SCO0,SIM0))
    if isFForced(CO) .

  eq m(< SCO,SIM,L >)
    = tdis(SCO, SCO, SIM) + tdis(SIM, SCO, SIM) + fdis(makeIDBag(SIM,SCO,SIM), SCO, SIM) .
  eq mlog(SCO, SIM)
    = tdis(SCO, SCO, SIM) + tdis(SIM, SCO, SIM) + fdis(makeIDBag(SIM,SCO,SIM), SCO, SIM) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-uniqCO(S) .
  ceq wfs(S) = false if not wfs-uniqIM(S) .
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq wfs(S) = false if not wfs-validCurrent(S) .
  ceq wfs(S) = false if not wfs-iidCOeidCODiffer(S) .

  -- inv-*:
  ceq inv(S) = false if not wfs(S) .
  ceq inv(S) = false if not noCOCycle(S) .
  ceq inv(S) = false if not inv-allFFCOHasFFIIM(S) .
  ceq inv(S) = false if not inv-allFFIMHasFFECO(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COIDLt
  ops idIM idIM' : -> IMIDLt
  ops sCO sCO' sCO'' sCO0 : -> SetOfComponent
  ops sIM sIM' sIM'' sIM0 : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  ops co co' co0 co1 : -> Component
  ops im im' im0 im1 : -> Import

  ops lg lg' : -> ListOfLog

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe

-- eof
**> Check Start <**
open ProofBase . 

ops COC COC1 COC2 COD : -> COIDLt .
ops IMW IMV IMW1 IMW2 : -> IMIDLt .

op components1 : -> SetOfComponent .
eq components1 =
  (cmp(COC,  started, started, started) 
   cmp(COC1, started, started, started)) .

op imports1 : -> SetOfImport .
eq imports1 =
  (imp(optional, IMW1, COC,  COC1,  wired,  wired, unused)) .

red makeIDBag(imports1,components1,imports1) .
red tdis(components1,components1,imports1) .
red tdis(imports1,components1,imports1) .
red fdis(makeIDBag(imports1,components1,imports1),components1,imports1) .
red m(< components1,imports1,lg >) .

op components2 : -> SetOfComponent .
eq components2 =
  (cmp(COC,  started, started, started) 
   cmp(COC2, started, started, started)) .

op imports2 : -> SetOfImport .
eq imports2 =
  (imp(mandatory, IMW2, COC,  COC2, unused, unused,  wired)) .

red makeIDBag(imports2,components2,imports2) .
red tdis(components2,components2,imports2) .
red tdis(imports2,components2,imports2) .
red fdis(makeIDBag(imports2,components2,imports2),components2,imports2) .
red m(< components2,imports2,lg >) .

op components : -> SetOfComponent .
eq components =
  (cmp(COD,  started, started, started) cmp(COC,  started, started, started) 
   cmp(COC1, started, started, started) cmp(COC2, started, started, started)) .

op imports : -> SetOfImport .
eq imports =
  (imp(mandatory, IMW,  COD,  COC,   wired,  wired,  wired)
   imp(optional,  IMV,  COC1, COC,   wired,  wired,  wired)
   imp(mandatory, IMW1, COC,  COC1,  wired,  wired, unused)
   imp(mandatory, IMW2, COC,  COC2, unused, unused,  wired)) .

red makeIDBag(imports,components,imports) .
red tdis(components,components,imports) .
red tdis(imports,components,imports) .
red fdis(makeIDBag(imports,components,imports),components,imports) .
red m(< components,imports,lg >) .

-- close
