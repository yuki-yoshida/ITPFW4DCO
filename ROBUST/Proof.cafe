require DomainModel DomainModel.cafe
provide Proof

module ProofBase {
  protecting(STATERules)

  op _!_ : Bool Bool -> Bool {constr assoc}
  op _=>_!!_ : State State Bool -> Bool {constr}

  var CO : Component
  var SCO : SetOfComponent
  vars IDCO IIDCO EIDCO : COID 
  vars CSCO NSCO TSCO : COState
  var StCO : SetOfCOState

  var IM : Import
  var SIM : SetOfImport
  var IDIM : IMID
  var TIM : IMType
  vars CSIM NSIM TSIM : IMState
  var StIM : SetOfIMState

  var L : ListOfLog
  vars S SS : State

  -- The invariant should be defined as the conjunction of all inv-* and all wfs-*.
  -- But this definition causes costly computations.

  pred iidCOeidCODiffer : SetOfImport
  eq iidCOeidCODiffer(empIM) = true .
  eq iidCOeidCODiffer(IM SIM)
    = not (importer(IM) = exporter(IM)) and iidCOeidCODiffer(SIM) .
--  eq iidCOeidCODiffer(imp(TIM,IDIM,IIDCO,EIDCO,CSIM,NSIM,TSIM) SIM)
--    = not (IIDCO = EIDCO) and iidCOeidCODiffer(SIM) .

  pred inv-iidCOeidCODiffer : State
  eq inv-iidCOeidCODiffer(< SCO,SIM,L >)
    = iidCOeidCODiffer(SIM) .

--> *************************
--> Step 0-2: Define cont(S).
--> *************************
  pred cont : State
  eq cont(S)
     = (S =(*,1)=>+ SS) .

--> **********************
--> Step 0-3: Define m(S).
--> **********************
  -- Measuring functions
  -- Target Distance
  op tdis : Component -> Nat
  op tdis : Import -> Nat
  op tdis : SetOfComponent SetOfComponent SetOfImport -> Nat
  op tdis : SetOfImport SetOfComponent SetOfImport -> Nat

  -- Forced Distance (the last parameter is a set of visited mandatory imports)
  -- Forced to become stopped temporally
  op fdis : Component -> Nat
  op fdis : Component SetOfComponent SetOfImport -> Nat
  -- Forced to become unwired temporally
  op fdis : Import -> Nat
  op fdis : SetOfImport SetOfComponent SetOfImport -> Nat

  pred isFForced : Component
  pred isFForced : Import
  pred isForced : Import

  eq isForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = true . -- Case (A)
  eq isForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = true . -- Case (A)
  ceq isForced(IM) = false
    if (type(IM) = optional) or 
       (state(IM) in (unwired unused)) or
       (next(IM) = unused) or
       (target(IM) in (wired unwired)) .

  eq isFForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,  wired, wired)) = true . -- case (B)
  eq isFForced(imp(mandatory,IDIM,IIDCO,IDCO,  wired,unwired, wired)) = true . -- case (B)
  ceq isFForced(IM) = true if isForced(IM) .
  ceq isFForced(IM) = false
    if (type(IM) = optional) or 
       (state(IM) in (unwired unused)) or
       (next(IM) = unused) or
       (target(IM) = unwired) .

  eq isFForced(cmp(IDCO,started,started,started)) = true . -- case (C)
  eq isFForced(cmp(IDCO,started,stopped,started)) = true . -- case (C)
  ceq isFForced(CO) = false
    if (state(CO) = stopped) or (target(CO) = stopped) .

  var SCO0 : SetOfComponent
  var SIM0 : SetOfImport
  var SIM' : SetOfImport

  eq tdis(cmp(IDCO,started,started,stopped)) = 2 .
  eq tdis(cmp(IDCO,started,stopped,stopped)) = 1 .
  eq tdis(cmp(IDCO,stopped,stopped,stopped)) = 0 .
  eq tdis(cmp(IDCO,stopped,started,stopped)) = 100 . -- do not happen
  eq tdis(cmp(IDCO,stopped,stopped,started)) = 2 .
  eq tdis(cmp(IDCO,stopped,started,started)) = 1 .
  eq tdis(cmp(IDCO,started,started,started)) = 0 .
  eq tdis(cmp(IDCO,started,stopped,started)) = 0 .

  eq tdis(empCO,SCO0,SIM0) = 0 .
  eq tdis((CO SCO),SCO0,SIM0) = tdis(CO,SCO0,SIM0) + tdis(SCO,SCO0,SIM0) .

  eq tdis(CO,SCO0,SIM0)
    = tdis(CO) + tdis(getIMsOfECO(SIM0,id(CO)),SCO0,SIM0) .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unwired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unwired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unwired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unwired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unwired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,  wired)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,  wired)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,  wired)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,  wired)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,  wired)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,  wired)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,  wired)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,  wired)) = 0 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,  wired, unused,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,  wired,unused)) = 100 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,  wired,unused)) = 100 .

  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired,unwired,unused)) = 2 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO,unwired, unused,unused)) = 1 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused, unused,unused)) = 0 .
  eq tdis(imp(TIM,IDIM,IIDCO,IDCO, unused,unwired,unused)) = 100 .

  eq tdis(empIM,SCO0,SIM0) = 0 .
  eq tdis((IM SIM),SCO0,SIM0) = tdis(IM,SCO0,SIM0) + tdis(SIM,SCO0,SIM0) .

  eq tdis(IM,SCO0,SIM0) 
    = tdis(IM) +
      if isForced(IM) then
	fdis(getComponent(SCO0,importer(IM)),SCO0,SIM0)
      else 0 fi .

  ceq fdis(CO) = 0 if not isFForced(CO) .
  eq fdis(cmp(IDCO,started,started,started)) = 4 .
  eq fdis(cmp(IDCO,started,stopped,started)) = 3 .

  eq fdis(CO,SCO0,SIM0) 
     = fdis(CO) +
       if isFForced(CO) then
         fdis(getIMsOfECOInTargetStates(SIM0,id(CO),wired),SCO0,SIM0)
       else 0 fi .

  ceq fdis(imp(TIM,IDIM,IIDCO,IDCO,CSIM,NSIM,TSIM))
     = 0 if not (CSIM = wired) or not (TSIM in (wired unused)) .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,wired)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,wired)) = 3 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,  wired,unused)) = 4 .
  eq fdis(imp(TIM,IDIM,IIDCO,IDCO,  wired,unwired,unused)) = 3 .

  eq fdis(empIM,SCO0,SIM0) = 0 .
  eq fdis((IM SIM),SCO0,SIM0) = fdis(IM,SCO0,SIM0) + fdis(SIM,SCO0,SIM0) .

  eq fdis(IM,SCO0,SIM0) 
    = fdis(IM) +
      if isFForced(IM) then
        fdis(getComponent(SCO0,importer(IM)),SCO0,SIM0)
      else 0 fi .

  eq m(< SCO,SIM,L >)
    = tdis(SCO, SCO, SIM) .
  eq mlog(SCO, SIM)
    = tdis(SCO, SCO, SIM) .

--> ************************
--> Step 0-4: Define inv(S).
--> ************************
  -- wfs-*:
  ceq wfs(S) = false if not wfs-uniqCO(S) .
  ceq wfs(S) = false if not wfs-uniqIM(S) .
  ceq wfs(S) = false if not wfs-allIMHaveICO(S) .
  ceq wfs(S) = false if not wfs-allIMHaveECO(S) .
  ceq wfs(S) = false if not wfs-validTarget(S) .
  ceq wfs(S) = false if not wfs-validCurrent(S) .
  ceq inv(S) = false if not wfs(S) .

  -- inv-*:
  ceq inv(S) = false if not inv-iidCOeidCODiffer(S) .
  ceq inv(S) = false if not noCOCycle(S) .

--> **************************************
--> Step 0-5: Prepare arbitrary constants.
--> **************************************
  ops idCO idCO' iidCO eidCO : -> COID
  ops idIM idIM' : -> IMID
  ops sCO sCO' sCO0 : -> SetOfComponent
  ops sIM sIM' sIM0 : -> SetOfImport
  ops tIM tIM' : -> IMType
  ops cCOs cCOs' nCOs nCOs' tCOs tCOs' : -> COState
  ops cIMs cIMs' nIMs nIMs' tIMs tIMs' : -> IMState
  op sCOs : -> SetOfCOState
  op sIMs : -> SetOfIMState
  ops co co' co0 co1 : -> Component
  ops im im' im0 im1 : -> Import

  ops lg lg' : -> ListOfLog

  -- idCO1 is a COID different from idCO.
  op idCO1 : -> COID
  eq (idCO1 = idCO) = false .

  op cCOs1 : -> COState
  eq (cCOs = cCOs1) = false .

  op tCOs1 : -> COState
  eq (tCOs = tCOs1) = false .

}

-- *************************************************************************
-- (1) init(S) implies cont(S).
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- *************************************************************************

-- ****************************
-- (1) init(S) implies cont(S).
-- ****************************
-- in Proof-initcont.cafe

-- **********************************************************
-- (2) inv(S) and not final(S) implies cont(SS) or final(SS).
-- **********************************************************
-- in Proof-contcont.cafe

-- *************************************************************************
-- (3) inv(S) and not final(S) implies measure(S) > measure(SS).
-- *************************************************************************
-- in Proof-measure.cafe

-- ***************************
-- (4) init(S) implies inv(S).
-- (5) inv(S) implies inv(SS).
-- ***************************
-- in Proof-inv.cafe
