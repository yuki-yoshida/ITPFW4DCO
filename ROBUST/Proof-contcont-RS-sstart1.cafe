require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> ************************************************************************************
--> trans [RS-sstart1]:
-->    < (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM,
-->      ListLG >
--> => < (cmp(IDCO, stopped, sstarted, sstarted) SCO), SIM,
-->      (clog("RS-sstart1:Should Stably Start", cmp(IDCO, stopped, sstarted, sstarted),
-->         mlog(
-->      (cmp(IDCO, stopped,  stopped, sstarted) SCO), SIM
-->        )) ListLG) > .
--> ************************************************************************************

open ProofContCont .

  var CO : Component
  var SCO : SetOfComponent
  var SIM : SetOfImport
  var L : ListOfLog

  -- eq robust-lemmaC04(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(stopped,sstarted,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(stopped,sstarted,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

--> *************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< (cmp(idCO, stopped,  stopped, sstarted) sCO), sIM, lg >) = true .
}
:apply (rd-)
--> Proof of (2) inv(S) and not final(S) and inv(SS) implies cont(SS) or final(SS).
-->   for Rule RS-sstart1 done
-->
show proof
close

--> Totally 1 goal should be proved.
