require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> **************************************************************************
-->  trans [RS-stop2]:
-->     < (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->        ListLG >
-->  => < (cmp(IDCO, started, stopped, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM),
-->       (clog("RS-stop2:Should Stop", cmp(IDCO, started, stopped, sstarted),
-->	  mlog(
-->       (cmp(IDCO, started, started, sstarted) SCO),
-->       (imp(mandatory, IDIM, IDCO, EIDCO, wired, unwired, TSIM) SIM)
-->	 )) ListLG) > .
--> **************************************************************************

open ProofContCont .

  var CO : Component
  var SCO : SetOfComponent
  var SIM : SetOfImport
  var L : ListOfLog

  -- eq robust-lemmaC02(CO,SCO,SIM,L)
  --   = cont(< (CO SCO), SIM, L >) 
  --     when inv(< (CO SCO), SIM, L >) and
  --          inStates(CO,st(started,stopped,sstarted)) .
  ceq inv(< (CO SCO), SIM, L >) = false 
    if inStates(CO,st(started,stopped,sstarted)) and
       cont(< (CO SCO), SIM, L >) = false .

--> *************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< (cmp(idCO, started, started, sstarted) sCO), 
                (imp(mandatory, idIM, idCO, eidCO, wired, unwired, tIMs) sIM),
                lg >) = true .
}
:apply (rd-)
--> Proof of (2) inv(S) and not final(S) and inv(SS) implies cont(SS) or final(SS).
-->   for Rule RS-stop2 done
-->
show proof
close

--> Totally 1 goal should be proved.
