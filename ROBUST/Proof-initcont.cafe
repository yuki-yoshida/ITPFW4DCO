require Proof Proof.cafe

--> ****************************
--> (1) init(S) implies cont(S).
--> ****************************

--> ******************************************
--> Step 1-0: Define a predicate to be proved.
--> ******************************************
module ProofInitCont {
  protecting(ProofBase)

  var S : State
  pred initcont : State .
  eq initcont(S) = init(S) implies cont(S) .
}

-- Proof of (1) init(S) implies cont(S).
select ProofInitCont .

--> *******************************************
--> Step 1-1: Begin with the most general case. 
--> *******************************************
:goal {eq initcont(< sCO, sIM, lg >) = true .}

:def csp1-1final = :csp  { 
  eq final(< sCO, sIM, lg >) = true .
  eq equivCOSet(sCO) = false .
  eq equivIMSet(sIM) = false .
}

:apply (csp1-1final rd-)

-- Case 2:
:set(normalize-init,on)
-- :init eq equivCOSet(sCO) = false .
:init (ceq true = false
	if equivCOSet(SCO:SetOfComponent) . ) by {
  SCO:SetOfComponent <- sCO;
}
:set(normalize-init,off)

:def csp1-1eqc1 = :csp  { 
  eq sCO = empCO .
  eq sCO = (cmp(idCO,cCOs,nCOs,tCOs) sCO') .
}

:apply (csp1-1eqc1 rd-)
-- Case 2-1 is discharged by :init eq equivCOSet(sCO) = false .

:def csp1-1eqc2 = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
}

:def csp1-1eqc3 = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
}

:def csp1-1eqc4 = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
}

:set(normalize-init,on)
-- :init eq (cCOs = tCOs) = false .
--   because equivCOSet(sCO) = false .
:init (ceq true = false
	if CCOS:COState = TCOS:COState . ) by {
  CCOS:COState <- cCOs;
  TCOS:COState <- tCOs;
}
:set(normalize-init,off)

:apply (csp1-1eqc2 csp1-1eqc3 csp1-1eqc4 rd-)
-- When not (cCOs = nCOs), it is discharged by init(S) imples stableCOSet(sCO) . 
-- When (cCOs = tCOs), it is discharged by :init eq (cCOs = tCOs) = false .

-- Case 3:
:set(normalize-init,on)
-- :init eq equivIMSet(sIM) = false .
:init (ceq true = false
	if equivIMSet(SIM:SetOfImport) . ) by {
  SIM:SetOfImport <- sIM;
}
:set(normalize-init,off)

:def csp1-1eqc5 = :csp  { 
  eq sIM = empIM .
  eq sIM = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}

:apply (csp1-1eqc5 rd-)
-- Case 3-1 is discharged by :init eq equivIMSet(sIM) = false .

:def csp1-1eqc6 = :csp  { 
  eq cIMs = unused .
  eq cIMs = unwired .
  eq cIMs = wired .
}

:def csp1-1eqc7 = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
}

:def csp1-1eqc8 = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
}

:set(normalize-init,on)
-- :init eq (cIMs = tIMs) = false .
--   because equivIMSet(sIM) = false .
:init (ceq true = false
	if CIMS:IMState = TIMS:IMState . ) by {
  CIMS:IMState <- cIMs;
  TIMS:IMState <- tIMs;
}
:set(normalize-init,off)

:apply (csp1-1eqc6 csp1-1eqc7 csp1-1eqc8 rd-)
-- When not (cIMs = nIMs), it is discharged by init(S) imples stableIMSet(sIM) . 
-- When (cIMs = tIMs), it is discharged by :init eq (cIMs = tIMs) = false .

show proof

select
