require Proof Proof.cafe

--> ****************************
--> (1) init(S) implies cont(S).
--> ****************************

--> ******************************************
--> Step 1-0: Define a predicate to be proved.
--> ******************************************
module ProofInitCont {
  protecting(ProofBase)

  var S : State
  pred initcont : State .
  eq initcont(S) = init(S) implies cont(S) .
}

-- Proof of (1) init(S) implies cont(S).
select ProofInitCont .

--> *******************************************
--> Step 1-1: Begin with the most general case. 
--> *******************************************
:goal {eq initcont(< sCO, sIM, lg >) = true .}

:def csp1-1final = :csp  { 
  eq final(< sCO, sIM, lg >) = true .
  eq equivCOSet(sCO) = false .
  eq equivIMSet(sIM) = false .
}

:apply (csp1-1final rd-)

-- Case 2:
:set(normalize-init,on)
-- :init eq equivCOSet(sCO) = false .
:init (ceq true = false
	if equivCOSet(SCO:SetOfComponent) . ) by {
  SCO:SetOfComponent <- sCO;
}
:set(normalize-init,off)

:def csp1-1eqc1 = :csp  { 
  eq sCO = empCO .
  eq sCO = (cmp(idCO,cCOs,nCOs,tCOs) sCO') .
}

:apply (csp1-1eqc1 rd-)

:def csp1-1eqc2 = :csp  { 
  eq cCOs = stopped .
  eq cCOs = started .
}

:def csp1-1eqc3 = :csp  { 
  eq nCOs = stopped .
  eq nCOs = started .
}

:def csp1-1eqc4 = :csp  { 
  eq tCOs = stopped .
  eq tCOs = started .
}

:set(normalize-init,on)
-- :init eq (cCOs = tCOs) = false .
:init (ceq true = false
	if CCOS:COState = TCOS:COState . ) by {
  CCOS:COState <- cCOs;
  TCOS:COState <- tCOs;
}
:set(normalize-init,off)

:apply (csp1-1eqc2 csp1-1eqc3 csp1-1eqc4 rd-)

-- Case 3:
:set(normalize-init,on)
-- :init eq equivIMSet(sIM) = false .
:init (ceq true = false
	if equivIMSet(SIM:SetOfImport) . ) by {
  SIM:SetOfImport <- sIM;
}
:set(normalize-init,off)

:def csp1-1eqc5 = :csp  { 
  eq sIM = empIM .
  eq sIM = (imp(tIM,idIM,iidCO,eidCO,cIMs,nIMs,tIMs) sIM') .
}

:apply (csp1-1eqc5 rd-)

:def csp1-1eqc6 = :csp  { 
  eq cIMs = unused .
  eq cIMs = unwired .
  eq cIMs = wired .
}

:def csp1-1eqc7 = :csp  { 
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
}

:def csp1-1eqc8 = :csp  { 
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
}

:set(normalize-init,on)
-- :init eq (cIMs = tIMs) = false .
:init (ceq true = false
	if CIMS:IMState = TIMS:IMState . ) by {
  CIMS:IMState <- cIMs;
  TIMS:IMState <- tIMs;
}
:set(normalize-init,off)
:apply (csp1-1eqc6 csp1-1eqc7 csp1-1eqc8 rd-)

eof

--> *************************************************************************************
--> Step 1-2: Consider which rule can be applied to the global state in the current case. 
--> *************************************************************************************
-- The first rule is R01.
--> **********************************************************************
--> Step 1-3: Split the current case into cases which collectively cover
-->  the current case and one of which matches to LHS of the current rule.
--> **********************************************************************
-- LHS of R01 requires at least one initial resource.
:def csp1-3R01a = :csp  { 
  eq sRS = empRS .
  eq sRS = (res(trs,idRS,srs) sRS') .
}
:def csp1-3R01b = :csp { 
  eq srs = initial .
  eq srs = started .
}
:apply (csp1-3R01a rd- csp1-3R01b rd-)
-- When the resource is initial:
-- Note that res(trs,idRS,initial) is arbitrary selected.
-- Thus, we can assume that all of DDSRS(res(trs,idRS,initial),S) are not initial,
-- which the Cyclic Dependency Lemma assures.
--> *********************************************************
--> Step 1-4: Split the current case into cases where
-->  the condition of the current rule does or does not hold. 
--> *********************************************************
-- The condition of R01 is allPROfRSInStates(sPR,idRS,ready) .
:def csp1-4R01 = :csp { 
  eq allPROfRSInStates(sPR,idRS,ready) = true .
  eq sPR = (prop(tpr,idPR,notready,idRS,idRRS) sPR') .
}
:apply (csp1-4R01 rd-)
-- When there is a not-ready property of the resource:
--> **********************************************************************
--> Step 1-5: When there are two identifier constants of the same sort,
-->  split the current case into cases where they are or are not the same.
--> **********************************************************************
:def ctf1-5idRRS = :ctf {
  eq idRRS = idRS .
}
:apply (ctf1-5idRRS rd-)
--> ***************************************************************
--> Step 1-6: When there is a dangling link, split the current case
-->  into cases where the linked object does or does not exist.
--> ***************************************************************
-- The resource referred by the property does or does not exist.
:def csp1-6a = :csp {
  eq existRS(sRS',idRRS) = false .
  eq sRS' = (res(trs',idRRS,srs') sRS'') .
}
:def csp1-6b = :csp {
  eq srs' = initial .
  eq srs' = started .
}
:apply (csp1-6a rd- csp1-6b rd-)
-- When the resource idRRS is initial:
--> ******************************************************************************
--> Step 1-7: When falling in a cyclic situation, use the Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:set(normalize-init,on)
:init [noCycle] by {
  O:Resource <- res(trs,idRS,initial);
  S:State <- < sRS, sPR >;
  SS:SetOfRSState <- initial;
}
:set(normalize-init,off)
:apply (rd-)
show proof

select
