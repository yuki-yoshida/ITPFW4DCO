require ProofContCont Proof-contcont.cafe

--> **********************************************************
--> (2) inv(S) and not final(S) implies cont(SS) or final(SS).
--> **********************************************************

--> ********************************************
-->  trans [RS-start1]:
-->     < (cmp(IDCO, stopped, stopped, started) SCO), SIM,
-->       ListLG >
-->  => < (cmp(IDCO, stopped, started, started) SCO), SIM,
-->       (clog("RS-start1:Should Start", cmp(IDCO, stopped, started, started)) ListLG) > .
--> ********************************************
select ProofContCont .
--> *************************************************************************
--> Step 2-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq contcont(< (cmp(idCO, stopped, stopped, started) sCO), sIM, lg >) = true .
}
--> ******************************************************
--> Step 2-2: Split the current case for a rule into cases
--> where the condition of the rule does or does not hold.
--> ******************************************************
--> *********************************************************
--> Step 2-3: Split the current case into cases where
-->  predicate final does or does not hold in the next state.
--> *********************************************************
--> ***************************************************************
--> Step 2-4: Consider which rule can be applied to the next state.
--> ***************************************************************
-- The next rule should be RD-start.
--> *************************************************************************************
--> Step 2-5: Split the current case into cases which collectively cover the current case
-->  and the next state of one of the split cases matches to LHS of the current rule.
--> *************************************************************************************
--> The case already matches to LHS of RD-start.
--> ***************************************************************
--> Step 2-6: Split the current case into cases where the condition
-->  of the current rule does or does not hold in the next state.
--> ***************************************************************
-- The condition of RD-start does or does not hold.
-- [RD-start]:A Component can start
--    all its mandatory Imports are wired to started Components and				
--    all its optional Imports are wired only to started components.
:def csp2-6RD-start1 = :csp {
  eq allIMInBothStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(wired unused)) and
     allCOInBothStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,wired)),started) = true .
  eq allIMInBothStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(wired unused)) = false .
  eq allCOInBothStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,wired)),started) = false .
}
:apply (csp2-6RD-start1 rd-)

-- Case 2: eq allIMInBothStates(getIMsOfTypeOfICO(sIM,mandatory,idCO),(wired unused)) = false .
:def csp2-6RD-start2 = :csp {
  eq sIM = (imp(mandatory, idIM, idCO, idCO', unwired, nIMs, tIMs) sIM') .
  eq sIM = (imp(mandatory, idIM, idCO, idCO', cIMs, unwired, tIMs) sIM') .
}
:apply (csp2-6RD-start2 rd-)

:def csp2-6RD-start3 = :csp {
  eq nIMs = unused .
  eq nIMs = unwired .
  eq nIMs = wired .
}
:def csp2-6RD-start4 = :csp {
  eq tIMs = unused .
  eq tIMs = unwired .
  eq tIMs = wired .
}
:apply (csp2-6RD-start3 csp2-6RD-start4 rd-)

eof
-- Case 3: eq allCOInBothStates(getECOsOfIMs(sCO,getIMsOfICOInStates(sIM,idCO,wired)),started) = false .
-- When at least one of properties of the resource idRS' is not-ready.
--> *********************************************************************
--> Step 2-7: When there are two identifier constants of the same sort,
--> split the current case into cases where they are or are not the same.
--> *********************************************************************
-- idRRS and idRS/idRS' are or are not the same.
:def ctf2-7idRRSa = :ctf {
  eq idRRS = idRS .
}
:def ctf2-7idRRSb = :ctf {
  eq idRRS = idRS' .
}
:apply (ctf2-7idRRSa rd-)
:apply (ctf2-7idRRSb rd-)
-- When at least one of properties of the resource idRS' is not-ready.
-- Because sPR is redefined, allPROfRSInStates(sPR,idRS,ready) should be claimed again.
:set(normalize-init,on)
:init ( ceq B1:Bool = true if not B2:Bool . ) by {
  B1:Bool <- allPROfRSInStates(sPR,idRS,ready) ;
  B2:Bool <- allPROfRSInStates(sPR,idRS,ready) == true ;
}
:set(normalize-init,off)
--> ***************************************************************
--> Step 2-8: When there is a dangling link, split the current case
-->  into cases where the linked object does or does not exist.
--> ***************************************************************
-- The resource referred by the property does or does not exist.
:def csp2-8idRRSa = :csp {
  eq existRS(sRS',idRRS) = false .
  eq sRS' = (res(trs'',idRRS,srs'') sRS'') .
}
:def csp2-8idRRSb = :csp { 
  eq srs'' = initial .
  eq srs'' = started .
}
:apply (csp2-8idRRSa rd- csp2-8idRRSb rd-)
-- When the resource idRRS is initial:
--> ******************************************************************************
--> Step 2-9: When falling in a cyclic situation, use the Cyclic Dependency Lemma.
--> ******************************************************************************
-- The Cyclic Dependency Lemma rejects this case.
:set(normalize-init,on)
:init [noCycle] by {
  O:Resource <- res(trs',idRS',initial);
  S:State <- < (res(trs,idRS,initial) sRS), sPR >;
  SS:SetOfRSState <- initial;
}
:set(normalize-init,off)
:apply (rd-)
show proof

select
