require Proof Proof.cafe
provide Proof-inv

-- As to rule R01, we have checked all possible cases, however,
-- here we will omit irrevant cases in which wfs(S) does not hold and thus invinv(S) holds.

--> ***************************
--> (5) init(S) implies inv(S).
--> (6) inv(S) implies inv(SS).
--> ***************************

module! ProofInv {
  pr(PROOFfuns)
  pred invS : State
  pred invSS : State
  pred initinv : State
  eq initinv(S:State)
     = init(S) implies invSS(S) .
  pred invinv : State State Bool
  eq invinv(S:State,SS:State,CC:Bool)
     = not (S =(*,1)=>+ SS if CC suchThat
            not ((CC then
                  (invS(S) implies invSS(SS))) == true)
     	   { S => SS !! CC ! invS(S) ! invSS(SS) }) .
}

--> ****************************************************************************
--> Proof of inv-allPairOfCPRQSameType.
-->  eq inv-allPairOfCPRQSameType(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = allPairOfCPRQSameType(SetCP,SetRL,SetRQ) .
--> ****************************************************************************
module! Proofinv-allPairOfCPRQSameType {
  pr(ProofInv)
  eq inv(S:State) = inv-allPairOfCPRQSameType(S) .
  eq wfs(S:State) = wfs-allCPHaveRL(S) and wfs-allRLHaveRQ(S) .
  pred lemma : SetOfCapability SetOfRelationship SetOfRequirement
  eq lemma(SetCP:SetOfCapability,SetRL:SetOfRelationship,SetRQ:SetOfRequirement)
     = allCPHaveRL(SetCP,SetRL) and allRLHaveRQ(SetRL,SetRQ) implies
       allPairOfCPRQSameType(SetCP,SetRL,SetRQ) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-allPairOfCPRQSameType .
  red lemma(empCP,sRL,sRQ) .
close
--> Induction Case: SetCP has a capability,
-->       sCP = (cap(trl,idCP,scp,idND) sCP') .
--> Case 1:
--> (1-1) onlyOneRLOfCP(sRL,idCP) does not hold.
open Proofinv-allPairOfCPRQSameType .
  eq onlyOneRLOfCP(sRL,idCP) = false .
  eq sCP = (cap(trl,idCP,scp,idND) sCP') .
  red lemma(sCP',sRL,sRQ) implies lemma(sCP,sRL,sRQ) .
close
--> Case 2:
--> (1-2) onlyOneRLOfCP(sRL,idCP) holds, i.e. sRL = (rel(trl',idRL,idCP,idRQ) sRL'),
--> (2-1) trl' is not trl.
open Proofinv-allPairOfCPRQSameType .
  eq (trl = trl') = false .
  eq sRL = (rel(trl',idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,scp,idND) sCP') .
  red lemma(sCP',sRL,sRQ) implies lemma(sCP,sRL,sRQ) .
close
--> Case 3:
--> (1-2) onlyOneRLOfCP(sRL,idCP) holds, i.e. sRL = (rel(trl',idRL,idCP,idRQ) sRL'),
--> (2-2) trl' is trl,
--> (3-1) existRQ(sRQ,idRQ) does not hold.
open Proofinv-allPairOfCPRQSameType .
  eq existRQ(sRQ,idRQ) = false .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,scp,idND) sCP') .
  red lemma(sCP',sRL,sRQ) implies lemma(sCP,sRL,sRQ) .
close
--> Case 4:
--> (1-2) onlyOneRLOfCP(sRL,idCP) holds, i.e. sRL = (rel(trl',idRL,idCP,idRQ) sRL'),
--> (2-2) trl' is trl,
--> (3-2) existRQ(sRQ,idRQ) holds, i.e. sRQ = (req(trl'',idRQ,srq,idND') sRQ'),
--> (4-1) trl'' is not trl.
open Proofinv-allPairOfCPRQSameType .
  eq (trl = trl'') = false .
  eq sRQ = (req(trl'',idRQ,srq,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,scp,idND) sCP') .
  red lemma(sCP',sRL,sRQ) implies lemma(sCP,sRL,sRQ) .
close
--> Case 5:
--> (1-2) onlyOneRLOfCP(sRL,idCP) holds, i.e. sRL = (rel(trl',idRL,idCP,idRQ) sRL'),
--> (2-2) trl' is trl,
--> (3-2) existRQ(sRQ,idRQ) holds, i.e. sRQ = (req(trl'',idRQ,srq,idND') sRQ'),
--> (4-2) trl'' is trl.
open Proofinv-allPairOfCPRQSameType .
  eq sRQ = (req(trl,idRQ,srq,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,scp,idND) sCP') .
  red lemma(sCP',sRL,sRQ) implies lemma(sCP,sRL,sRQ) .
close
--> Proof of initinv.
open Proofinv-allPairOfCPRQSameType .
  red lemma(sCP,sRL,sRQ) and wfs(< sND,sCP,sRQ,sRL,mp >)
      implies inv(< sND,sCP,sRQ,sRL,mp >) .
close

--> *********************************************************************
--> Proof of inv-ifOpenMsgThenCPActivated.
-->  eq inv-ifOpenMsgThenCPActivated(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifOpenMsgThenCPInStates(MP,SetCP,(open available)) .
--> *********************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifOpenMsgThenCPActivated-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
}
--> Proof of initinv.
--> Case 1:
--> (1-1) MP is empty.
open Proofinv-ifOpenMsgThenCPActivated-init .
  red initinv(< sND,sCP,sRQ,sRL,empMsg >) .
close
--> Case 2:
--> (1-2) MP is not empty.
open Proofinv-ifOpenMsgThenCPActivated-init .
  eq (mp = empMsg) = false .
  red initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifOpenMsgThenCPActivated-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifOpenMsgThenCPActivated-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
--> The tosca-theorem11 ensures that
--> ifOpenMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),(open available)) implies
-->   ifOpenMsgThenCPInStates(mp,(cap(hostedOn,idCP,available,idND) sCP),(open available)) .
open Proofinv-ifOpenMsgThenCPActivated-R03 .
  eq (ifOpenMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),(open available)) and
      ifOpenMsgThenCPInStates(mp,(cap(hostedOn,idCP,available,idND) sCP),(open available)))
     = ifOpenMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),(open available)) .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifOpenMsgThenCPActivated-R04 .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
--> The tosca-theorem12 ensures that
--> ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),(open available)) implies
-->   ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),(open available)) .
open Proofinv-ifOpenMsgThenCPActivated-R05 .
  eq (ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),(open available)) and
      ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),(open available)))
     = ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),(open available)) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifOpenMsgThenCPActivated-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
--> The tosca-theorem11 ensures that
--> ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),(open available)) implies
-->   ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,available,idND) sCP),(open available)) .
open Proofinv-ifOpenMsgThenCPActivated-R06 .
  eq (ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),(open available)) and
      ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,available,idND) sCP),(open available)))
     = ifOpenMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),(open available)) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
open Proofinv-ifOpenMsgThenCPActivated-R07 .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifOpenMsgThenCPActivated-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
--> The tosca-theorem12 ensures that
--> ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),(open available)) implies
-->   ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),(open available)) .
open Proofinv-ifOpenMsgThenCPActivated-R09 .
  eq (ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),(open available)) and
      ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),(open available)))
     = ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),(open available)) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
--> The tosca-theorem11 ensures that
--> ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),(open available)) implies
-->   ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,available,idND) sCP),(open available)) .
open Proofinv-ifOpenMsgThenCPActivated-R10 .
  eq (ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),(open available)) and
      ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,available,idND) sCP),(open available)))
     = ifOpenMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),(open available)) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifOpenMsgThenCPActivated-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
open Proofinv-ifOpenMsgThenCPActivated-R11 .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifOpenMsgThenCPActivated-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifOpenMsgThenCPActivated(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifOpenMsgThenCPActivated-R12 .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *********************************************************************
--> Proof of inv-ifCPClosedThenRQUnbound.
-->  eq inv-ifCPClosedThenRQUnbound(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .
--> *********************************************************************
--> This proof requires inv-ifOpenMsgThenCPActivated.
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifCPClosedThenRQUnbound-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship
  eq lemma(SetCP:SetOfCapability,SetRQ:SetOfRequirement,SetRL:SetOfRelationship)
     = allRQInStates(SetRQ,unbound) 
       implies ifCPInStatesThenRQInStates(SetCP,closed,SetRQ,unbound,SetRL) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sCP = empCP .
  red lemma(sCP,sRQ,sRL) .
close
--> Induction Case: SetCP has a capability.
-->       i.e. sCP = (cap(trl,idCP,scp,idND) sCP'),
-->       sRL = (rel(trl,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(trl,idRQ,srq,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> Case 1:
--> (1-1) The capability is open.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sRQ = (req(trl,idRQ,srq,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 2:
--> (1-2) The capability is available.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sRQ = (req(trl,idRQ,srq,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 3:
--> (1-3) The capability is closed,
--> (2-1) srq is unbound.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sRQ = (req(trl,idRQ,unbound,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 4:
--> (1-3) The capability is closed,
--> (2-2) srq is waiting.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sRQ = (req(trl,idRQ,waiting,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 5:
--> (1-3) The capability is closed,
--> (2-3) srq is ready.
open Proofinv-ifCPClosedThenRQUnbound-init .
  eq sRQ = (req(trl,idRQ,ready,idND') sRQ') .
  eq sRL = (rel(trl,idRL,idCP,idRQ) sRL') .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Proof of initinv.
open Proofinv-ifCPClosedThenRQUnbound-init .
  red lemma(sCP,sRQ,sRL) implies initinv(< sND,sCP,sRQ,sRL,empMsg >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifCPClosedThenRQUnbound-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifCPClosedThenRQUnbound-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifCPClosedThenRQUnbound-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqCP(S) .
}
--> Proof of invinv.
--> Case 1: existCP(sCP,idCP) holds.
open Proofinv-ifCPClosedThenRQUnbound-R04 .
  eq existCP(sCP,idCP) = true .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2: existCP(sCP,idCP) does not hold.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP,closed,(req(hostedOn,idRQ,unbound,idND2) sRQ),unbound,
-->                                       (rel(hostedOn,idRL,idCP,idRQ) sRL)) implies
-->   ifCPInStatesThenRQInStates(sCP,closed,(req(hostedOn,idRQ,ready,idND2) sRQ),unbound,
-->                                         (rel(hostedOn,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPClosedThenRQUnbound-R04 .
  eq (ifCPInStatesThenRQInStates(sCP,closed,(req(hostedOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,closed,(req(hostedOn,idRQ,ready,idND2) sRQ),unbound,
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP,closed,(req(hostedOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
open Proofinv-ifCPClosedThenRQUnbound-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifCPClosedThenRQUnbound-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
open Proofinv-ifCPClosedThenRQUnbound-R06 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqCP(S) .
}
--> Case 1:
--> (1-1) state(getNode(sND,idND2)) is not created.
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq (state(getNode(sND,idND2)) = created) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) state(getNode(sND,idND2)) is created,
--> (2-1) existCP(sCP,idCP) holds.
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq existCP(sCP,idCP) = true .
  eq state(getNode(sND,idND2)) = created .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) state(getNode(sND,idND2)) is created,
--> (2-2) existCP(sCP,idCP) does not hold,
--> (3-1) scp is closed.
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq scp = closed .
  eq existCP(sCP,idCP) = false .
  eq state(getNode(sND,idND2)) = created .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) state(getNode(sND,idND2)) is created,
--> (2-2) existCP(sCP,idCP) does not hold,
--> (3-2) scp is closed,
--> (4-1) The condition of R06 does not hold.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
-->                                       (rel(dependsOn,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
--> 		                          (rel(dependsOn,idRL,idCP,idRQ) sRL)))
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq (ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
      			                    (rel(dependsOn,idRL,idCP,idRQ) sRL)))
     =  ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) .
  eq (state(getNode(sND,idND1)) = started) = false .
  eq scp = open .
  eq existCP(sCP,idCP) = false .
  eq state(getNode(sND,idND2)) = created .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) state(getNode(sND,idND2)) is created,
--> (2-2) existCP(sCP,idCP) does not hold,
--> (3-2) scp is closed,
--> (4-2) The condition of R06 holds.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
-->                                       (rel(dependsOn,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
--> 		                          (rel(dependsOn,idRL,idCP,idRQ) sRL)))
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq (ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
      			                    (rel(dependsOn,idRL,idCP,idRQ) sRL)))
     =  ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) .
  eq state(getNode(sND,idND1)) = started .
  eq scp = open .
  eq existCP(sCP,idCP) = false .
  eq state(getNode(sND,idND2)) = created .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) state(getNode(sND,idND2)) is created,
--> (2-2) existCP(sCP,idCP) does not hold,
--> (3-3) scp is available.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
-->                                       (rel(dependsOn,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
--> 		                          (rel(dependsOn,idRL,idCP,idRQ) sRL)))
open Proofinv-ifCPClosedThenRQUnbound-R07 .
  eq (ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,waiting,idND2) sRQ),unbound,
      			                    (rel(dependsOn,idRL,idCP,idRQ) sRL)))
     =  ifCPInStatesThenRQInStates(sCP,closed,(req(dependsOn,idRQ,unbound,idND2) sRQ),unbound,
                                            (rel(dependsOn,idRL,idCP,idRQ) sRL)) .
  eq scp = available .
  eq existCP(sCP,idCP) = false .
  eq state(getNode(sND,idND2)) = created .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifCPClosedThenRQUnbound-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv .
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
open Proofinv-ifCPClosedThenRQUnbound-R09 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R10 does not hold,
open Proofinv-ifCPClosedThenRQUnbound-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-ifCPClosedThenRQUnbound-R10 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqCP(S) and wfs-allCPHaveRL(S)
     		     and inv-ifOpenMsgThenCPActivated(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-1) TRL is hostedOn.
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq sCP = (cap(hostedOn,idCP,scp,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-2) TRL is dependsOn.
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq sCP = (cap(dependsOn,idCP,scp,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-3) TRL is connectsTo,
--> (3-1) existCP(sCP',idCP) holds.
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq existCP(sCP',idCP) = true .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-3) TRL is connectsTo,
--> (3-2) existCP(sCP',idCP) does not hold,
--> (4-1) SCP is closed.
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq sCP = (cap(connectsTo,idCP,closed,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-3) TRL is connectsTo,
--> (3-2) existCP(sCP',idCP) does not hold,
--> (4-2) SCP is open,
--> (5-1) The condition of R10 does not hold.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
-->                                        (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
-->   ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
-->                                          (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq (ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  eq (state(getNode(sND,idND')) = started) = false .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 7:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-3) TRL is connectsTo,
--> (3-2) existCP(sCP',idCP) does not hold,
--> (4-2) SCP is open,
--> (5-2) The condition of R10 holds.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
-->                                        (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
-->   ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
-->                                          (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq (ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  eq (state(getNode(sND,idND')) = started) = true .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 8:
--> (1-2) The condition of R11 holds,
-->       existCP(sCP,idCP) holds, i.e. sCP = (cap(TRL,idCP,SCP) sCP'), because of wfs-allRLHaveCP(S),
--> (2-3) TRL is connectsTo,
--> (3-2) existCP(sCP',idCP) does not hold,
--> (4-3) SCP is available.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
-->                                        (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
-->   ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
-->                                          (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPClosedThenRQUnbound-R11 .
  eq (ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP',closed,(req(connectsTo,idRQ,unbound,idND) sRQ),unbound,
                                             (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  eq sCP = (cap(connectsTo,idCP,available,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifCPClosedThenRQUnbound-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> The tosca-theorem09 ensures that
--> ifCPInStatesThenRQInStates(sCP,closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
-->                                       (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP,closed,(req(connectsTo,idRQ,ready,idND) sRQ),unbound,
-->                                       (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPClosedThenRQUnbound-R12 .
  eq (ifCPInStatesThenRQInStates(sCP,closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
                                            (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,closed,(req(connectsTo,idRQ,ready,idND) sRQ),unbound,
                                            (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP,closed,(req(connectsTo,idRQ,waiting,idND) sRQ),unbound,
                                            (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *********************************************************************
--> Proof of inv-ifAvailableMsgThenCPAvailable.
-->  eq inv-ifAvailableMsgThenCPAvailable(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifAvailableMsgThenCPInStates(MP,SetCP,started) .
--> *********************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifAvailableMsgThenCPAvailable-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
}
--> Proof of initinv.
--> Case 1:
--> (1-1) MP is empty.
open Proofinv-ifAvailableMsgThenCPAvailable-init .
  red initinv(< sND,sCP,sRQ,sRL,empMsg >) .
close
--> Case 2:
--> (1-2) MP is not empty.
open Proofinv-ifAvailableMsgThenCPAvailable-init .
  eq (mp = empMsg) = false .
  red initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifAvailableMsgThenCPAvailable-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifAvailableMsgThenCPAvailable-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
--> The tosca-theorem01 ensures that
--> ifAvailableMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),available) implies
-->   ifAvailableMsgThenCPInStates(mp,(cap(hostedOn,idCP,available,idND) sCP),available) .
open Proofinv-ifAvailableMsgThenCPAvailable-R03 .
  eq (ifAvailableMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),available) and
      ifAvailableMsgThenCPInStates(mp,(cap(hostedOn,idCP,available,idND) sCP),available))
     = ifAvailableMsgThenCPInStates(mp,(cap(hostedOn,idCP,closed,idND) sCP),available) .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifAvailableMsgThenCPAvailable-R04 .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
--> The tosca-theorem02 ensures that
--> ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),available) implies
-->   ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),available) .
open Proofinv-ifAvailableMsgThenCPAvailable-R05 .
  eq (ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),available) and
      ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),available))
     = ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,closed,idND) sCP),available) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifAvailableMsgThenCPAvailable-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
--> The tosca-theorem01 ensures that
--> ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),available) implies
-->   ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,available,idND) sCP),available) .
open Proofinv-ifAvailableMsgThenCPAvailable-R06 .
  eq (ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),available) and
      ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,available,idND) sCP),available))
     = ifAvailableMsgThenCPInStates(mp,(cap(dependsOn,idCP,open,idND) sCP),available) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
open Proofinv-ifAvailableMsgThenCPAvailable-R07 .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
--> 	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifAvailableMsgThenCPAvailable-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
--> The tosca-theorem02 ensures that
--> ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),available) implies
-->   ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),available) .
open Proofinv-ifAvailableMsgThenCPAvailable-R09 .
  eq (ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),available) and
      ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),available))
     = ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,closed,idND) sCP),available) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R10 holds.
--> The tosca-theorem01 ensures that
--> ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),available) implies
-->   ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,available,idND) sCP),available) .
open Proofinv-ifAvailableMsgThenCPAvailable-R10 .
  eq (ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),available) and
      ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,available,idND) sCP),available))
     = ifAvailableMsgThenCPInStates(mp,(cap(connectsTo,idCP,open,idND) sCP),available) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifAvailableMsgThenCPAvailable-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
open Proofinv-ifAvailableMsgThenCPAvailable-R11 .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifAvailableMsgThenCPAvailable-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifAvailableMsgThenCPAvailable(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifAvailableMsgThenCPAvailable-R12 .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> ****************************************************************************
--> Proof of inv-ifCPOpenThenRQUnboundWaiting.
-->  eq inv-ifCPOpenThenRQUnboundWaiting(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifCPInStatesThenRQInStates(SetCP,open,SetRQ,(unbound waiting),SetRL) .
--> ****************************************************************************
--> This proof requires inv-ifCPClosedThenRQUnbound and inv-ifAvailableMsgThenCPAvailable .
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship
  eq lemma(SetCP:SetOfCapability,SetRQ:SetOfRequirement,SetRL:SetOfRelationship)
     = allCPInStates(SetCP,closed) 
       implies ifCPInStatesThenRQInStates(SetCP,open,SetRQ,(unbound waiting),SetRL) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-ifCPOpenThenRQUnboundWaiting-init .
  eq sCP = empCP .
  red lemma(sCP,sRQ,sRL) .
close
--> Induction Case: SetCP has a capability.
--> Case 1:
--> (1-1) It is closed.
open Proofinv-ifCPOpenThenRQUnboundWaiting-init .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 2:
--> (1-2) It is open.
open Proofinv-ifCPOpenThenRQUnboundWaiting-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Case 3:
--> (1-3) It is available.
open Proofinv-ifCPOpenThenRQUnboundWaiting-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP',sRQ,sRL) implies lemma(sCP,sRQ,sRL) .
close
--> Proof of initinv.
open Proofinv-ifCPOpenThenRQUnboundWaiting-init .
  red lemma(sCP,sRQ,sRL) implies initinv(< sND,sCP,sRQ,sRL,empMsg >) .
close
--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqCP(S) .
}
--> Proof of invinv.
--> Case 1: existCP(sCP,idCP) holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R04 .
  eq existCP(sCP,idCP) = true .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2: existCP(sCP,idCP) does not hold.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
-->                                       (rel(hostedOn,idRL,idCP,idRQ) sRL)) implies
-->   ifCPInStatesThenRQInStates(sCP,open,(req(hostedOn,idRQ,ready,idND2) sRQ),(unbound waiting),
-->                                         (rel(hostedOn,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPOpenThenRQUnboundWaiting-R04 .
  eq (ifCPInStatesThenRQInStates(sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,open,(req(hostedOn,idRQ,ready,idND2) sRQ),(unbound waiting),
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
                                            (rel(hostedOn,idRL,idCP,idRQ) sRL)) .
eq existCP(sCP,idCP) = false .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) and inv-ifCPClosedThenRQUnbound(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds,
-->       sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(dependsOn,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-1) SRQ is unbound.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R05 .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND') sRQ') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R05 holds,
-->       sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(dependsOn,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-2) SRQ is waiting.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R05 .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND') sRQ') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The condition of R05 holds,
-->       sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(dependsOn,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-3) SRQ is ready.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R05 .
  eq sRQ = (req(dependsOn,idRQ,ready,idND') sRQ') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifCPOpenThenRQUnboundWaiting-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R06 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
--> The tosca-theorem10 ensures that
--> ifCPInStatesThenRQInStates(sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
-->                                      (rel(dependsOn,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP,open,(req(dependsOn,idRQ,waiting,idND2) sRQ),(unbound waiting),
-->                                      (rel(dependsOn,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPOpenThenRQUnboundWaiting-R07 .
  eq (ifCPInStatesThenRQInStates(sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
                                           (rel(dependsOn,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP,open,(req(dependsOn,idRQ,waiting,idND2) sRQ),(unbound waiting),
                                           (rel(dependsOn,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound waiting),
                                           (rel(dependsOn,idRL,idCP,idRQ) sRL)) .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifCPOpenThenRQUnboundWaiting-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) and inv-ifCPClosedThenRQUnbound(S) .
}
--> Proof of invinv .
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds,
-->       sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(connectsTo,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-1) SRQ is unbound.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R09 .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND') sRQ') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R09 holds,
-->       sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(connectsTo,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-2) SRQ is waiting.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R09 .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND') sRQ') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The condition of R09 holds,
-->       sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') because of wfs-allCPHaveRL(S),
-->       sRQ = (req(connectsTo,idRQ,SRQ,idND') sRQ') because of wfs-allRLHaveRQ(S),
--> (2-3) SRQ is ready.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R09 .
  eq sRQ = (req(connectsTo,idRQ,ready,idND') sRQ') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R10 does not hold,
open Proofinv-ifCPOpenThenRQUnboundWaiting-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R10 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Proof of invinv.
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds,
-->       sCP = (cap(connectsTo,idCP,SCP,idND') sCP') because of wfs-allRLHaveCP(S),
--> The tosca-theorem10 ensures that
--> ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound waiting),
-->                                      (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound waiting),
-->                                      (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPOpenThenRQUnboundWaiting-R11 .
  eq (ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  eq sCP = (cap(connectsTo,idCP,scp,idND') sCP') .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifCPOpenThenRQUnboundWaiting-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifCPOpenThenRQUnboundWaiting(S) .
  eq invS(S:State) = invSS(S) and inv-ifAvailableMsgThenCPAvailable(S)
                     and wfs-uniqCP(S) .
}
--> Proof of invinv.
-->       sCP = (cap(connectsTo,idCP,SCP,idND') sCP') because of wfs-allRLHaveCP(S),
--> Case 1:
--> (1-1) The capability is closed.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R12 .
  eq sCP = (cap(connectsTo,idCP,closed,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The capability is open,
--> (2-1) (state(getNode(sND,idND')) = started) holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R12 .
  eq (state(getNode(sND,idND')) = started) = true .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The capability is open,
--> (2-2) (state(getNode(sND,idND')) = started) does not hold.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R12 .
  eq (state(getNode(sND,idND')) = started) = false .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-3) The capability is available.
--> (3-1) existCP(sCP',idCP) holds.
open Proofinv-ifCPOpenThenRQUnboundWaiting-R12 .
  eq existCP(sCP',idCP) = true .
  eq sCP = (cap(connectsTo,idCP,available,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-3) The capability is available.
--> (3-2) existCP(sCP',idCP) does not hold.
--> The tosca-theorem08 ensures that
--> ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound waiting),
-->                                      (rel(connectsTo,idRL,idCP,idRQ) sRL)) implies
--> ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,ready,idND) sRQ),(unbound waiting),
-->                                      (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
open Proofinv-ifCPOpenThenRQUnboundWaiting-R12 .
  eq (ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)) and
      ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,ready,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)))
     = ifCPInStatesThenRQInStates(sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound waiting),
                                           (rel(connectsTo,idRL,idCP,idRQ) sRL)) .
  eq sCP = (cap(connectsTo,idCP,available,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> ****************************************************************************************
--> Proof of inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg.
-->  eq inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,open,SetRQ,waiting,SetRL,MP) .
--> ****************************************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship PoolOfMsg
  eq lemma(SetCP:SetOfCapability,SetRQ:SetOfRequirement,SetRL:SetOfRelationship,MP:PoolOfMsg)
     = allCPInStates(SetCP,closed) 
       implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,open,SetRQ,waiting,SetRL,MP) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init .
  eq sCP = empCP .
  red lemma(sCP,sRQ,sRL,mp) .
close
--> Induction Case: SetCP has a capability.
--> Case 1:
--> (1-1) It is closed.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 2:
--> (1-2) It is open.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 3:
--> (1-3) It is available.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Proof of initinv.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-init .
  red lemma(sCP,sRQ,sRL,mp) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> The tosca-theorem06 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->	         sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),waiting,(rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->   	         sCP,open,(req(hostedOn,idRQ,ready,idND2) sRQ),waiting,(rel(hostedOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R04 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),waiting,(rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
      	  sCP,open,(req(hostedOn,idRQ,ready,idND2) sRQ),waiting,(rel(hostedOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,open,(req(hostedOn,idRQ,unbound,idND2) sRQ),waiting,(rel(hostedOn,idRL,idCP,idRQ) sRL),mp) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
--> The tosca-theorem06 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->	         sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),waiting,
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->   	         sCP,open,(req(dependsOn,idRQ,waiting,idND2) sRQ),waiting,
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R07 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),waiting,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
      	  sCP,open,(req(dependsOn,idRQ,waiting,idND2) sRQ),waiting,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,open,(req(dependsOn,idRQ,unbound,idND2) sRQ),waiting,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp) .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
--> The tosca-theorem03 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp) 
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,(opMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R09 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp) 
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,(opMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
--> The tosca-theorem04 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp)
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,open,sRQ,waiting,sRL,mp) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
--> The tosca-theorem05 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP,open,(req(connectsTo,idRQ,unbound,idND) sRQ),waiting,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) implies
-->      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP,open,(req(connectsTo,idRQ,waiting,idND) sRQ),waiting,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R11 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,open,(req(connectsTo,idRQ,unbound,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,open,(req(connectsTo,idRQ,waiting,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,open,(req(connectsTo,idRQ,unbound,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
--> This proof requires inv-ifAvailableMsgThenCPAvailable.
module! Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) and inv-ifAvailableMsgThenCPAvailable(S) and 
     		     wfs-allRLHaveCP(S) and wfs-uniqCP(S) .
}
--> Case 1:
--> (1-1) existCP(sCP,idCP) does not hold.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq existCP(sCP,idCP) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-1) the capability is type of HostedOn.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq sCP = (cap(hostedOn,idCP,scp,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-2) the capability is type of DependsOn.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq sCP = (cap(dependsOn,idCP,scp,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-3) the capability is type of ConnectsTo,
--> (3-1) it is closed.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq sCP = (cap(connectsTo,idCP,closed,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-3) the capability is type of ConnectsTo,
--> (3-2) it is open,
--> (4-1) state(getNode(sND,idND')) is not started.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq (state(getNode(sND,idND')) = started) = false .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-3) the capability is type of ConnectsTo,
--> (3-2) it is open,
--> (4-2) state(getNode(sND,idND')) is started.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq (state(getNode(sND,idND')) = started) = false .
  eq sCP = (cap(connectsTo,idCP,open,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 7:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-3) the capability is type of ConnectsTo,
--> (3-3) it is available,
--> (5-1) existCP(sCP',idCP) holds.
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq existCP(sCP',idCP) = true .
  eq sCP = (cap(connectsTo,idCP,available,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 8:
--> (1-2) existCP(sCP,idCP) holds,
-->       which means that sCP = (cap(TRL,idCP,SCP,idND') sCP'),
--> (2-3) the capability is type of ConnectsTo,
--> (3-3) it is available,
--> (5-2) existCP(sCP',idCP) does not hold.
--> The tosca-theorem07 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),waiting,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) implies
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP',open,(req(connectsTo,idRQ,ready,idND) sRQ),waiting,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg-R12 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP',open,(req(connectsTo,idRQ,ready,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP',open,(req(connectsTo,idRQ,waiting,idND) sRQ),waiting,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) .
  eq existCP(sCP',idCP) = false .
  eq sCP = (cap(connectsTo,idCP,available,idND') sCP') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *****************************************************************************************************
--> Proof of inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg.
-->  eq inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,available,SetRQ,(waiting ready),SetRL,MP) .
--> *****************************************************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship PoolOfMsg
  eq lemma(SetCP:SetOfCapability,SetRQ:SetOfRequirement,SetRL:SetOfRelationship,MP:PoolOfMsg)
     = allCPInStates(SetCP,closed) 
       implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(SetCP,available,SetRQ,(waiting ready),SetRL,MP) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init .
  eq sCP = empCP .
  red lemma(sCP,sRQ,sRL,mp) .
close
--> Induction Case: SetCP has a capability.
--> Case 1:
--> (1-1) It is closed.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 2:
--> (1-2) It is open.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 3:
--> (1-3) It is avalilable.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Proof of initinv.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-init .
  red lemma(sCP,sRQ,sRL,mp) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> The tosca-theorem06 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->	         sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),(waiting ready),
-->		 (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->   	         sCP,available,(req(hostedOn,idRQ,ready,idND2) sRQ),(waiting ready),
-->		 (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R04 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),(waiting ready),
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
      	  sCP,available,(req(hostedOn,idRQ,ready,idND2) sRQ),(waiting ready),
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),(waiting ready),
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
--> The tosca-theorem06 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->	         sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),(waiting ready),
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->   	         sCP,available,(req(dependsOn,idRQ,waiting,idND2) sRQ),(waiting ready),
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R07 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),(waiting ready),
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
      	  sCP,available,(req(dependsOn,idRQ,waiting,idND2) sRQ),(waiting ready),
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
	  sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),(waiting ready),
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp) .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
--> The tosca-theorem03 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) implies
-->   ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(opMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R09 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(opMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> This proof requires inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg.
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) and inv-ifConnectsToCPOpenThenRQWaitingOrOpenMsg(S) .
}
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-1) the corresponding requirement of the capability is unbound .
--> The tosca-theorem04 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = unbound .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-2) the corresponding requirement of the capability is waiting .
--> The tosca-theorem04 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = waiting .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-3) the corresponding requirement of the capability is ready .
--> The tosca-theorem04 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = ready .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The condition of R10 holds,
--> (2-2) MP has an open message of idCP,
--> The tosca-theorem04 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(opMsg(idCP) mp'))
-->   implies ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(avMsg(idCP) (opMsg(idCP) mp'))) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(opMsg(idCP) mp')) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,((avMsg(idCP) opMsg(idCP)) mp')))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(sCP,available,sRQ,(waiting ready),sRL,(opMsg(idCP) mp')) .
  eq mp = (opMsg(idCP) mp') .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
--> The tosca-theorem05 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),(waiting ready),
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) implies
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
-->		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),(waiting ready),
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R11 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> The tosca-theorem05 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
--> 		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),(waiting ready),
--> 		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) implies
--> ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
--> 		sCP,available,(req(connectsTo,idRQ,ready,idND) sRQ),(waiting ready),
--> 		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg-R12 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,ready,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrOpenMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),(waiting ready),
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> ************************************************************************************************
--> Proof of inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg.
-->  eq inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,available,SetRQ,ready,SetRL,MP) .
--> ************************************************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  pred lemma : SetOfCapability SetOfRequirement SetOfRelationship PoolOfMsg
  eq lemma(SetCP:SetOfCapability,SetRQ:SetOfRequirement,SetRL:SetOfRelationship,MP:PoolOfMsg)
     = allCPInStates(SetCP,closed) 
       implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(SetCP,available,SetRQ,ready,SetRL,MP) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init .
  eq sCP = empCP .
  red lemma(sCP,sRQ,sRL,mp) .
close
--> Induction Case: SetCP has a capability.
--> Case 1:
--> (1-1) It is closed.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 2:
--> (1-2) It is open.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Case 3:
--> (1-3) It is avalilable.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP',sRQ,sRL,mp) implies lemma(sCP,sRQ,sRL,mp) .
close
--> Proof of initinv.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-init .
  red lemma(sCP,sRQ,sRL,mp) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R03 .
  eq (isCreated(state(getNode(sND,idND)))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> The tosca-theorem16 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->	         sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready,
-->		 (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->   	         sCP,available,(req(hostedOn,idRQ,ready,idND2) sRQ),ready,
-->		 (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R04 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
	  sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready,
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
      	  sCP,available,(req(hostedOn,idRQ,ready,idND2) sRQ),ready,
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
	  sCP,available,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready,
	  (rel(hostedOn,idRL,idCP,idRQ) sRL),mp) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R05 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R05 holds.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R06 .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
--> The tosca-theorem16 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->	         sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready,
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->   	         sCP,available,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready,
-->		 (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R07 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
	  sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp)
      and ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
      	  sCP,available,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
	  sCP,available,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready,
	  (rel(dependsOn,idRL,idCP,idRQ) sRL),mp) .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
--> The tosca-theorem13 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) implies
-->   ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(opMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R09 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(opMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
--> This proof requires inv-ifConnectsToCPOpenThenRQWaitingOrAvailableMsg.
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-1) the corresponding requirement of the capability is unbound .
--> The tosca-theorem14 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = unbound .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-2) the corresponding requirement of the capability is waiting .
--> The tosca-theorem14 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = waiting .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The condition of R10 holds,
--> (2-1) MP does not have an open message of idCP,
--> (3-3) the corresponding requirement of the capability is ready .
--> The tosca-theorem14 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp)
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) mp)))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,mp) .
  eq state(getRequirement(sRQ,req(getRLOfCP(sRL,idCP)))) = ready .
  eq (opMsg(idCP) \in mp) = false .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The condition of R10 holds,
--> (2-2) MP has an open message of idCP,
--> The tosca-theorem14 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(opMsg(idCP) mp'))
-->   implies ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(avMsg(idCP) (opMsg(idCP) mp'))) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R10 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(opMsg(idCP) mp')) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,((avMsg(idCP) opMsg(idCP)) mp')))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(sCP,available,sRQ,ready,sRL,(opMsg(idCP) mp')) .
  eq mp = (opMsg(idCP) mp') .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
--> The tosca-theorem15 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),ready,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) implies
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
-->		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),ready,
-->		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R11 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,unbound,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(opMsg(idCP) mp)) .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq invS(S:State) = invSS(S) .
}
--> The tosca-theorem15 ensures that
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
--> 		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),ready,
--> 		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) implies
--> ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
--> 		sCP,available,(req(connectsTo,idRQ,ready,idND) sRQ),ready,
--> 		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp) .
open Proofinv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg-R12 .
  eq (ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) and
      ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,ready,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),mp))
     = ifConnectsToCPInStatesThenRQInStatesOrAvailableMsg(
		sCP,available,(req(connectsTo,idRQ,waiting,idND) sRQ),ready,
		(rel(connectsTo,idRL,idCP,idRQ) sRL),(avMsg(idCP) mp)) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> ***************************************************************
--> Proof of inv-ifNDInitialThenCPClosed.
-->  eq inv-ifNDInitialThenCPClosed(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenCPInStates(SetND,initial,SetCP,closed) .
--> ***************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifNDInitialThenCPClosed-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  pred lemma : SetOfNode SetOfCapability
  eq lemma(SetND:SetOfNode,SetCP:SetOfCapability)
     = allNDInStates(SetND,initial) and allCPInStates(SetCP,closed) 
       implies ifNDInStatesThenCPInStates(SetND,initial,SetCP,closed) .
}
--> Proof of lemma.
--> Base Case: SetND is empty.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sND = empND .
  red lemma(sND,sCP) .
close
--> Induction Case: SetND has a node.
--> Case 1:
--> (1-1) It is initial.
--> (2-1) There is no capability.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sCP = empCP .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Case 2:
--> (1-1) It is initial.
--> (2-1) There is at least one capability.
--> (3-1) allCPOfNDInStates(sCP,idND,closed) holds.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq allCPOfNDInStates(sCP,idND,closed) = true .
  eq (sCP = empCP) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Case 3:
--> (1-1) It is initial.
--> (2-1) There is at least one capability.
--> (3-2) allCPOfNDInStates(sCP,idND,closed) does not hold,
-->       i.e. sCP = (cap(trl,idCP,scp,idND) sCP') where scp is not closed,
--> (4-1) It is open.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Case 4:
--> (1-1) It is initial.
--> (2-1) There is at least one capability.
--> (3-2) allCPOfNDInStates(sCP,idND,closed) does not hold,
-->       i.e. sCP = (cap(trl,idCP,scp,idND) sCP') where scp is not closed,
--> (4-2) It is avialable.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Case 5:
--> (1-2) It is created.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sND = (node(tnd,idND,created) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Case 6:
--> (1-3) It is started.
open Proofinv-ifNDInitialThenCPClosed-init .
  eq sND = (node(tnd,idND,started) sND') .
  red lemma(sND',sCP) implies lemma(sND,sCP) .
close
--> Proof of initinv.
open Proofinv-ifNDInitialThenCPClosed-init .
  red lemma(sND,sCP) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds,
--> (2-1) sCP is empty.
open Proofinv-ifNDInitialThenCPClosed-R01 .
  eq sCP = empCP .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R01 holds,
--> (2-2) sCP is not empty.
open Proofinv-ifNDInitialThenCPClosed-R01 .
  eq (sCP = empCP) = false .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds,
--> (2-1) sCP is empty.
open Proofinv-ifNDInitialThenCPClosed-R02 .
  eq sCP = empCP .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R02 holds,
--> (2-2) sCP is not empty.
open Proofinv-ifNDInitialThenCPClosed-R02 .
  eq (sCP = empCP) = false .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 7:
--> (1-3) The corresponding node is started.
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq existND(sND',idND) = true .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 8:
--> (1-3) The corresponding node is started.
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R03 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDInitialThenCPClosed-R04 .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 7:
--> (1-3) The corresponding node is started,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq existND(sND',idND) = true .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 8:
--> (1-3) The corresponding node is started,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(hostedOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R05 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(dependsOn,idCP,closed,idND) sCP),closed) .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold,
open Proofinv-ifNDInitialThenCPClosed-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R06 holds.
--> The m2o-theorem10 ensures that
--> ifNDInStatesThenCPInStates(sND,initial,(cap(dependsOn,idCP,open,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND,initial,(cap(dependsOn,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R06 .
  eq (ifNDInStatesThenCPInStates(sND,initial,(cap(dependsOn,idCP,open,idND) sCP),closed) and 
      ifNDInStatesThenCPInStates(sND,initial,(cap(dependsOn,idCP,available,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND,initial,(cap(dependsOn,idCP,open,idND) sCP),closed) .
  eq (state(getNode(sND,idND)) = started) = true .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R07 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R07 .
  eq (state(getNode(sND,idND2)) = created and isActivated(scp)) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R07 holds.
open Proofinv-ifNDInitialThenCPClosed-R07 .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDInitialThenCPClosed-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 7:
--> (1-3) The corresponding node is started,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq existND(sND',idND) = true .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 8:
--> (1-3) The corresponding node is started,
--> (4-2) existND(sND',idND) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R09 .
  eq (ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,open,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND',initial,(cap(connectsTo,idCP,closed,idND) sCP),closed) .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
--> The m2o-theorem10 ensures that
--> ifNDInStatesThenCPInStates(sND,initial,(cap(connectsTo,idCP,open,idND) sCP),closed) implies
--> ifNDInStatesThenCPInStates(sND,initial,(cap(connectsTo,idCP,available,idND) sCP),closed)) .
open Proofinv-ifNDInitialThenCPClosed-R10 .
  eq (ifNDInStatesThenCPInStates(sND,initial,(cap(connectsTo,idCP,open,idND) sCP),closed) and
      ifNDInStatesThenCPInStates(sND,initial,(cap(connectsTo,idCP,available,idND) sCP),closed))
     = ifNDInStatesThenCPInStates(sND,initial,(cap(connectsTo,idCP,open,idND) sCP),closed) .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R11 does not hold.
open Proofinv-ifNDInitialThenCPClosed-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R11 holds.
open Proofinv-ifNDInitialThenCPClosed-R11 .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifNDInitialThenCPClosed-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDInitialThenCPClosed-R12 .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************
--> Proof of inv-ifNDInitialThenRQUnboundReady.
-->  eq inv-ifNDInitialThenRQUnboundReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenRQInStates(SetND,initial,SetRQ,(unbound ready)) .
--> ***********************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifNDInitialThenRQUnboundReady-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  pred lemma : SetOfNode SetOfRequirement
  eq lemma(SetND:SetOfNode,SetRQ:SetOfRequirement)
     = allNDInStates(SetND,initial) and allRQInStates(SetRQ,unbound) 
       implies ifNDInStatesThenRQInStates(SetND,initial,SetRQ,(unbound ready)) .
}
--> Proof of lemma.
--> Base Case: SetND is empty.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq sND = empND .
  red lemma(sND,sRQ) .
close
--> Induction Case: SetND has a node.
--> Case 1:
--> (1-1) It is initial.
--> (2-1) sRQ is empty.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq sRQ = empRQ .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 2:
--> (1-1) It is initial.
--> (2-2) sRQ is not empty.
--> (3-1) allRQOfNDInStates(sRQ,idND,(unbound ready)) holds.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq allRQOfNDInStates(sRQ,idND,(unbound ready)) = true .
  eq (sRQ = empRQ) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 3:
--> (1-1) It is initial.
--> (2-2) sRQ is not empty.
--> (3-2) allRQOfNDInStates(sRQ,idND,(unbound ready)) does not hold,
-->       i.e. sRQ = (req(trl,idRQ,waiting,idND) sRQ').
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq sRQ = (req(trl,idRQ,waiting,idND) sRQ') .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 4:
--> (1-2) It is created.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq sND = (node(tnd,idND,created) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 5:
--> (1-3) It is started.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  eq sND = (node(tnd,idND,started) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Proof of initinv.
open Proofinv-ifNDInitialThenRQUnboundReady-init .
  red lemma(sND,sRQ) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds,
--> (2-1) sRQ is empty.
open Proofinv-ifNDInitialThenRQUnboundReady-R01 .
  eq sRQ = empRQ .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R01 holds,
--> (2-2) sRQ is not empty.
open Proofinv-ifNDInitialThenRQUnboundReady-R01 .
  eq (sRQ = empRQ) = false .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds,
--> (2-1) sRQ is empty.
open Proofinv-ifNDInitialThenRQUnboundReady-R02 .
  eq sRQ = empRQ .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R02 holds,
--> (2-2) sRQ is not empty.
open Proofinv-ifNDInitialThenRQUnboundReady-R02 .
  eq (sRQ = empRQ) = false .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND,initial,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound ready)) implies
--> ifNDInStatesThenRQInStates(sND,initial,(req(hostedOn,idRQ,ready,idND2) sRQ),(unbound ready)) .
open Proofinv-ifNDInitialThenRQUnboundReady-R04 .
  eq (ifNDInStatesThenRQInStates(sND,initial,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound ready)) and
      ifNDInStatesThenRQInStates(sND,initial,(req(hostedOn,idRQ,ready,idND2) sRQ),(unbound ready)))
     = ifNDInStatesThenRQInStates(sND,initial,(req(hostedOn,idRQ,unbound,idND2) sRQ),(unbound ready)) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R06 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R06 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND2,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) isActivated(scp) does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq isActivated(scp) = false .
  eq sND = (node(tnd,idND2,snd) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-1) The condtion of R01 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = false .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-2) The condtion of R01 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = true .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-1) existND(sND',idND2) holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq existND(sND',idND2) = true .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-2) existND(sND',idND2) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',initial,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound ready)) implies
--> ifNDInStatesThenRQInStates(sND',initial,(req(dependsOn,idRQ,waiting,idND2) sRQ),(unbound ready))) .
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq (ifNDInStatesThenRQInStates(sND',initial,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound ready)) and
      ifNDInStatesThenRQInStates(sND',initial,(req(dependsOn,idRQ,waiting,idND2) sRQ),(unbound ready)))
     = ifNDInStatesThenRQInStates(sND',initial,(req(dependsOn,idRQ,unbound,idND2) sRQ),(unbound ready)) .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) isActivated(scp) holds,
--> (2-3) snd is started.
open Proofinv-ifNDInitialThenRQUnboundReady-R07 .
  eq sND = (node(tnd,idND2,started) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDInitialThenRQUnboundReady-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R09 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
--> The m2o-theorem07 ensures that
--> ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),initial,sRQ,(unbound ready)) implies
--> ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),initial,sRQ,(unbound ready))
open Proofinv-ifNDInitialThenRQUnboundReady-R09 .
  eq (ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),initial,sRQ,(unbound ready)) and
      ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),initial,sRQ,(unbound ready)))
     = ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),initial,sRQ,(unbound ready)) .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
open Proofinv-ifNDInitialThenRQUnboundReady-R09 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> The m2o-theorem07 ensures that
--> ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),initial,sRQ,(unbound ready)) implies
--> ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),initial,sRQ,(unbound ready))
open Proofinv-ifNDInitialThenRQUnboundReady-R09 .
  eq (ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),initial,sRQ,(unbound ready)) and
      ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),initial,sRQ,(unbound ready)))
     = ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),initial,sRQ,(unbound ready)) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDInitialThenRQUnboundReady-R09 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R10 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) existND(sND',idND) holds.
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-2) existND(sND',idND) does not hold.
--> (4-1) The condition of R02 does not hold,
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) implies
--> ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready))) .
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) and
      ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready)))
     = ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (3-2) existND(sND',idND) does not hold.
--> (4-2) The condition of R02 holds.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) implies
--> ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready))) .
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) and
      ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready)))
     = ifNDInStatesThenRQInStates(sND',initial,(req(connectsTo,idRQ,unbound,idND) sRQ),(unbound ready)) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDInitialThenRQUnboundReady-R11 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifNDInitialThenRQUnboundReady-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDInitialThenRQUnboundReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem08 ensures that
--> ifNDInStatesThenRQInStates(sND,initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready)) implies
--> ifNDInStatesThenRQInStates(sND,initial,(req(connectsTo,idRQ,ready,idND) sRQ),(unbound ready))) .
open Proofinv-ifNDInitialThenRQUnboundReady-R12 .
  eq (ifNDInStatesThenRQInStates(sND,initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready)) and
      ifNDInStatesThenRQInStates(sND,initial,(req(connectsTo,idRQ,ready,idND) sRQ),(unbound ready)))
     = ifNDInStatesThenRQInStates(sND,initial,(req(connectsTo,idRQ,waiting,idND) sRQ),(unbound ready)) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> **************************************************************
--> Proof of inv-ifNDStartedThenRQReady.
-->  eq inv-ifNDStartedThenRQReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenRQInStates(SetND,started,SetRQ,ready) .
--> **************************************************************
--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifNDStartedThenRQReady-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  pred lemma : SetOfNode SetOfRequirement
  eq lemma(SetND:SetOfNode,SetRQ:SetOfRequirement)
     = allNDInStates(SetND,initial) and allRQInStates(SetRQ,unbound) 
       implies ifNDInStatesThenRQInStates(SetND,started,SetRQ,ready) .
}
--> Proof of lemma.
--> Base Case: SetND is empty.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sND = empND .
  red lemma(sND,sRQ) .
close
--> Induction Case: SetND has a node.
--> Case 1:
--> (1-1) It is initial,
--> (2-1) sRQ is empty.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sRQ = empRQ .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 2:
--> (1-1) It is initial,
--> (2-2) sRQ is not empty,
--> (3-1) allRQOfNDInStates(sRQ,idND,ready) holds.
open Proofinv-ifNDStartedThenRQReady-init .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq (sRQ = empRQ) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 3:
--> (1-1) It is initial,
--> (2-2) sRQ is not empty,
--> (3-2) allRQOfNDInStates(sRQ,idND,ready) does not hold,
-->       i.e. sRQ = (req(trl,idRQ,srq,idND) sRQ'),
--> (4-1) srq is unbound.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sRQ = (req(trl,idRQ,unbound,idND) sRQ') .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 4:
--> (1-1) It is initial,
--> (2-2) sRQ is not empty,
--> (3-2) allRQOfNDInStates(sRQ,idND,ready) does not hold,
-->       i.e. sRQ = (req(trl,idRQ,srq,idND) sRQ'),
--> (4-2) srq is waiting.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sRQ = (req(trl,idRQ,waiting,idND) sRQ') .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 5:
--> (1-2) It is created.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sND = (node(tnd,idND,created) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 6:
--> (1-3) It is started.
open Proofinv-ifNDStartedThenRQReady-init .
  eq sND = (node(tnd,idND,started) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Proof of initinv.
open Proofinv-ifNDStartedThenRQReady-init .
  red lemma(sND,sRQ) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifNDStartedThenRQReady-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds,
--> (2-1) sRQ is empty.
open Proofinv-ifNDStartedThenRQReady-R01 .
  eq sRQ = empRQ .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R01 holds,
--> (2-2) sRQ is not empty.
open Proofinv-ifNDStartedThenRQReady-R01 .
  eq (sRQ = empRQ) = false .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifNDStartedThenRQReady-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds,
--> (2-1) sRQ is empty.
open Proofinv-ifNDStartedThenRQReady-R02 .
  eq sRQ = empRQ .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R02 holds,
--> (2-2) sRQ is not empty.
open Proofinv-ifNDStartedThenRQReady-R02 .
  eq (sRQ = empRQ) = false .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDStartedThenRQReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDStartedThenRQReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND,started,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND,started,(req(hostedOn,idRQ,ready,idND2) sRQ),ready) .
open Proofinv-ifNDStartedThenRQReady-R04 .
  eq (ifNDInStatesThenRQInStates(sND,started,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND,started,(req(hostedOn,idRQ,ready,idND2) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND,started,(req(hostedOn,idRQ,unbound,idND2) sRQ),ready) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDStartedThenRQReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDStartedThenRQReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold.
open Proofinv-ifNDStartedThenRQReady-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R06 holds.
open Proofinv-ifNDStartedThenRQReady-R06 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND2,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) isActivated(scp) does not hold.
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq isActivated(scp) = false .
  eq sND = (node(tnd,idND2,snd) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-1) The condtion of R01 does not hold.
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = false .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-2) The condtion of R01 holds.
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = true .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-1) existND(sND',idND2) holds.
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq existND(sND',idND2) = true .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-2) existND(sND',idND2) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready)) .
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq (ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) isActivated(scp) holds,
--> (2-3) snd is started.
open Proofinv-ifNDStartedThenRQReady-R07 .
  eq sND = (node(tnd,idND2,started) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDStartedThenRQReady-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDStartedThenRQReady-R09 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
--> The m2o-theorem07 ensures that
--> ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),started,sRQ,ready) implies
--> ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),started,sRQ,ready)
open Proofinv-ifNDStartedThenRQReady-R09 .
  eq (ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),started,sRQ,ready) and
      ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),started,sRQ,ready))
     = ifNDInStatesThenRQInStates((node(tnd,idND,initial) sND'),started,sRQ,ready) .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) The condition of R02 does not hold,
open Proofinv-ifNDStartedThenRQReady-R09 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-2) The condition of R02 holds,
--> The m2o-theorem07 ensures that
--> ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),started,sRQ,ready) implies
--> ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),started,sRQ,ready)
open Proofinv-ifNDStartedThenRQReady-R09 .
  eq (ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),started,sRQ,ready) and
      ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),started,sRQ,ready))
     = ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),started,sRQ,ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDStartedThenRQReady-R09 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifNDStartedThenRQReady-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-ifNDStartedThenRQReady-R10 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds.
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The corresponding node is created,
--> (3-1) existND(sND',idND) holds.
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (3-2) existND(sND',idND) does not hold.
--> (4-1) The condition of R02 does not hold,
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready)) .
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (3-2) existND(sND',idND) does not hold.
--> (4-2) The condition of R02 holds.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready)) .
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',started,(req(connectsTo,idRQ,unbound,idND) sRQ),ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDStartedThenRQReady-R11 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifNDStartedThenRQReady-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDStartedThenRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem08 ensures that
--> ifNDInStatesThenRQInStates(sND,started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND,started,(req(connectsTo,idRQ,ready,idND) sRQ),ready)) .
open Proofinv-ifNDStartedThenRQReady-R12 .
  eq (ifNDInStatesThenRQInStates(sND,started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND,started,(req(connectsTo,idRQ,ready,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND,started,(req(connectsTo,idRQ,waiting,idND) sRQ),ready) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************
--> Proof of inv-ifNDCreatedThenHostedOnRQReady.
-->  eq inv-ifNDCreatedThenHostedOnRQReady(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = ifNDInStatesThenHostedOnRQInStates(SetND,(created started),SetRQ,ready) .
--> *******************************************************************************

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  pred lemma : SetOfNode SetOfRequirement
  eq lemma(SetND:SetOfNode,SetRQ:SetOfRequirement)
     = allNDInStates(SetND,initial) and allRQInStates(SetRQ,unbound) 
       implies ifNDInStatesThenHostedOnRQInStates(SetND,(created started),SetRQ,ready) .
}
--> Proof of lemma.
--> Base Case: SetND is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  eq sND = empND .
  red lemma(sND,sRQ) .
close
--> Induction Case: SetND has a node.
--> Case 1:
--> (1-1) It is initial.
--> (2-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 2:
--> (1-1) It is initial.
--> (2-2) filterRQ(sRQ,hostedOn) is not empty,
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 3:
--> (1-2) It is create.
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  eq sND = (node(tnd,idND,created) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Case 4:
--> (1-3) It is started.
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  eq sND = (node(tnd,idND,created) sND') .
  red lemma(sND',sRQ) implies lemma(sND,sRQ) .
close
--> Proof of initinv.
open Proofinv-ifNDCreatedThenHostedOnRQReady-init .
  red lemma(sND,sRQ) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds,
--> (2-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R01 .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R01 holds,
--> (2-2) filterRQ(sRQ,hostedOn) is not empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R01 .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds,
--> (2-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R02 .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) The condition of R02 holds,
--> (2-2) filterRQ(sRQ,hostedOn) is not empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R02 .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R03 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND,(created started),
-->                            (req(hostedOn,idRQ,unbound,idND2) filterRQ(sRQ,hostedOn)),ready) implies
--> ifNDInStatesThenRQInStates(sND,(created started),
-->                            (req(hostedOn,idRQ,ready,idND2) filterRQ(sRQ,hostedOn)),ready) .
open Proofinv-ifNDCreatedThenHostedOnRQReady-R04 .
  eq (ifNDInStatesThenRQInStates(sND,(created started),
                                 (req(hostedOn,idRQ,unbound,idND2) filterRQ(sRQ,hostedOn)),ready) and
      ifNDInStatesThenRQInStates(sND,(created started),
                                 (req(hostedOn,idRQ,ready,idND2) filterRQ(sRQ,hostedOn)),ready))
     = ifNDInStatesThenRQInStates(sND,(created started),
                                  (req(hostedOn,idRQ,unbound,idND2) filterRQ(sRQ,hostedOn)),ready) .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R06 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R06 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND2,snd) sND') because of wfs-allCPHaveND(S).
--> Case 1:
--> (1-1) isActivated(scp) does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq isActivated(scp) = false .
  eq sND = (node(tnd,idND2,snd) sND') .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-2) filterRQ(sRQ,hostedOn) is not empty,
--> (4-1) The condtion of R01 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = false .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) isActivated(scp) holds,
--> (2-1) snd is initial.
--> (3-2) filterRQ(sRQ,hostedOn) is not empty,
--> (4-2) The condtion of R01 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND2,ready) = true .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq sND = (node(tnd,idND2,initial) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-1) existND(sND',idND2) holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq existND(sND',idND2) = true .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) isActivated(scp) holds,
--> (2-2) snd is created,
--> (3-2) existND(sND',idND2) does not hold.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready)) .
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq (ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,waiting,idND2) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',started,(req(dependsOn,idRQ,unbound,idND2) sRQ),ready) .
  eq sND = (node(tnd,idND2,created) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 7:
--> (1-2) isActivated(scp) holds,
--> (2-3) snd is started.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R07 .
  eq sND = (node(tnd,idND2,started) sND') .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-ifNDCreatedThenHostedOnRQReady-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) The condition of R01 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds,
--> (3-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-1) The corresponding node is initial,
--> (2-2) The condition of R01 holds,
--> (3-2) filterRQ(sRQ,hostedOn) is not empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (4-1) The condition of R02 does not hold,
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (4-2) The condition of R02 holds,
--> The m2o-theorem07 ensures that
--> ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),(created started),
-->                            filterRQ(sRQ,hostedOn),ready) implies
--> ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),(created started),
-->                            filterRQ(sRQ,hostedOn),ready)
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq (ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),(created started),
                                 filterRQ(sRQ,hostedOn),ready) and
      ifNDInStatesThenRQInStates((node(tnd,idND,started) sND'),(created started),
                                 filterRQ(sRQ,hostedOn),ready))
     = ifNDInStatesThenRQInStates((node(tnd,idND,created) sND'),(created started),
                                  filterRQ(sRQ,hostedOn),ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDCreatedThenHostedOnRQReady-R09 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R10 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) and wfs-uniqND(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The corresponding node is initial,
--> (2-1) filterRQ(sRQ,hostedOn) is empty.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq filterRQ(sRQ,hostedOn) = empRQ .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-1) The corresponding node is initial,
--> (2-2) filterRQ(sRQ,hostedOn) is not empty,
--> (3-1) The condition of R01 does not hold.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-1) The corresponding node is initial,
--> (2-2) filterRQ(sRQ,hostedOn) is not empty,
--> (3-2) The condition of R01 holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  eq (filterRQ(sRQ,hostedOn) = empRQ) = false .
  eq sND = (node(tnd,idND,initial) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) The corresponding node is created,
--> (4-1) existND(sND',idND) holds.
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq existND(sND',idND) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) The corresponding node is created,
--> (4-2) existND(sND',idND) does not hold.
--> (5-1) The condition of R02 does not hold,
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready)) .
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) The corresponding node is created,
--> (4-2) existND(sND',idND) does not hold.
--> (5-2) The condition of R02 holds.
--> The m2o-theorem04 ensures that
--> ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready)) .
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq (ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND',(created started),(req(connectsTo,idRQ,unbound,idND) sRQ),ready) .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  eq sND = (node(tnd,idND,created) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 7:
--> (1-3) The corresponding node is started,
open Proofinv-ifNDCreatedThenHostedOnRQReady-R11 .
  eq sND = (node(tnd,idND,started) sND') .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
eof
--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-ifNDCreatedThenHostedOnRQReady-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq invS(S:State) = invSS(S) .
}
--> The m2o-theorem08 ensures that
--> ifNDInStatesThenRQInStates(sND,(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready) implies
--> ifNDInStatesThenRQInStates(sND,(created started),(req(connectsTo,idRQ,ready,idND) sRQ),ready)) .
open Proofinv-ifNDCreatedThenHostedOnRQReady-R12 .
  eq (ifNDInStatesThenRQInStates(sND,(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready) and
      ifNDInStatesThenRQInStates(sND,(created started),(req(connectsTo,idRQ,ready,idND) sRQ),ready))
     = ifNDInStatesThenRQInStates(sND,(created started),(req(connectsTo,idRQ,waiting,idND) sRQ),ready) .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************
--> Proof of inv-HostedOnCPNotOpen .
-->  eq inv-HostedOnCPNotOpen(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = HostedOnCPInState(SetCP,(closed available)) .
--> *******************************************************************************

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-HostedOnCPNotOpen-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  pred lemma : SetOfCapability
  eq lemma(SetCP:SetOfCapability)
     = allCPInStates(SetCP,closed) 
       implies HostedOnCPInState(SetCP,(closed available)) .
}
--> Proof of lemma.
--> Base Case: SetCP is empty.
open Proofinv-HostedOnCPNotOpen-init .
  eq sCP = empCP .
  red lemma(sCP) .
close
--> Induction Case: SetCP has a capability.
--> Case 1:
--> (1-1) It is closed.
open Proofinv-HostedOnCPNotOpen-init .
  eq sCP = (cap(trl,idCP,closed,idND) sCP') .
  red lemma(sCP') implies lemma(sCP) .
close
--> Case 2:
--> (1-2) It is open.
open Proofinv-HostedOnCPNotOpen-init .
  eq sCP = (cap(trl,idCP,open,idND) sCP') .
  red lemma(sCP') implies lemma(sCP) .
close
--> Case 3:
--> (1-3) It is available.
open Proofinv-HostedOnCPNotOpen-init .
  eq sCP = (cap(trl,idCP,available,idND) sCP') .
  red lemma(sCP') implies lemma(sCP) .
close
--> Proof of initinv.
open Proofinv-HostedOnCPNotOpen-init .
  red lemma(sCP) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-HostedOnCPNotOpen-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-HostedOnCPNotOpen-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-HostedOnCPNotOpen-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-HostedOnCPNotOpen-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-HostedOnCPNotOpen-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-HostedOnCPNotOpen-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-HostedOnCPNotOpen-R03 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-HostedOnCPNotOpen-R03 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnCPNotOpen-R04 .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-HostedOnCPNotOpen-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-HostedOnCPNotOpen-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-HostedOnCPNotOpen-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold.
open Proofinv-HostedOnCPNotOpen-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R06 holds.
open Proofinv-HostedOnCPNotOpen-R06 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-HostedOnCPNotOpen-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) isActivated(scp) does not hold.
open Proofinv-HostedOnCPNotOpen-R07 .
  eq isActivated(scp) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) isActivated(scp) holds,
--> (2-1) state(getNode(sND,idND2)) is not created.
open Proofinv-HostedOnCPNotOpen-R07 .
  eq (state(getNode(sND,idND2)) = created) = false .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) isActivated(scp) holds,
--> (2-2) state(getNode(sND,idND2)) is created.
open Proofinv-HostedOnCPNotOpen-R07 .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnCPNotOpen-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-HostedOnCPNotOpen-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-HostedOnCPNotOpen-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
open Proofinv-HostedOnCPNotOpen-R09 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-HostedOnCPNotOpen-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-HostedOnCPNotOpen-R10 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The of R11 does not hold.
open Proofinv-HostedOnCPNotOpen-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The of R11 holds.
open Proofinv-HostedOnCPNotOpen-R11 .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-HostedOnCPNotOpen-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnCPNotOpen(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnCPNotOpen-R12 .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************
--> Proof of inv-HostedOnRQNotWaiting .
-->  eq inv-HostedOnRQNotWaiting(< SetND,SetCP,SetRQ,SetRL,MP >)
-->     = HostedOnRQInState(SetRQ,(unbound ready)) .
--> *******************************************************************************

--> ***************************
--> (5) init(S) implies inv(S).
--> ***************************
module! Proofinv-HostedOnRQNotWaiting-init {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  pred lemma : SetOfRequirement
  eq lemma(SetRQ:SetOfRequirement)
     = allRQInStates(SetRQ,unbound) 
       implies HostedOnRQInState(SetRQ,(unbound ready)) .
}
--> Proof of lemma.
--> Base Case: SetRQ is empty.
open Proofinv-HostedOnRQNotWaiting-init .
  eq sRQ = empRQ .
  red lemma(sRQ) .
close
--> Induction Case: SetRQ has a requirement.
--> Case 1:
--> (1-1) It is unbound.
open Proofinv-HostedOnRQNotWaiting-init .
  eq sRQ = (req(trl,idRQ,unbound,idND) sRQ') .
  red lemma(sRQ') implies lemma(sRQ) .
close
--> Case 2:
--> (1-2) It is waiting.
open Proofinv-HostedOnRQNotWaiting-init .
  eq sRQ = (req(trl,idRQ,waiting,idND) sRQ') .
  red lemma(sRQ') implies lemma(sRQ) .
close
--> Case 3:
--> (1-3) It is ready.
open Proofinv-HostedOnRQNotWaiting-init .
  eq sRQ = (req(trl,idRQ,ready,idND) sRQ') .
  red lemma(sRQ') implies lemma(sRQ) .
close
--> Proof of initinv.
open Proofinv-HostedOnRQNotWaiting-init .
  red lemma(sRQ) implies initinv(< sND,sCP,sRQ,sRL,mp >) .
close

--> ***************************
--> (6) inv(S) implies inv(SS).
--> ***************************
--> *************************************************************************
--> ctrans [R01]: < (node(TND,IDND,initial) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->	      if allRQOfNDInStates(filterRQ(SetRQ,hostedOn),IDND,ready) .
--> *************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R01 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R01 does not hold.
open Proofinv-HostedOnRQNotWaiting-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = false .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R01 holds.
open Proofinv-HostedOnRQNotWaiting-R01 .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) = true .
  red invinv(< (node(tnd,idND,initial) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************
--> ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->            => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> *************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R02 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R02 does not hold.
open Proofinv-HostedOnRQNotWaiting-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R02 holds.
open Proofinv-HostedOnRQNotWaiting-R02 .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red invinv(< (node(tnd,idND,created)  sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ************************************************************************************
--> ctrans [R03]: < SetND, (cap(hostedOn,IDCP,closed,   IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(hostedOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R03 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-HostedOnRQNotWaiting-R03 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-HostedOnRQNotWaiting-R03 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(hostedOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ***************************************************************************************************
--> trans [R04]: < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,unbound,IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(hostedOn,IDCP,available,IDND1) SetCP), 
-->  	       	(req(hostedOn,IDRQ,ready,   IDND2) SetRQ), (rel(hostedOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ***************************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R04 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnRQNotWaiting-R04 .
  red invinv(< sND, (cap(hostedOn,idCP,available,idND1) sCP), 
  	       (req(hostedOn,idRQ,unbound,idND2) sRQ), (rel(hostedOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> **********************************************************************************
--> ctrans [R05]: < SetND, (cap(dependsOn,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,open,  IDND) SetCP), SetRQ, SetRL, MP >
-->	     if isCreated(state(getNode(SetND,IDND))) .
--> **********************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R05 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R03 does not hold.
open Proofinv-HostedOnRQNotWaiting-R05 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R03 holds.
open Proofinv-HostedOnRQNotWaiting-R05 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(dependsOn,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> *************************************************************************************
--> ctrans [R06]: < SetND, (cap(dependsOn,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(dependsOn,IDCP,available,IDND) SetCP), SetRQ, SetRL, MP >
-->	     if state(getNode(SetND,IDND)) = started .
--> *************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R06 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R06 does not hold.
open Proofinv-HostedOnRQNotWaiting-R06 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> (1-2) The condition of R06 holds.
open Proofinv-HostedOnRQNotWaiting-R06 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(dependsOn,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************
--> ctrans [R07]: < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->   	                   (req(dependsOn,IDRQ,unbound,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            => < SetND, (cap(dependsOn,IDCP,SCP,IDND1) SetCP), 
-->  	                   (req(dependsOn,IDRQ,waiting,IDND2) SetRQ),
-->                        (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->            if state(getNode(SetND,IDND2)) = created and isActivated(SCP) .
--> **************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R07 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) isActivated(scp) does not hold.
open Proofinv-HostedOnRQNotWaiting-R07 .
  eq isActivated(scp) = false .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) isActivated(scp) holds,
--> (2-1) state(getNode(sND,idND2)) is not created.
open Proofinv-HostedOnRQNotWaiting-R07 .
  eq (state(getNode(sND,idND2)) = created) = false .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) isActivated(scp) holds,
--> (2-2) state(getNode(sND,idND2)) is created.
open Proofinv-HostedOnRQNotWaiting-R07 .
  eq state(getNode(sND,idND2)) = created .
  eq isActivated(scp) = true .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,unbound,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> trans [R08]: < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	          (req(dependsOn,IDRQ,waiting,IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP >
-->           => < SetND, (cap(dependsOn,IDCP,available,IDND1) SetCP), 
-->  	       	  (req(dependsOn,IDRQ,ready,  IDND2) SetRQ), (rel(dependsOn,IDRL,IDCP,IDRQ) SetRL), MP > .
--> ******************************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R08 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnRQNotWaiting-R08 .
  red invinv(< sND, (cap(dependsOn,idCP,scp,idND1) sCP), 
   	       (req(dependsOn,idRQ,waiting,idND2) sRQ), (rel(dependsOn,idRL,idCP,idRQ) sRL), mp >,
             SS:State,CC:Bool) .
close

--> ***********************************************************************************
--> ctrans [R09]: < SetND, (cap(connectsTo,IDCP,closed,IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,open,  IDND) SetCP), SetRQ, SetRL, 
-->	       	 (opMsg(IDCP) MP) >
-->	    if isCreated(state(getNode(SetND,IDND))) .
--> ***********************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R09 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The condition of R09 does not hold.
open Proofinv-HostedOnRQNotWaiting-R09 .
  eq isCreated(state(getNode(sND,idND))) = false .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R09 holds.
open Proofinv-HostedOnRQNotWaiting-R09 .
  eq isCreated(state(getNode(sND,idND))) = true .
  red invinv(< sND, (cap(connectsTo,idCP,closed,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> **************************************************************************************
--> ctrans [R10]: < SetND, (cap(connectsTo,IDCP,open,     IDND) SetCP), SetRQ, SetRL, MP >
-->            => < SetND, (cap(connectsTo,IDCP,available,IDND) SetCP), SetRQ, SetRL,
-->	       	  (avMsg(IDCP) MP) >
-->	     if state(getNode(SetND,IDND)) = started .
--> **************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R10 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> sND = (node(tnd,idND,snd) sND') because of wfs-allRQHaveND(S).
--> Case 1:
--> (1-1) The condition of R10 does not hold.
open Proofinv-HostedOnRQNotWaiting-R10 .
  eq (state(getNode(sND,idND)) = started) = false .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The condition of R10 holds.
open Proofinv-HostedOnRQNotWaiting-R10 .
  eq state(getNode(sND,idND)) = started .
  red invinv(< sND, (cap(connectsTo,idCP,open,idND) sCP), sRQ, sRL, mp >,SS:State,CC:Bool) .
close

--> ******************************************************************************************************
--> ctrans [R11]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,unbound,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (opMsg(IDCP) MP) >
-->            => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP >
--> 	     if state(getNode(SetND,IDND)) = created .
--> ******************************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R11 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
--> Case 1:
--> (1-1) The of R11 does not hold.
open Proofinv-HostedOnRQNotWaiting-R11 .
  eq (state(getNode(sND,idND)) = created) = false .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) The of R11 holds.
open Proofinv-HostedOnRQNotWaiting-R11 .
  eq (state(getNode(sND,idND)) = created) = true .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,unbound,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (opMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close

--> *******************************************************************************************************
--> trans [R12]: < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,waiting,IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), 
--> 		  (avMsg(IDCP) MP) >
-->           => < SetND, SetCP, 
--> 	       	  (req(connectsTo,IDRQ,ready,  IDND) SetRQ), (rel(connectsTo,IDRL,IDCP,IDRQ) SetRL), MP > .
--> *******************************************************************************************************
module! Proofinv-HostedOnRQNotWaiting-R12 {
  pr(ProofInv)
  eq invSS(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq invS(S:State) = invSS(S) .
}
open Proofinv-HostedOnRQNotWaiting-R12 .
  red invinv(< sND, sCP, 
   	       (req(connectsTo,idRQ,waiting,idND) sRQ), (rel(connectsTo,idRL,idCP,idRQ) sRL),
	       (avMsg(idCP) mp) >,
             SS:State,CC:Bool) .
close
