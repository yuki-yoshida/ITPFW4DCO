require ProofContCont Proof-contcont.cafe

-- As to rule R01, we have checked all possible cases, however,
-- here we will omit irrevant cases in which wfs(S) does not hold and thus contcont(S) holds.

--> **************************************************************************
-->  ctrans [R02]: < (node(TND,IDND,created) SetND), SetCP, SetRQ, SetRL, MP >
-->             => < (node(TND,IDND,started) SetND), SetCP, SetRQ, SetRL, MP > 
-->	      if allRQOfNDInStates(SetRQ,IDND,ready) .
--> **************************************************************************
--> Rule R02 starts a node, so the next state may be final.
--> Case 1: The condition of R02 does not hold in S, otherwise
--> Case 2: The next state (SS) is final,
-->  otherwise there is at least one node (N1) that is not started.
--> Case 3: N1 is initial.
-->         Cyclic Dependency Theorem allows us to assume that
-->         DDSR01 of the N1 does not include initial nodes.
--> Case 3: The condition of R01 holds for N1, otherwise
--> Case 4-9: There is at least one hostedOn requirement (R1) of N1 that is not ready.
-->  #   R1       C1        N2
-->  4   unbound  closed    initial -> a contradiction
-->  5/6 unbound  closed    created -> R03 is applicable
-->  7   unbound  closed    started -> R03 is applicable
-->  8   unbound  open      *       -> not reachable
-->  9   unbound  available *       -> R04 is applicable
-->  10  waiting  *         *       -> not reachbale
--> Case 11: N1 is created.
-->         Cyclic Dependency Theorem allows us to assume that
-->         DDSR02 of the N1 does not include created nodes.
--> Case 11: The condition of R02 holds for N1, otherwise
--> Case 12-43: There is at least one requirement (R1) of N1 that is not ready.
-->  #     R1                 C1        N2
-->  12    hostedOn&unbound   *                 -> not reachable
-->  13    hostedOn&waiting   *                 -> not reachable
-->  *     dependsOn&unbound  closed    initial -> Case 44
-->  14    dependsOn&unbound  closed    created -> a contradiction
-->  15/16 dependsOn&unbound  closed    started -> R05 is applicable
-->  17/18 dependsOn&unbound  open      initial -> not reachable
-->  19    dependsOn&unbound  open      created -> a contradiction
-->  20    dependsOn&unbound  open      started -> R07 is applicable
-->  21    dependsOn&unbound  available *       -> R07 is applicable
-->  22    dependsOn&waiting  closed    *       -> not rechable
-->  23/24 dependsOn&waiting  open      initial -> not rechable
-->  25    dependsOn&waiting  open      created -> a contradiction
-->  26    dependsOn&waiting  open      started -> R06 is applicable
-->  27    dependsOn&waiting  available *       -> R08 is applicable
-->  *     connectsTo&unbound closed    initial -> Case 45
-->  28    connectsTo&unbound closed    created -> a contradiction
-->  29/30 connectsTo&unbound closed    started -> R09 is applicable
-->  31/32 connectsTo&unbound open      initial -> not reachable
-->  33    connectsTo&unbound open      created -> a contradiction
-->  34    connectsTo&unbound open      started -> R11 is applicable
-->  35/36 connectsTo&unbound available *       -> R11 is applicable
-->  37    connectsTo&waiting closed    *       -> not rechable
-->  38/39 connectsTo&waiting open      initial -> not rechable
-->  40    connectsTo&waiting open      created -> a contradiction
-->  41    connectsTo&waiting open      started -> R10 is applicable
-->  42/43 connectsTo&waiting available *       -> R12 is applicable
-->  Case 44: N2 is initial.
-->         Cyclic Dependency Theorem allows us to assume that 
-->         DDSR01 of the N2 does not include initial nodes.
-->  Case 45: N2 is initial.
-->         Cyclic Dependency Theorem allows us to assume that
-->         DDSR01 of the N2 does not include initial nodes.

--> Case 1:
--> (1-1) allRQOfNDInStates(sRQ,idND,ready) does not hold.
--> In this case, no rule is applicable.
open ProofContCont .
  eq allRQOfNDInStates(sRQ,idND,ready) = false .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 2:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-1) allNDInStates(sND,started) holds.
--> In this case, the next state is finail
open ProofContCont .
  eq allNDInStates(sND,started) = true .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 3:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial.
-->       Cyclic Dependency Theorem allows us to assume that DDSR01(N1,S) does not include initial nodes.
-->       i.e.  sND = (node(tnd',idND1,initial) sND') .
--> (4-1) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND,ready) holds.
--> In this case, Rule R01 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) = true .
  eq sND = (node(tnd',idND1,initial) sND') .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 4:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial.
--> This case will be rejected by the constraint that DDSR01(N1,S) does not include initial nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(hostedOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red allNDInStates(DDSR01(node(tnd',idND1,initial),< sND, sCP, sRQ, sRL, mp >),(created started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 5:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> (8-1) allRQOfNDInStates(sRQ',idND2,ready) does not hold.
--> In this case, Rule R03 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(hostedOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 6:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> (8-2) allRQOfNDInStates(sRQ',idND2,ready) holds.
--> In this case, Rule R03 and R02 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(hostedOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 7:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started.
--> In this case, Rule R03 can be applied to SS.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,started) sND'') .
  eq sCP = (cap(hostedOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 8:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open.
--> This case will be rejected by inv-HostedOnCPNotOpen(S) .
open ProofContCont .
  eq inv(S:State) = inv-HostedOnCPNotOpen(S) .
  eq sCP = (cap(hostedOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 9:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a hostedOn relationship of idRQ, i.e. sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a hostedOn capability of idRL, i.e. sCP = (cap(hostedOn,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available.
--> In this case, Rule R04 can be applied to SS.
open ProofContCont .
  eq sCP = (cap(hostedOn,idCP,available,idND2) sCP') .
  eq sRL = (rel(hostedOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 10:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-1) N1 is initial,
--> (4-2) allRQOfNDInStates(filterRQ(sRQ,hostedOn),idND1,ready) does not hold, which means
-->       there is at least one HostedOn requirement of N1 which is not ready, 
--> (5-2) it is waiting, i.e., sRQ = (req(hostedOn,idRQ,waiting,idND1) sRQ').
--> This case will be rejected by inv-HostedOnRQNotWaiting(S) .
open ProofContCont .
  eq inv(S:State) = inv-HostedOnRQNotWaiting(S) .
  eq sRQ = (req(hostedOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,initial) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 11:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 N1 which is not started,
--> (3-2) N1 is created.
-->       Cyclic Dependency Theorem allows us to assume that DDSR02(N1,S) does not include created nodes.
-->       i.e.  sND = (node(tnd',idND1,created) sND') .
--> (9-1) allRQOfNDInStates(sRQ,idND1,ready) holds.
--> In this case, Rule R02 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ,idND1,ready) = true .
  eq sND = (node(tnd',idND1,created) sND') .
  eq allRQOfNDInStates(sRQ,idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 12:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-1) it is a hostedOn requirement,
--> (11-1) it is unbound, i.e., sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ').
--> This case will be rejected by inv-ifNDCreatedThenHostedOnRQReady(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq sRQ = (req(hostedOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 13:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-1) it is a hostedOn requirement,
--> (11-2) it is waiting, i.e., sRQ = (req(hostedOn,idRQ,waiting,idND1) sRQ').
--> This case will be rejected by inv-ifNDCreatedThenHostedOnRQReady(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDCreatedThenHostedOnRQReady(S) .
  eq sRQ = (req(hostedOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 14:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(dependsOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 15:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started,
--> (8-1) allRQOfNDInStates(sRQ',idND2,ready) does not hold.
--> In this case, Rule R05 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(dependsOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 16:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started,
--> (8-2) allRQOfNDInStates(sRQ',idND2,ready) holds.
--> In this case, Rule R02 and R05 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(dependsOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 17:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-1) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) holds.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 18:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-2) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) does not hold.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 19:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 20:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started.
--> In this case, Rule R07 can be applied to SS.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,started) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 21:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available.
--> In this case, Rule R07 can be applied to SS.
open ProofContCont .
  eq sCP = (cap(dependsOn,idCP,available,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 22:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed.
--> This case will be rejected by inv-ifCPClosedThenRQUnbound(S).
open ProofContCont .
  eq inv(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq sCP = (cap(dependsOn,idCP,closed,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 23:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-1) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) holds.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 24:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-2) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) does not hold.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 25:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 26:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started.
--> In this case, Rule R06 can be applied to SS.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,started) sND'') .
  eq sCP = (cap(dependsOn,idCP,open,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 27:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available.
--> In this case, Rule R08 can be applied to SS.
open ProofContCont .
  eq sCP = (cap(dependsOn,idCP,available,idND2) sCP') .
  eq sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(dependsOn,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 28:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(connectsTo,idCP,closed,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 29:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started,
--> (8-1) allRQOfNDInStates(sRQ',idND2,ready) does not hold.
--> In this case, Rule R09 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(connectsTo,idCP,closed,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 30:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started,
--> (8-2) allRQOfNDInStates(sRQ',idND2,ready) holds.
--> In this case, Rule R02 and R09 can be applied to SS.
open ProofContCont .
  eq allRQOfNDInStates(sRQ',idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(connectsTo,idCP,closed,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 31:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-1) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) holds.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 32:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-2) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) does not hold.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 33:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 34:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started.
--> In this case, Rule R11 can be applied to SS.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,started) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 35:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available,
--> (14-1) There is not opMsg(idCP) in mp.
--> This case will be rejected by inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S).
open ProofContCont .
  eq inv(S:State) = inv-ifConnectsToCPAvailableThenRQWaitingReadyOrOpenMsg(S) .
  eq (opMsg(idCP) \in mp) = false .
  eq sCP = (cap(connectsTo,idCP,available,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 36:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available,
--> (14-2) There is opMsg(idCP) in mp.
--> In this case, Rule R11 can be applied to SS.
open ProofContCont .
  eq mp = (opMsg(idCP) mp') .
  eq sCP = (cap(connectsTo,idCP,available,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 37:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed.
--> This case will be rejected by inv-ifCPClosedThenRQUnbound(S).
open ProofContCont .
  eq inv(S:State) = inv-ifCPClosedThenRQUnbound(S) .
  eq sCP = (cap(connectsTo,idCP,closed,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 38:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-1) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) holds.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = true .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 39:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial,
--> (13-2) allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) does not hold.
--> This case will be rejected by inv-inv-ifNDInitialThenCPClosed(S) .
open ProofContCont .
  eq inv(S:State) = inv-ifNDInitialThenCPClosed(S) .
  eq allRQOfNDInStates(filterRQ(sRQ',hostedOn),idND2,ready) = false .
  eq sND' = (node(tnd'',idND2,initial) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 40:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-2) N2 is created.
--> This case will be rejected by the constraint that DDSR02(N1,S) does not include created nodes.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,created) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red allNDInStates(DDSR02(node(tnd',idND1,created),< sND, sCP, sRQ, sRL, mp >),(initial started)) = false .
--  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 41:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-2) SCP is open, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-3) N2 is started.
--> In this case, Rule R10 can be applied to SS.
open ProofContCont .
  eq sND' = (node(tnd'',idND2,started) sND'') .
  eq sCP = (cap(connectsTo,idCP,open,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 42:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available.
--> (15-1) There is not anMsg(idCP) in mp.
--> This case will be rejected by inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S).
open ProofContCont .
  eq inv(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq (avMsg(idCP) \in mp) = false .
  eq sCP = (cap(connectsTo,idCP,available,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 43:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-2) it is waiting, i.e., sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-3) SCP is available.
--> (15-2) There is anMsg(idCP) in mp.
--> In this case, Rule R12 can be applied to SS.
open ProofContCont .
  eq inv(S:State) = inv-ifConnectsToCPAvailableThenRQReadyOrAvailableMsg(S) .
  eq mp = (avMsg(idCP) \in mp') .
  eq sCP = (cap(connectsTo,idCP,available,idND2) sCP') .
  eq sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL') .
  eq sRQ = (req(connectsTo,idRQ,waiting,idND1) sRQ') .
  eq sND = (node(tnd',idND1,created) sND') .
  red allRQOfNDInStates(sRQ,idND,ready)
      implies allRQOfNDInStates(sRQ',idND,ready) .
  eq allRQOfNDInStates(sRQ',idND,ready) = true .
  red contcont(< (node(tnd,idND,created) sND), sCP, sRQ, sRL, mp >,SS:State,CC:Bool) .
close
--> Case 44:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-2) it is a dependsOn requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(dependsOn,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a dependsOn relationship of idRQ, i.e. sRL = (rel(dependsOn,idRL,idCP,idRQ) sRL'),
-->       sCP has a dependsOn capability of idRL, i.e. sCP = (cap(dependsOn,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial.
-->       Cyclic Dependency Theorem ensures that
-->       there is a node X which is initial and DDSR01(X,S) does not include initial nodes
-->       and so this case is just same as Case 3-9.
--> Case 45:
--> (1-2) allRQOfNDInStates(sRQ,idND,ready) holds,
--> (2-2) allNDInStates(sND,started) does not hold, which means
-->       sND has a node N1 which is not started,
--> (3-2) N1 is created,
--> (9-2) allRQOfNDInStates(sRQ,idND1,ready) does not hold, which means
-->       there is at least one requirement of N1 which is not ready, 
--> (10-3) it is a connectsTo requirement,
--> (12-1) it is unbound, i.e., sRQ = (req(connectsTo,idRQ,unbound,idND1) sRQ'), then
-->       sRL has a connectsTo relationship of idRQ, i.e. sRL = (rel(connectsTo,idRL,idCP,idRQ) sRL'),
-->       sCP has a connectsTo capability of idRL, i.e. sCP = (cap(connectsTo,idCP,SCP,idND2) sCP'),
--> (6-1) SCP is closed, then
-->       sND' has a node N2 of idND2, i.e., sND' = (node(tnd'',idND2,snd) sND''),
--> (7-1) N2 is initial.
-->       Cyclic Dependency Theorem ensures that
-->       there is a node X which is initial and DDSR01(X,S) does not include initial nodes.,
-->       and so this case is just same as Case 3-9.
