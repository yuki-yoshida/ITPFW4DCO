require Template Template.cafe

-- No Cycle Lemma:
-- if noCycleC(S) and some object O in S is in a local state LS
-- then there is some object X in S that is also in LS
--      but does not depend on any other objects in LS.
-- eq noCycleLemma(O,S,LS)
--   = (noCycleC(S) and O in getAllObjC(S) and O in LS) 
--     implies someNoDependObj(getAllObjC(S), LS, S) .
module CYCLELEMMA {
  protecting(CYCLEPRED)
  
  op getNoDependObj : SetOfObject LocalState State -> Object
  pred noCycleLemma : Object State LocalState
  pred cycle-lemma1 : Object LocalState State
  pred cycle-lemma2 : Object LocalState State

  vars O O' : Object
  vars OS OS' OS0 OS0' : SetOfObject
  var LS : LocalState
  var S : State

  -- Assuming subset(DDSC(O,S),getAllObjC(S)) .
  eq [DDSCinS :nonexec]:
    subset(DDSC(O,S),getAllObjC(S)) = true .

  ceq getNoDependObj((O OS),LS,S) 
    = (if isNoDepend(O,LS,S) then O else getNoDependObj(DDSC(O,S),LS,S) fi)
    if O in LS .

  ceq getNoDependObj((O OS),LS,S) 
    = getNoDependObj(OS,LS,S)
    if not (O in LS) .

  -- Lemmas to be proved
  eq noCycleLemma(O,S,LS)
    = (noCycleC(S) and O in getAllObjC(S) and O in LS) 
      implies someNoDependObj(getAllObjC(S), LS, S) .

  eq cycle-lemma1(O,LS,S)
    = (noCycleC(S) and 
       O in getAllObjC(S) and 
       O in LS) implies 
      isNoDepend(getNoDependObj(O,LS,S),LS,S) .

  eq cycle-lemma2(O,LS,S)
    = (noCycleC(S) and 
       O in getAllObjC(S) and 
       O in LS) implies 
      getNoDependObj(O,LS,S) in getAllObjC(S) .

  -- Set Axiom
  ceq [OinOS :nonexec]:
      (O in OS) = true
   if subset((O OS'),OS) .

  [OLSS] op t : Object LocalState State -> OLSS {constr} .
  pred _<wf_ : OLSS OLSS .

  -- Define <wf for cycle-lemma1
  ceq ( t(O',LS,S) <wf t(O,LS,S) ) = true
     if O' in DDSC(O,S) .

  ops o o' : -> Object .
  ops os0 os os' : -> SetOfObject .
  op ls : -> LocalState .
  op s : -> State .
}

--> Proof of cycle-lemma1
-->  eq cycle-lemma1(O,LS,S)
-->    = (noCycleC(S) and 
-->       O in getAllObjC(S) and 
-->       O in LS) implies 
-->      isNoDepend(getNoDependObj(O,LS,S),LS,S) .
open CYCLELEMMA .

  -- Induction Hypothesis
  ceq [cycle-lemma1-IH :nonexec]:
    cycle-lemma1(O,LS,S) = true
    if t(O,LS,S) <wf t(o,ls,s) .

:goal { eq cycle-lemma1(o,ls,s) = true . }
:def OinScsp = :csp {
  eq (o in getAllObjC(s)) = false .
  eq getAllObjC(s) = (o os) .
}
:apply (OinScsp rd-)
:def OinLSctf = :ctf {
  eq (o in ls) = true .
}
:apply (OinLSctf rd-)
:def allNScsp = :csp {
  eq allObjNotInState(DDSC(o,s),ls) = true .
  eq DDSC(o,s) = (o' os') .
}
:apply (allNScsp rd-)
:csp {
  eq (o' in ls) = true .
}
:def OisO'ctf = :ctf {
  eq (o' in o) = true .
}
:apply (OisO'ctf rd-)
:init as DDSCinS-in [DDSCinS]
  by {O:Object <- o;
      S:State <- s; }
:init as OinOS-in [OinOS]
  by {O:Object <- o';
      OS:SetOfObject <- getAllObjC(s);
      OS':SetOfObject <- os'; }
:init as cycle-lemma1-IH-in [cycle-lemma1-IH]
  by {O:Object <- o'; 
      LS:LocalState <- ls; 
      S:State <- s; }
:apply (rd-)
--> Proof of cycle-lemma1 done
-->
show proof
close

--> Proof of cycle-lemma2
-->  eq cycle-lemma2(O,LS,S)
-->    = (noCycleC(S) and 
-->       O in getAllObjC(S) and 
-->       O in LS) implies 
-->      getNoDependObj(O,LS,S) in getAllObjC(S) .
open CYCLELEMMA .

  -- Induction Hypothesis
  ceq [cycle-lemma2-IH :nonexec]:
    cycle-lemma2(O,LS,S) = true
    if t(O,LS,S) <wf t(o,ls,s) .

:goal { eq cycle-lemma2(o,ls,s) = true . }
:def OinScsp = :csp {
  eq (o in getAllObjC(s)) = false .
  eq getAllObjC(s) = (o os) .
}
:apply (OinScsp rd-)
:def OinLSctf = :ctf {
  eq (o in ls) = true .
}
:apply (OinLSctf rd-)
:def allNScsp = :csp {
  eq allObjNotInState(DDSC(o,s),ls) = true .
  eq DDSC(o,s) = (o' os') .
}
:apply (allNScsp rd-)
:csp {
  eq (o' in ls) = true .
}
:def OisO'ctf = :ctf {
  eq (o' in o) = true .
}
:apply (OisO'ctf rd-)
:init as DDSCinS-in [DDSCinS]
  by {O:Object <- o;
      S:State <- s; }
:init as OinOS-in [OinOS]
  by {O:Object <- o';
      OS:SetOfObject <- getAllObjC(s);
      OS':SetOfObject <- os'; }
:init as cycle-lemma2-IH-in [cycle-lemma2-IH]
  by {O:Object <- o'; 
      LS:LocalState <- ls; 
      S:State <- s; }
:apply (rd-)
--> Proof of cycle-lemma2 done
-->
show proof
close

--> Proof of noCycleLemma
-->  eq noCycleLemma(O,S,LS)
-->    = (noCycleC(S) and O in getAllObjC(S) and O in LS)
-->      implies someNoDependObj(getAllObjC(S), LS, S) .
open CYCLELEMMA .

  -- sublemma
  -- eq cycle-lemma1(O,LS,S)
  --   = (noCycleC(S) and 
  --      O in getAllObjC(S) and 
  --      O in LS) implies 
  --     isNoDepend(getNoDependObj(O,LS,S),LS,S) .
  ceq [cycle-lemma1 :nonexec]:
    isNoDepend(getNoDependObj(O,LS,S),LS,S) = true
    if (noCycleC(S) and 
        O in getAllObjC(S) and 
        O in LS) .

  -- eq cycle-lemma2(O,LS,S)
  --   = (noCycleC(S) and 
  --      O in getAllObjC(S) and 
  --      O in LS) implies 
  --     getNoDependObj(O,LS,S) in getAllObjC(S) .
  ceq [cycle-lemma2 :nonexec]:
    (getNoDependObj(O,LS,S) in getAllObjC(S)) = true
    if noCycleC(S) and O in getAllObjC(S) and O in LS .

:goal { eq noCycleLemma(o,s,ls) = true . }
:def noCyclectf = :ctf {
  eq noCycleC(s) = true .
}
:apply (noCyclectf rd-)
:def OinScsp = :csp {
  eq (o in getAllObjC(s)) = false .
  eq getAllObjC(s) = (o os) .
}
:apply (OinScsp rd-)
:def OinLSctf = :ctf {
  eq (o in ls) = true .
}
:apply (OinLSctf rd-)
:def allNSctf = :ctf {
  eq allObjNotInState(DDSC(o,s),ls) = true .
}
:apply (allNSctf rd-)
:def getNDisOcsp = :csp {
  eq getNoDependObj(DDSC(o, s), ls, s) in (o os) = false .
  eq (o os) = (o getNoDependObj(DDSC(o,s),ls,s) os') .
}
:apply (getNDisOcsp)
-- 1-2-1-2-1
:init as cycle-lemma2-in [cycle-lemma2]
  by {O:Object <- o;
      LS:LocalState <- ls;
      S:State <- s; }
:apply (rd-)
-- 1-2-1-2-2
:init as cycle-lemma1-in [cycle-lemma1]
  by {O:Object <- o;
      LS:LocalState <- ls;
      S:State <- s; }
:apply (rd-)
--> Proof of noCycleLemma done
-->
show proof
close 

--> Totally 3 goals should be proved
