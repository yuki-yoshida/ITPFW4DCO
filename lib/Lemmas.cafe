require Template Template.cafe

provide Lemmas

module CONVLEMMAS {
  protecting(PROOFBASE)
  
  -- If init(S) implies final(S) = false and
  -- both of initinv(S) and invcont(S) holds for any state S,
  -- then initcont(S) and contcont(S) also hold for any S.

  var S : State
  -- Assuming init(S) implies final(S) = false:
  ceq init(S) = false if final(S) .
  -- Assuming initinv(S):
  ceq init(S) = false if inv(S) = false .
  -- Assuming invcont(S):
  ceq cont(S) = true if inv(S) and final(S) = false .

  op s : -> State .

}

select CONVLEMMAS .
:goal { eq initcont(s) = true . }
:def invctf = :ctf {
  eq inv(s) = true .
}
:def finalctf = :ctf {
  eq final(s) = true .
}
:apply (invctf finalctf rd-)
show proof

select CONVLEMMAS .
:goal { eq contcont(s) = true . }
:def invctf = :ctf {
  eq inv(s) = true .
}
:def finalctf = :ctf {
  eq final(s) = true .
}
:apply (invctf finalctf rd-)
show proof

module BOOLLEMMAS {
  pred bool-lemma1 : Bool Bool .
  -- (X implies Y) can be written as an equation, eq (X and Y) = X .
  eq bool-lemma1(X:Bool,Y:Bool)
     = (X implies Y) iff ((X and Y) = X) .
  ops x y : -> Bool .
}

select BOOLLEMMAS
:goal {
  eq bool-lemma1(x,y) = true .
}
:def ctf-1 = :ctf {
  eq x = true .
}
:def ctf-2 = :ctf {
  eq y = true .
}
:apply (ctf-1 ctf-2 rd-)
show proof

module SETLEMMAS {
  protecting(-ALLOBJPRED1)

  op _ in _ : Object SetOfObject -> Bool
  op subset : SetOfObject SetOfObject -> Bool

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  -- Axioms
  -- SET Lemmas are valid only when instantiating with the following properties.
  vars O O1 : Object
  vars S S' S1 S2 : SetOfObject
  var A : Arg
  eq (empObj = (O S)) = false .
  eq ((O S) = (O S')) = (S = S') .
  eq O in empObj = false .
  eq O in (O S) = true .
  ceq O in (O1 S) = O in S if not(O = O1) .
  eq subset(empObj,S) = true .
  eq subset(S,empObj) = (S = empObj) .
  eq subset(S,S) = true .
  ceq subset((O S),S') = subset(S,S') if (O in S') .
  ceq subset((O S),S') = false if not (O in S') .
  eq subset(S,(O S)) = true .

  -- Skolem functions
  -- A set may include a specific element
  op e : SetOfObject -> Object {strat (0)} .
  -- and there is a rest of the set
  op s' : SetOfObject -> SetOfObject {strat (0)} .

  pred set-lemma00 : SetOfObject Object
  -- When O is included in S, there exist some S' such that S = (O S').
  eq set-lemma00(S, O)
     = (O in S) implies (S = (O s'(S))) .

  pred set-lemma01 : SetOfObject Arg
  -- When allObjP(S,A) does not hold, there exist some E and S' such that S = (E S') and p(E,A) does not hold.
  eq set-lemma01(S, A)
     = not allObjP(S,A) implies (S = (e(S) s'(S))) and not p(e(S),A) .

  pred set-lemma02 : SetOfObject Arg
  -- When onlyOneObjP(S,A) holds, there exist some E and S' such that S = (E S') and p(E,A) holds.
  eq set-lemma02(S, A)
     = onlyOneObjP(S,A) implies (S = (e(S) s'(S))) and p(e(S),A) and allObjNotP(s'(S),A).

  pred set-lemma03 : SetOfObject Arg
  -- someObjP(S,A) if and only if not allObjNotP(S,A).
  eq set-lemma03(S, A)
     = someObjP(S,A) iff not allObjNotP(S,A) .

  pred set-lemma04 : SetOfObject Object Arg
  -- When p(O,A) holds and O is included in S, then someObjP(S,A) holds.
  eq set-lemma04(S, O, A)
     = p(O,A) and (O in S) implies someObjP(S,A) .

  pred set-lemma05 : SetOfObject Arg
  -- When onlyOneObjP(S,A) holds, someObjP(S,A) also holds.
  eq set-lemma05(S, A)
     = onlyOneObjP(S,A) implies someObjP(S,A) .

  pred set-lemma06 : Object SetOfObject Arg
  -- When p(O,A) holds, allObjP((O S),A) is equivalent to allObjP(S,A).
  eq set-lemma06(O, S, A)
     = allObjP((O S),A) implies allObjP(S,A) .

  pred set-lemma07 : Object Object SetOfObject
  -- When O in S and O1 in O holds, O1 in S also holds.
  eq set-lemma07(O,O1,S)
     = O1 in O implies O1 in S 
     when O in S .
  
  pred set-lemma08 : Object SetOfObject SetOfObject
  -- When O in S holds, O in (S S') also holds.
  eq set-lemma08(O,S,S')
     = O in S implies O in (S S') .

  pred set-lemma09 : Object SetOfObject SetOfObject
  -- When subset(S,S') holds, subset(S,(O S')) also holds.
  eq set-lemma09(O,S,S')
     = subset(S,S') implies subset(S,(O S')) .

  pred set-lemma10 : SetOfObject SetOfObject SetOfObject
  -- When subset(S1,S) and subset(S2,S) holds, subset((S1 S2),S) also holds.
  eq set-lemma10(S,S1,S2)
     = subset(S2,S) implies subset((S1 S2),S) 
     when subset(S1,S) .

  pred set-lemma11 : SetOfObject SetOfObject SetOfObject
  -- When subset(S,S1) holds, subset(S,(S1 S2)) also holds. 
  eq set-lemma11(S,S1,S2)
     = subset(S,S1) implies subset(S,(S1 S2)) . 

  pred set-lemma12 : SetOfObject 
  -- subset(S,S)) alway holds. 
  eq set-lemma12(S)
     = subset(S,S) .

  pred set-lemma13 : SetOfObject SetOfObject SetOfObject
  -- When subset(S1,S2) and subset(S2,S) holds, subset(S1,S) also holds.
  eq set-lemma13(S,S1,S2)
     = subset(S1,S2) implies subset(S1,S) 
     when subset(S2,S) .

  ops o o' o1 o2 : -> Object .
  ops s s1 s2 s2' : -> SetOfObject .
  op a : -> Arg .
}

--> *****************************************************************************
--> Prove that when O is included in S, there exist some S' such that S = (O S').
--> *****************************************************************************
--> case 1: Basic case, S is empty
select SETLEMMAS
:goal {
  eq set-lemma00(empObj,o) = true .
  eq set-lemma00(s,o) implies set-lemma00((o' s),o) = true .
}
:ctf {
  eq o = o' .
}
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- o' s;
  S':SetOfObject <- s;
}
:apply (rd-)  
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- (o' s);
  S':SetOfObject <- (o' s'(s));
}
:apply (rd-)  
show proof

--> *******************************************************************************************************************
--> Prove that when allObjP(S,A) does not hold there exist some E and S' such that S = (E S') and p(E,A) does not hold.
--> *******************************************************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma01(empObj,a) = true .
  eq set-lemma01(s,a) implies set-lemma01((o s),a) = true .
}
:ctf {
  eq p(o,a) = true .
}
:ctf {
  eq allObjP(s,a) = true .
}
:apply (rd-)
:init ( eq e(S:SetOfObject) = E:Object .) by {
  S:SetOfObject <- (o s);
  E:Object <- e(s);
}
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- (o s);
  S':SetOfObject <- (o s'(s));
}
:apply (rd-)
:init ( eq e(S:SetOfObject) = E:Object .) by {
  S:SetOfObject <- (o s);
  E:Object <- o;
}
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- (o s);
  S':SetOfObject <- s;
}
:apply (rd-)
show proof

--> *****************************************************************************************************************************
--> Prove that when onlyOneObjP(S,A) holds, there exist some E and S' such that S = (E S') and p(E,A) holds.
--> *****************************************************************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma02(empObj,a) = true .
  eq set-lemma02(s,a) implies set-lemma02((o s),a) = true .
}
:ctf {
  eq p(o,a) = true .
}
:init ( eq e(S:SetOfObject) = E:Object .) by {
  S:SetOfObject <- (o s);
  E:Object <- o;
}
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- (o s);
  S':SetOfObject <- s;
}
:apply (rd-)
:init ( eq e(S:SetOfObject) = E:Object .) by {
  S:SetOfObject <- (o s);
  E:Object <- e(s);
}
:init ( eq s'(S:SetOfObject) = S':SetOfObject .) by {
  S:SetOfObject <- (o s);
  S':SetOfObject <- (o s'(s));
}
:apply (rd-)
show proof

--> **************************************************
--> Prove that someObjP(S,A) iff not allObjNotP(S,A) .
--> **************************************************
select SETLEMMAS
:goal {
  eq set-lemma03(empObj,a) = true .
  eq set-lemma03(s,a) implies set-lemma03(o s,a) = true .
}
:apply (rd-)
show proof

--> ******************************************************************************
--> Prove that when p(O,A) holds and O is included in S, then someObjP(S,A) holds.
--> ******************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma04(empObj,o,a) = true .
  eq set-lemma04(s,o,a) implies set-lemma04(o' s,o,a) = true .
}
:def ctfo' = :ctf {
  eq o' = o .
}
:apply (ctfo' rd-)
show proof

--> *****************************************************************
--> Prove that when onlyOneObjP(S,A) holds, someObjP(S,A) also holds.
--> *****************************************************************
select SETLEMMAS
:goal {
  eq set-lemma05(empObj,a) = true .
  eq set-lemma05(s,a) implies set-lemma05((o s),a) = true .
}
:def ctfp = :ctf {
  eq p(o,a) = true .
}
:apply (ctfp rd-)
show proof

--> *****************************************************************************
--> Prove that when p(O,A) holds, allObjP((O S),A) is equivalent to allObjP(S,A).
--> *****************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma06(o,s,a) = true .
}
:def ctfp = :ctf {
  eq p(o,a) = true .
}
:apply (ctfp rd-)
show proof

--> *************************************************************
--> Prove that when O in S and O1 in O holds, O1 in S also holds.
--> *************************************************************
select SETLEMMAS
:goal {
  eq set-lemma07(o,o',s) = true .
}
:def ctfo' = :ctf {
  eq o' = o .
}
:apply (ctfo' rd-)
show proof

--> *****************************************************
--> Prove that when O in S holds, O in (S S') also holds.
--> *****************************************************
select SETLEMMAS
:goal {
  eq set-lemma08(o,empObj,s1) = true .
  eq set-lemma08(o,s,s1) implies set-lemma08(o,(o' s),s1) = true .
}
:def ctfo' = :ctf {
  eq o' = o .
}
:apply (ctfo' rd-)
show proof

--> ****************************************************************
--> Prove that when subset(S,S') holds, subset(S,(O S')) also holds.
--> ****************************************************************
select SETLEMMAS
:goal {
  eq set-lemma09(o,empObj,s2) = true .
  eq set-lemma09(o,s1,s2) implies set-lemma09(o,(o' s1),s2) = true .
}
:def ctfo' = :ctf {
  eq o' = o .
}
:apply (ctfo')
:def ctfoins2 = :ctf {
  eq (o in s2) = true . 
}
:apply (ctfoins2 rd-)
:def ctfo'ins2 = :ctf {
  eq (o' in s2) = true . 
}
:apply (ctfo'ins2 rd-)
show proof

--> **********************************************************************************
--> Prove that when subset(S1,S) and subset(S2,S) holds, subset((S1 S2),S) also holds.
--> **********************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma10(s,empObj,s2) = true .
  eq set-lemma10(s,s1,s2) implies set-lemma10(s,(o s1),s2) = true .
}
:def ctfo = :ctf {
  eq (o in s) = true . 
}
:apply (ctfo rd-)
show proof

--> ******************************************************************
--> Prove that when subset(S,S1) holds, subset(S,(S1 S2)) also holds. 
--> ******************************************************************
open SETLEMMAS .
-- Using set-lemma08
ceq [set-lemma08]:
   (O in (S S')) = true 
   if O in S .
:goal {
  eq set-lemma11(empObj,s1,s2) = true .
  eq set-lemma11(s,s1,s2) implies set-lemma11((o s),s1,s2) = true .
}
:def ctfo = :ctf {
  eq (o in s1) = true . 
}
:apply (ctfo rd-)
show proof
close

--> ************************************
--> Prove that subset(S,S) always holds.
--> ************************************
open SETLEMMAS .
-- Using set-lemma09
eq [set-lemma09]:
   (subset(S,S') and subset(S,(O S')))
  = subset(S,S') .
:goal {
  eq set-lemma12(empObj) = true .
  eq set-lemma12(s) implies set-lemma12(o s) = true .
}
:apply (rd-)
show proof
close

--> ******************************************************************************
--> Prove that when subset(S1,S2) and subset(S2,S) holds, subset(S1,S) also holds.
--> ******************************************************************************
select SETLEMMAS
:goal {
  eq set-lemma13(s,empObj,s2) = true .
  eq set-lemma13(s,s1,s2) implies set-lemma13(s,(o s1),s2) = true .
}
:def cspos2 = :csp {
  eq (o in s2) = false .
  eq s2 = (o s2') .
}
:apply (cspos2 rd-)
:def ctfos = :ctf {
  eq o in s = true . 
}
:apply (ctfos rd-)
show proof

module BASE-LEMMAS {
  including(-OBJECTBASE0-lemma)

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .


  var IDO : ObjID 
  vars O O' : Object
  var S_O : SetOfObject
  vars SO SO1 SO2 : ObjState
  var St_O : SetOfObjState
  var OT : ObjType
  vars Z Z1 Z2 : Object

  pred base-lemma01 : SetOfObject ObjID Object
  eq base-lemma01(S_O,IDO,O)
     = existObj(S_O,IDO) implies existObj((O S_O),IDO) .

  pred base-lemma02 : Object ObjID SetOfObject
  eq base-lemma02(O,IDO,S_O)
     = (id(O) = IDO) implies existObj((O S_O),IDO) .

  pred base-lemma03 : SetOfObject ObjState SetOfObjState
  eq base-lemma03(S_O, SO, St_O)
     = allObjInStates0(S_O,(SO St_O)) and #ObjInStates0(SO,S_O) = 0 
       implies allObjInStates0(S_O,St_O) .

  pred base-lemma04 : SetOfObject ObjType ObjState SetOfObjState
  eq base-lemma04(S_O,OT,SO,St_O)
     = allObjInStates0(S_O,SO) 
       implies allObjOfTypeInStates0(S_O,OT,St_O)
     when SO in St_O .

  pred base-lemma05 : SetOfObject ObjID
  eq base-lemma05(S_O,IDO)
     = getObject(S_O,IDO) = null
       when not existObj(S_O,IDO) .

  -- Using set-lemma07 for SetOfObjState
  ceq ((SO1 in SO2) and (SO1 in St_O))
     = (SO1 in SO2) 
     if (SO2 in St_O) . 

  -- Axiom of Nat
  eq (1 + N:Nat = 0) = false .

  -- Constants for Proofs.
  ops o o' o1 o2 : -> Object .
  op idO : -> ObjID
  ops setO setO' : -> SetOfObject
  op ot : -> ObjType
  op so : -> ObjState
  op setSO : -> SetOfObjState
}

select BASE-LEMMAS
:goal {
  eq base-lemma01(setO,idO,o) = true .
  eq base-lemma02(o,idO,setO) = true .
}
:apply (rd-)
show proof

--> *********************************************************************************
--> Prove that when allObjInStates0(S_O,(SO St_O)) and #ObjInStates0(SO,S_O) =0 holds, 
-->            allObjInStates0(S_O,St_O) also holds.
--> *********************************************************************************
select BASE-LEMMAS
:goal {
  eq base-lemma03(empObj,so,setSO) = true .
  eq base-lemma03(setO,so,setSO) implies base-lemma03((o setO),so,setSO) = true .
}
:def ctfso = :ctf {
  eq state(o) = so .
}
:apply (ctfso rd-)
show proof

--> ************************************************
--> Prove base-lemma04
-->     = allObjInStates0(S_O,SO) 
-->       implies allObjOfTypeInStates0(S_O,OT,St_O)
-->     when SO in St_O .
--> ************************************************
select BASE-LEMMAS
:goal {
  eq base-lemma04(empObj,ot,so,setSO) = true .
  eq base-lemma04(setO,ot,so,setSO) implies base-lemma04((o setO),ot,so,setSO) = true .
}
:def ctfot = :ctf {
  eq type(o) = ot .
}
:apply (ctfot rd-)
:def ctfso = :ctf {
  eq (so in setSO) = true .
}
:apply (ctfso rd-)
show proof

--> ********************************
--> Prove base-lemma05(S_O,IDO)
-->     = getObject(S_O,IDO) = null
-->     when not existObj(S_O,IDO) .
--> ********************************
select BASE-LEMMAS
:goal {
  eq base-lemma05(empObj,idO) = true .
  eq base-lemma05(setO,idO) implies base-lemma05((o setO),idO) = true .
}
:apply (rd-)
show proof

module M2O-LEMMAS {
  including(-OBJLINKMANY2ONE0-lemma)

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  var IDX : LObjID 
  vars X X' : LObject
  vars Z Z' : Object
  vars S_X S_X' S_X1 S_X2 : SetOfLObject
  vars S_Z S_Z' S_Z1 S_Z2 : SetOfObject
  vars SX SX1 : LObjState
  vars SZ SZ1 SZ2 : ObjState
  var St_X : SetOfLObjState
  var St_Z : SetOfObjState
  var OT : ObjType

  -- Axioms
  -- M2O Lemmas are valid only when instantiating with the following properties.
  eq X in empLObj = false .
  eq X in (X S_X) = true .
  ceq X in (X' S_X) = X in S_X if not(X = X') .
  eq ((X S_X) = empLObj) = false .

  eq Z in empObj = false .
  eq Z in (Z S_Z) = true .
  ceq Z in (Z' S_Z) = Z in S_Z if not(Z = Z') .
  eq ((Z S_Z) = empObj) = false .

  eq SX in SX1 = (SX = SX1) .
  eq SX in (SX St_X) = true .
  ceq SX in (SX1 St_X) = SX in St_X if not(SX = SX1) .

  eq SZ in empState = false .
  eq SZ in (SZ St_Z) = true .
  ceq SZ in (SZ1 St_Z) = SZ in St_Z if not(SZ = SZ1) .
  eq ((SZ St_Z) = empState) = false .

  eq subset(empLObj,S_X) = true .
  eq subset(S_X,empLObj) = (S_X = empLObj) .
  eq subset(S_X,S_X) = true .
  ceq subset((X S_X),S_X') = subset(S_X,S_X') if (X in S_X') .
  ceq subset((X S_X),S_X') = false if not (X in S_X') .
  eq subset(S_X,(X S_X)) = true .

  eq subset(empObj,S_Z) = true .
  eq subset(S_Z,empObj) = (S_Z = empObj) .
  eq subset(S_Z,S_Z) = true .
  ceq subset((Z S_Z),S_Z') = subset(S_Z,S_Z') if (Z in S_Z') .
  ceq subset((Z S_Z),S_Z') = false if not (Z in S_Z') .
  eq subset(S_Z,(Z S_Z)) = true .

  eq getLObject((X S_X),IDX)
     = if (id(X) = IDX) then X else getLObject(S_X,IDX) fi .

  pred hasID : LObject LObjID
  eq hasID(X,IDX) = id(X) = IDX .

  eq existLObj(empLObj,IDX)
     = false .
  eq existLObj((X S_X),IDX)
     = hasID(X,IDX) or existLObj(S_X,IDX) .

  eq allLObjInStates(empLObj, St_X) = true .
  eq allLObjInStates((X S_X), St_X)
     = (state(X) in St_X) and allLObjInStates(S_X, St_X) .

  eq allObjInStates(empObj, St_Z) = true .
  eq allObjInStates((Z S_Z), St_Z)
     = (state(Z) in St_Z) and allObjInStates(S_Z, St_Z) .

  -- Using set-lemma07 for SetOfObjState
  ceq [set-lemma07]:
    ((SZ1 in SZ2) and (SZ1 in St_Z)) = (SZ1 in SZ2)
    if (SZ2 in St_Z) . 

  -- Using set-lemma09 for SetOfLObject
  eq [set-lemma09]:
     (subset(S_X,S_X') and subset(S_X,(X S_X')))
     = subset(S_X,S_X') .

  -- Using set-lemma09, 10, and 12 for SetOfObject
  eq [set-lemma09&10&11]:
     (subset(S_Z1,S_Z2) and subset((S_Z1 S_Z),(Z S_Z2 S_Z)))
     = subset(S_Z1,S_Z2) .

  -- Using set-lemma10 and 12 for SetOfObject
  eq [set-lemma10&11]:
     (subset(S_Z1,S_Z2) and subset((S_Z1 S_Z),(S_Z2 S_Z)))
     = subset(S_Z1,S_Z2) .

  -- Using set-lemma11 for SetOfObject
  eq [set-lemma11]:
     (subset(S_Z,S_Z1) and subset(S_Z,(S_Z1 S_Z2)))
     = subset(S_Z,S_Z1) .

  -- Using set-lemma11 and 12 for SetOfObject
  eq [set-lemma11&12]:
     subset(S_Z,(S_Z S_Z1)) = true .

  pred m2o-lemma01 : LObjID SetOfObject ObjState SetOfObjState
  eq m2o-lemma01(IDX,S_Z,SZ,St_Z)
     = allObjInStates(S_Z,SZ) implies allZOfXInStates0(S_Z,IDX,St_Z) 
     when (SZ in St_Z) .

  pred m2o-lemma02 : LObjID SetOfObject ObjState ObjType SetOfObjState
  eq m2o-lemma02(IDX,S_Z,SZ,OT,St_Z)
     = allObjInStates(S_Z,SZ) implies allZOfTypeOfXInStates0(S_Z,OT,IDX,St_Z) 
     when (SZ in St_Z) .

  pred m2o-lemma03 : SetOfObject Object SetOfObjState
  eq m2o-lemma03(S_Z,Z,St_Z)
     = allZOfXInStates0(S_Z,link(Z),St_Z) implies (state(Z) in St_Z)
     when (Z in S_Z) .

  pred m2o-lemma04 : SetOfObject LObjID ObjState SetOfObjState .
  eq m2o-lemma04(S_Z,IDX,SZ,St_Z)
     = (getZsOfXInStates0(S_Z,IDX,SZ) = empObj)
       implies allZOfXInStates0(S_Z,IDX,St_Z) 
     when allZOfXInStates0(S_Z,IDX,(SZ St_Z)) .

  pred m2o-lemma05 : LObject LObject SetOfObject SetOfLObject
  eq m2o-lemma05(X,X',S_Z,S_X) 
     = allZHaveX(S_Z,(X S_X)) implies allZHaveX(S_Z,(X' S_X))
    when changeObjState0(X,X') .

  pred m2o-lemma06 : SetOfLObject SetOfLObjState SetOfObject ObjState SetOfObjState
  eq m2o-lemma06(S_X,St_X,S_Z,SZ,St_Z)
     = allObjInStates(S_Z,SZ) implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z)
     when (SZ in St_Z) .

  pred m2o-lemma07 : SetOfLObject LObjState SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma07(S_X,SX,St_X,S_Z,St_Z)
     = allLObjInStates(S_X,SX) implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z)
     when not (SX in St_X) .

  pred m2o-lemma08 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma08(Z,Z',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
         implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z)
     when not existLObj(S_X,link(Z)) and changeObjState0(Z,Z') .

  pred m2o-lemma09 : SetOfLObject SetOfLObjState Object SetOfObject SetOfObjState
  eq m2o-lemma09(S_X,St_X,Z,S_Z,St_Z)
     = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
         implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z) .

  pred m2o-lemma10 : LObject LObject SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma10(X,X',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates0((X S_X),St_X,S_Z,St_Z)
         implies ifXInStatesThenZInStates0((X' S_X),St_X,S_Z,St_Z)
     when not (state(X') in St_X) and changeObjState0(X,X') .

  pred m2o-lemma11 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma11(Z,Z',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
         implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z) 
     when (state(Z') in St_Z) and changeObjState0(Z,Z') .

  pred m2o-lemma12 : LObject LObject SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma12(X,X',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates0((X S_X),St_X,S_Z,St_Z)
         implies ifXInStatesThenZInStates0((X' S_X),St_X,S_Z,St_Z)
     when allZOfXInStates0(S_Z,id(X'),St_Z) and changeObjState0(X,X') .

  pred m2o-lemma13 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq m2o-lemma13(Z,Z',S_X,St_X,S_Z,St_Z)
     = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
         implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z)
     when not (state(Z) in St_Z) and changeObjState0(Z,Z') .

  pred m2o-lemma14 : SetOfLObject SetOfLObjState SetOfObject ObjState ObjType SetOfObjState
  eq m2o-lemma14(S_X,St_X,S_Z,SZ,OT,St_Z)
     = allObjInStates(S_Z,SZ) implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z)
     when (SZ in St_Z) .

  pred m2o-lemma15 : SetOfLObject LObjState SetOfLObjState SetOfObject ObjType SetOfObjState
  eq m2o-lemma15(S_X,SX,St_X,S_Z,OT,St_Z)
     = allLObjInStates(S_X,SX) implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z)
     when not (SX in St_X) .

  pred m2o-lemma16 : Object Object SetOfLObject SetOfLObjState SetOfObject ObjType SetOfObjState
  eq m2o-lemma16(Z,Z',S_X,St_X,S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),OT,St_Z)
     when not existLObj(S_X,link(Z)) and changeObjState0(Z,Z') .

  pred m2o-lemma17 : SetOfLObject SetOfLObjState Object SetOfObject ObjType SetOfObjState
  eq m2o-lemma17(S_X,St_X,Z,S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z) .

  pred m2o-lemma18 : LObject LObject SetOfLObject SetOfLObjState SetOfObject ObjType SetOfObjState
  eq m2o-lemma18(X,X',S_X,St_X,S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0((X S_X),St_X,S_Z,OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0((X' S_X),St_X,S_Z,OT,St_Z)
     when not (state(X') in St_X) and changeObjState0(X,X') .

  pred m2o-lemma19 : Object Object SetOfLObject SetOfLObjState SetOfObject ObjType SetOfObjState
  eq m2o-lemma19(Z,Z',S_X,St_X,S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),OT,St_Z) 
     when (state(Z') in St_Z) and changeObjState0(Z,Z') .

  pred m2o-lemma20 : LObject LObject SetOfLObject SetOfLObjState SetOfObject ObjType SetOfObjState
  eq m2o-lemma20(X,X',S_X,St_X,S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0((X S_X),St_X,S_Z,OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0((X' S_X),St_X,S_Z,OT,St_Z)
     when allZOfTypeOfXInStates0(S_Z,OT,id(X'),St_Z) and changeObjState0(X,X') .

  pred m2o-lemma21 : SetOfLObject SetOfLObjState Object Object SetOfObject ObjType SetOfObjState
  eq m2o-lemma21(S_X,St_X,Z,Z',S_Z,OT,St_Z)
     = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
         implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),OT,St_Z)
     when not (type(Z) = OT) and changeObjState0(Z,Z') .

  pred m2o-lemma22 : Object SetOfObject SetOfLObject SetOfLObjState .
  eq m2o-lemma22(Z,S_Z,S_X,St_X)
     = getLObject(S_X,link(Z)) in getXsOfZsInStates0(S_X,S_Z,St_X)
     when not S_X = empLObj and (state(getLObject(S_X,link(Z))) in St_X) and (Z in S_Z) .

  pred m2o-lemma23 : SetOfObject SetOfObject SetOfLObject SetOfLObjState .
  eq m2o-lemma23(S_Z,S_Z',S_X,St_X)
     = subset(S_Z,S_Z') implies 
       subset(getXsOfZsInStates0(S_X,S_Z,St_X),getXsOfZsInStates0(S_X,S_Z',St_X)) .

  pred m2o-lemma24 : LObject LObject SetOfLObject SetOfObject SetOfLObjState .
  eq m2o-lemma24(X,X',S_X,S_Z,St_X)
     = subset(getXsOfZsInStates0((X' S_X),S_Z,St_X),getXsOfZsInStates0((X S_X),S_Z,St_X))
     when changeObjState0(X,X') and not state(X') in St_X .

  pred m2o-lemma25 : LObject SetOfLObject SetOfObject SetOfObjState .
  eq m2o-lemma25(X,S_X,S_Z,St_Z)
     = subset(getZsOfXInStates0(S_Z,id(X),St_Z),getZsOfXsInStates0(S_Z,S_X,St_Z))
     when X in S_X .

  pred m2o-lemma26 : SetOfLObject SetOfLObject SetOfObject SetOfObjState .
  eq m2o-lemma26(S_X,S_X',S_Z,St_Z)
     = subset(S_X,S_X') implies 
       subset(getZsOfXsInStates0(S_Z,S_X,St_Z),getZsOfXsInStates0(S_Z,S_X',St_Z)) .

  pred m2o-lemma27 : Object Object SetOfObject SetOfLObject SetOfObjState .
  eq m2o-lemma27(Z,Z',S_Z,S_X,St_Z)
     = subset(getZsOfXsInStates0((Z' S_Z),S_X,St_Z),getZsOfXsInStates0((Z S_Z),S_X,St_Z))
     when changeObjState0(Z,Z') and not state(Z') in St_Z .

  pred m2o-lemma28 : Object Object SetOfObject LObject SetOfObjState .
  eq m2o-lemma28(Z,Z',S_Z,X,St_Z)
     = subset(getZsOfXInStates0((Z' S_Z),X,St_Z),getZsOfXInStates0((Z S_Z),X,St_Z))
     when changeObjState0(Z,Z') and not state(Z') in St_Z .

  -- Constants for Proofs.
  ops x x' x1 x2 : -> LObject .
  ops z z' z1 z2 z3 : -> Object .
  op idX : -> LObjID
  op idZ : -> ObjID
  ops setX setX' : -> SetOfLObject
  ops setZ setZ' : -> SetOfObject
  op ot : -> ObjType
  op sx : -> LObjState
  op sz : -> ObjState
  op setSX : -> SetOfLObjState
  op setSZ : -> SetOfObjState
}

--> **********************************************************************
--> Prove m2o-lemma01
-->       = allObjInStates(S_Z,SZ) implies allZOfXInStates0(S_Z,IDX,St_Z).
-->       when (SZ in St_Z) .
--> **********************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma01(idX,empObj,sz,setSZ) = true .
  eq m2o-lemma01(idX,setZ,sz,setSZ) implies m2o-lemma01(idX,(z setZ),sz,setSZ) = true .
}
:def ctfsz = :ctf {
  eq (sz in setSZ) = true .
}
:apply (ctfsz rd-)
show proof

--> ********************************************************************************
--> Prove m2o-lemma02
-->       = allObjInStates(S_Z,St_Z) implies allZOfTypeOfXInStates0(S_Z,IDX,OT,St_Z).
--> ********************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma02(idX,empObj,sz,ot,setSZ) = true .
  eq m2o-lemma02(idX,setZ,sz,ot,setSZ) implies m2o-lemma02(idX,(z setZ),sz,ot,setSZ) = true .
}
:def ctfsz = :ctf {
  eq (sz in setSZ) = true .
}
:apply (ctfsz rd-)
show proof

--> ********************************************************************
--> Prove m2o-lemma03
-->       = allZOfXInStates0(S_Z,link(Z),St_Z) implies (state(Z) in St_Z)
-->       when (Z in S_Z) .
--> ********************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma03(empObj,z,setSZ) = true .
  eq m2o-lemma03(setZ,z,setSZ) implies m2o-lemma03((z' setZ),z,setSZ) = true .
}
:def ctfz' = :ctf {
  eq z' = z .
}
:apply (ctfz' rd-)
show proof

--> ************************************************
--> Prove m2o-lemma04(S_Z,IDX,SZ,St_Z)
-->       = (getZsOfXInStates0(S_Z,IDX,SZ) = empObj)
-->           implies allZOfXInStates0(S_Z,IDX,St_Z) 
-->       when allZOfXInStates0(S_Z,IDX,(SZ St_Z)) .
--> ************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma04(empObj,idX,sz,setSZ) = true .
  eq m2o-lemma04(setZ,idX,sz,setSZ) implies m2o-lemma04((z setZ),idX,sz,setSZ) = true .
}
:def ctflink = :ctf {
  eq link(z) = idX .
}
:apply (ctflink rd-)
:def ctfstate = :ctf {
  eq state(z) = sz .
}
:apply (ctfstate rd-)
show proof

--> **************************************************************
--> Prove m2o-lemma05
-->       = allZHaveX(S_Z,(X S_X)) implies allZHaveX(S_Z,(X' S_X))
-->       when changeObjState0(X,X') .
--> **************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma05(x,x',empObj,setX) = true .
  eq m2o-lemma05(x,x',setZ,setX)
      implies m2o-lemma05(x,x',(z setZ),setX) = true .
}
:def ctfx = :ctf {
  eq id(x) = id(x') .
}
:apply (ctfx rd-)
show proof

--> ***********************************************************************************
--> Prove m2o-lemma06
-->       = allObjInStates(S_Z,SZ) implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z)
-->       when (SZ in St_Z) .
-->    This proof requires M2O-lemma01.
--> ***********************************************************************************
open M2O-LEMMAS .
  ceq [m2o-lemma01]:
      (allObjInStates(S_Z,SZ) and allZOfXInStates0(S_Z,IDX,St_Z))
     = allObjInStates(S_Z,SZ)
     if (SZ in St_Z) . 

:goal {
  eq m2o-lemma06(empLObj,setSX,setZ,sz,setSZ) = true .
  eq m2o-lemma06(setX,setSX,setZ,sz,setSZ) implies m2o-lemma06((x setX),setSX,setZ,sz,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfstate = :ctf {
  eq (state(x) in setSX) = true .
}
:apply (ctfstate rd-)
:def ctfsz = :ctf {
  eq (sz in setSZ) = true .
}
:apply (ctfsz rd-)
show proof
close

--> ********************************************************************************
--> Prove m2o-lemma07
-->    = allLObjInStates(S_X,SX) implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z)
-->    when not (SX in St_X) .
--> ********************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma07(empLObj,sx,setSX,setZ,setSZ) = true .
  eq m2o-lemma07(setX,sx,setSX,setZ,setSZ)
      implies m2o-lemma07((x setX),sx,setSX,setZ,setSZ) = true .
}
:def ctfsx = :ctf {
  eq (sx in setSX) = true .
}
:apply (ctfsx rd-)
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfstate = :ctf {
  eq state(x) = sx .
}
:apply (ctfstate rd-)
show proof

--> *******************************************************************
--> Prove m2o-lemma08
-->       = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
-->           implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z)
-->       when not existLObj(S_X,link(Z)) and changeObjState0(Z,Z') .
--> *******************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma08(z,z',empLObj,setSX,setZ,setSZ) = true .
  eq m2o-lemma08(z,z',setX,setSX,setZ,setSZ) implies m2o-lemma08(z,z',(x setX),setSX,setZ,setSZ) = true .
}
:def ctfz = :ctf {
  eq id(x) = link(z) .
}
:apply (ctfz rd-)
:def ctfz' = :ctf {
  eq id(x) = link(z') .
}
:apply (ctfz' rd-)
show proof

--> ****************************************************************
--> Prove m2o-lemma09
-->       = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
-->           implies ifXInStatesThenZInStates0(S_X,St_X,S_Z,St_Z) .
--> ****************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma09(empLObj,setSX,z,setZ,setSZ) = true .
  eq m2o-lemma09(setX,setSX,z,setZ,setSZ) implies m2o-lemma09((x setX),setSX,z,setZ,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> ******************************************************************
--> Prove m2o-lemma10(X,X',S_X,St_X,S_Z,St_Z)
-->       = ifXInStatesThenZInStates0((X S_X),St_X,S_Z,St_Z)
-->          implies ifXInStatesThenZInStates0((X' S_X),St_X,S_Z,St_Z)
-->       when not (state(X') in St_X) and changeObjState0(X,X') .
--> ******************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma10(x,x',setX,setSX,setZ,setSZ)= true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> *******************************************************************
--> Prove m2o-lemma11
-->       = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
-->           implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z)
-->       when (state(Z') in St_Z) and changeObjState0(Z,Z') .
--> *******************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma11(z,z',empLObj,setSX,setZ,setSZ) = true .
  eq m2o-lemma11(z,z',setX,setSX,setZ,setSZ)
      implies m2o-lemma11(z,z',(x setX),setSX,setZ,setSZ) = true .
}
:apply (rd-)
show proof

--> ************************************************************************
--> Prove m2o-lemma12
-->       = ifXInStatesThenZInStates0((X S_X),St_X,S_Z,St_Z)
-->           implies ifXInStatesThenZInStates0((X' S_X),St_X,S_Z,St_Z)
-->       when allZOfXInStates0(S_Z,id(X'),St_Z) and changeObjState0(X,X') .
--> ************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma12(x,x',setX,setSX,setZ,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> *******************************************************************
--> Prove m2o-lemma13
-->       = ifXInStatesThenZInStates0(S_X,St_X,(Z S_Z),St_Z)
-->           implies ifXInStatesThenZInStates0(S_X,St_X,(Z' S_Z),St_Z)
-->       when not (state(Z) in St_Z) and changeObjState0(Z,Z') .
--> *******************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma13(z,z',empLObj,setSX,setZ,setSZ) = true .
  eq m2o-lemma13(z,z',setX,setSX,setZ,setSZ)
      implies m2o-lemma13(z,z',(x setX),setSX,setZ,setSZ) = true .
}
:def ctfz = :ctf {
  eq link(z) = id(x) .
}
:apply (ctfz rd-)
:def ctfz' = :ctf {
  eq link(z') = id(x) .
}
:apply (ctfz' rd-)
show proof

--> ********************************************************************************************
--> Prove m2o-lemma14
-->       = allObjInStates(S_Z,SZ) implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z)
-->       when (SZ in St_Z) .
-->    This proof requires M2O-lemma01.
--> ********************************************************************************************
open M2O-LEMMAS .
  ceq [m2o-lemma02]:
      (allObjInStates(S_Z,SZ) and allZOfTypeOfXInStates0(S_Z,OT,IDX,St_Z))
     = allObjInStates(S_Z,SZ)
     if (SZ in St_Z) . 
:goal {
  eq m2o-lemma14(empLObj,setSX,setZ,sz,ot,setSZ) = true .
  eq m2o-lemma14(setX,setSX,setZ,sz,ot,setSZ) implies m2o-lemma14((x setX),setSX,setZ,sz,ot,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfstate = :ctf {
  eq (state(x) in setSX) = true .
}
:apply (ctfstate rd-)
:def ctfsz = :ctf {
  eq (sz in setSZ) = true .
}
:apply (ctfsz rd-)
show proof
close

--> *****************************************************************************************
--> Prove m2o-lemma15
-->    = allLObjInStates(S_X,SX) implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z)
-->    when not (SX in St_X) .
--> *****************************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma15(empLObj,sx,setSX,setZ,ot,setSZ) = true .
  eq m2o-lemma15(setX,sx,setSX,setZ,ot,setSZ)
      implies m2o-lemma15((x setX),sx,setSX,setZ,ot,setSZ) = true .
}
:def ctfsx = :ctf {
  eq (sx in setSX) = true .
}
:apply (ctfsx rd-)
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfstate = :ctf {
  eq state(x) = sx .
}
:apply (ctfstate rd-)
show proof

--> ****************************************************************************
--> Prove m2o-lemma16
-->       = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
-->           implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),OT,St_Z)
-->       when not existLObj(S_X,link(Z)) and changeObjState0(Z,Z') .
--> ****************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma16(z,z',empLObj,setSX,setZ,ot,setSZ) = true .
  eq m2o-lemma16(z,z',setX,setSX,setZ,ot,setSZ) implies m2o-lemma16(z,z',(x setX),setSX,setZ,ot,setSZ) = true .
}
:def ctfz = :ctf {
  eq id(x) = link(z) .
}
:apply (ctfz rd-)
:def ctfz' = :ctf {
  eq id(x) = link(z') .
}
:apply (ctfz' rd-)
show proof

--> *************************************************************************
--> Prove m2o-lemma17
-->       = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
-->           implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,S_Z,OT,St_Z) .
--> *************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma17(empLObj,setSX,z,setZ,ot,setSZ) = true .
  eq m2o-lemma17(setX,setSX,z,setZ,ot,setSZ) implies m2o-lemma17((x setX),setSX,z,setZ,ot,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> *********************************************************************
--> Prove m2o-lemma18(X,X',S_X,St_X,S_Z,OT,St_Z)
-->       = ifXInStatesThenZInStates0((X S_X),St_X,S_Z,OT,St_Z)
-->          implies ifXInStatesThenZInStates0((X' S_X),St_X,S_Z,OT,St_Z)
-->       when not (state(X') in St_X) and changeObjState0(X,X') .
--> *********************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma18(x,x',setX,setSX,setZ,ot,setSZ)= true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> *************************************************************************
--> Prove m2o-lemma19
-->       = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),St_Z)
-->           implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),St_Z)
-->       when (state(Z') in St_Z) and changeObjState0(Z,Z') .
--> *************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma19(z,z',empLObj,setSX,setZ,ot,setSZ) = true .
  eq m2o-lemma19(z,z',setX,setSX,setZ,ot,setSZ)
      implies m2o-lemma19(z,z',(x setX),setSX,setZ,ot,setSZ) = true .
}
:apply (rd-)
show proof

--> *********************************************************************************
--> Prove m2o-lemma20
-->       = ifXInStatesThenZOfTypeInStates0((X S_X),St_X,S_Z,OT,St_Z)
-->           implies ifXInStatesThenZOfTypeInStates0((X' S_X),St_X,S_Z,OT,St_Z)
-->       when allZOfTypeOfXInStates0(S_Z,OT,id(X'),St_Z) and changeObjState0(X,X') .
--> *********************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma20(x,x',setX,setSX,setZ,ot,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
show proof

--> ****************************************************************************
--> Prove m2o-lemma21
-->       = ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z S_Z),OT,St_Z)
-->           implies ifXInStatesThenZOfTypeInStates0(S_X,St_X,(Z' S_Z),OT,St_Z) 
-->     when not (type(Z) = OT) and changeObjState0(Z,Z') .
--> ****************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma21(empLObj,setSX,z,z',setZ,ot,setSZ) = true .
  eq m2o-lemma21(setX,setSX,z,z',setZ,ot,setSZ) implies m2o-lemma21((x setX),setSX,z,z',setZ,ot,setSZ) = true .
}
:def ctfot = :ctf {
  eq type(z) = ot .
}
:apply (ctfot rd-)
:def ctfstate = :ctf {
  eq (state(x) in setSX) = true .
}
:apply (ctfstate rd-)
:def ctfid = :ctf {
  eq id(z) = id(z') .
}
:apply (ctfid rd-)
:def ctflink = :ctf {
  eq link(z) = link(z') .
}
:apply (ctflink rd-)
:def ctftype = :ctf {
  eq type(z) = type(z') .
}
:apply (ctftype rd-)
show proof

--> ****************************************************************************************
--> Prove m2o-lemma22
-->     = getLObject(S_X,link(Z)) in getXsOfZsInStates0(S_X,S_Z,St_X)
-->     when not S_X = empLObj and (state(getLObject(S_X,link(Z))) in St_X) and (Z in S_Z) .
--> ****************************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma22(z,setZ,setX,setSX) = true .
}
:def ctfsetX = :ctf {
  eq setX = empLObj .
}
:apply (ctfsetX rd-)
:def cspz = :csp {
  eq (z in setZ) = false .
  eq setZ = (z setZ') .
}
:apply (cspz rd-)
:def ctfstate = :ctf {
  eq state(getLObject(setX,link(z))) in setSX = true .
}
:apply (ctfstate rd-)
show proof

--> **********************************************************************************
--> Prove m2o-lemma23(S_Z,S_Z',S_X,St_X)
-->     = subset(S_Z,S_Z') implies 
-->       subset(getXsOfZsInStates0(S_X,S_Z,St_X),getXsOfZsInStates0(S_X,S_Z',St_X)) .
--> **********************************************************************************
open M2O-LEMMAS .
  ceq [m2o-lemma22]:
    (getLObject(S_X,link(Z)) in getXsOfZsInStates0(S_X,S_Z,St_X)) = true
    if not S_X = empLObj and (state(getLObject(S_X,link(Z))) in St_X) and (Z in S_Z) .
:goal {
  eq m2o-lemma23(empObj,setZ',setX,setSX) = true .
  eq m2o-lemma23(setZ,setZ',setX,setSX) implies m2o-lemma23((z setZ),setZ',setX,setSX) = true .
}
:def ctfsetX = :ctf {
  eq setX = empLObj .
}
:apply (ctfsetX rd-)
:def ctfz = :ctf {
  eq (z in setZ') = true .
}
:apply (ctfz rd-)
:def ctfstate = :ctf {
  eq state(getLObject(setX,link(z))) in setSX = true .
}
:apply (ctfstate rd-)
show proof
close

--> ******************************************************************************************
--> Prove m2o-lemma24(X,X',S_X,S_Z,St_X)
-->     = changeObjState0(X,X') and not state(X') in St_X implies
-->       subset(getXsOfZsInStates0((X' S_X),S_Z,St_X),getXsOfZsInStates0((X S_X),S_Z,St_X)) .
--> ******************************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma24(x1,x2,setX,empObj,setSX) = true .
  eq m2o-lemma24(x1,x2,setX,setZ,setSX) implies  m2o-lemma24(x1,x2,setX,(z setZ),setSX) = true .
}
:def ctfx2 = :ctf {
  eq (state(x2) in setSX) = true .
}
:apply (ctfx2 rd-)
:def ctfid = :ctf {
  eq id(x2) = id(x1) .
}
:apply (ctfid rd-)
:def ctflink = :ctf {
  eq link(z) = id(x1) .
}
:def ctfx1 = :ctf {
  eq (state(x1) in setSX) = true .
}
:def ctfstate = :ctf {
  eq (state(getLObject(setX,link(z))) in setSX) = true .
}
:apply (ctflink ctfx1 ctfstate rd-)
show proof

--> **********************************************************************************
--> Prove m2o-lemma25(X,S_X,S_Z,St_Z)
-->     = X in S_X implies 
-->       subset(getZsOfXInStates0(S_Z,id(X),St_Z),getZsOfXsInStates0(S_Z,S_X,St_Z)) .
--> **********************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma25(x,empLObj,setZ,setSZ) = true .
  eq m2o-lemma25(x,setX,setZ,setSZ) implies m2o-lemma25(x,(x' setX),setZ,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfx = :ctf {
  eq x' = x .
}
:apply (ctfx rd-)
show proof

--> **********************************************************************************
--> Prove m2o-lemma26(S_X,S_X',S_Z,St_Z)
-->     = subset(S_X,S_X') implies 
-->       subset(getZsOfXsInStates0(S_Z,S_X,St_Z),getZsOfXsInStates0(S_Z,S_X',St_Z)) .
--> **********************************************************************************
open M2O-LEMMAS .
ceq [m2o-lemma25&set-lemma10]:
    subset(S_Z',getZsOfXsInStates0(S_Z,S_X,St_Z)) and
    subset((S_Z' getZsOfXInStates0(S_Z,id(X),St_Z)),getZsOfXsInStates0(S_Z,S_X,St_Z))
  = subset(S_Z',getZsOfXsInStates0(S_Z,S_X,St_Z)) 
  if X in S_X .
:goal {
  eq m2o-lemma26(empLObj,setX',setZ,setSZ) = true .
  eq m2o-lemma26(setX,setX',setZ,setSZ) implies m2o-lemma26((x setX),setX',setZ,setSZ) = true .
}
:def ctfsetZ = :ctf {
  eq setZ = empObj .
}
:apply (ctfsetZ rd-)
:def ctfx = :ctf {
  eq (x in setX') = true .
}
:apply (ctfx rd-)
show proof
close

--> ******************************************************************************************
--> Prove m2o-lemma27(Z,Z',S_Z,S_X,St_Z)
-->     = changeObjState0(Z,Z') and not state(Z') in St_Z implies
-->       subset(getZsOfXsInStates0((Z' S_Z),S_X,St_Z),getZsOfXsInStates0((Z S_Z),S_X,St_Z)) .
--> ******************************************************************************************
select M2O-LEMMAS
:goal {
  eq m2o-lemma27(z1,z2,setZ,empLObj,setSZ) = true .
  eq m2o-lemma27(z1,z2,setZ,setX,setSZ) implies  m2o-lemma27(z1,z2,setZ,(x setX),setSZ) = true .
}
:def ctfstate = :ctf {
  eq (state(z2) in setSZ) = true .
}
:apply (ctfstate rd-)
:def ctfidz = :ctf {
  eq id(z2) = id(z1) .
}
:apply (ctfidz rd-)
:def ctfidx = :ctf {
  eq id(x) = link(z1) .
}
:apply (ctfidx rd-)
:def ctfz1 = :ctf {
  eq (state(z1) in setSZ) = true .
}
:apply (ctfz1 rd-)
show proof

--> ************************************************************************************
--> Prove m2o-lemma28(Z,Z',S_Z,X,St_Z)
-->     = changeObjState0(Z,Z') and not state(Z') in St_Z implies
-->       subset(getZsOfXInStates0((Z' S_Z),X,St_Z),getZsOfXInStates0((Z S_Z),X,St_Z)) .
--> ************************************************************************************
select M2O-LEMMAS 
:goal {
  eq m2o-lemma28(z1,z2,setZ,x,setSZ) = true .
}
:def ctfstatez2 = :ctf {
  eq (state(z2) in setSZ) = true .
}
:apply (ctfstatez2 rd-)
:def ctfz2 = :ctf {
  eq id(z2) = id(z1) .
}
:apply (ctfz2 rd-)
:def ctfx = :ctf {
  eq id(x) = link(z1) .
}
:apply (ctfx rd-)
:def ctfstatez1 = :ctf {
  eq (state(z1) in setSZ) = true .
}
:apply (ctfstatez1 rd-)
show proof

select

module O2O-LEMMAS {
  including(-OBJLINKONE2ONE0-lemma)

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  var IDX : LObjID 
  var IDY : ObjID 
  vars X X' : LObject
  vars Y Y' : Object
  vars S_X S_X' : SetOfLObject
  vars S_Y S_Y' : SetOfObject
  vars SX SX1 : LObjState
  vars SY SY1 : ObjState
  var St_X : SetOfLObjState
  var St_Y : SetOfObjState

  -- Axiom
  -- O2O Lemmas are valid only when instantiating with the following properties.
  eq X in empLObj = false .
  eq X in (X S_X) = true .
  ceq X in (X' S_X) = X in S_X if not(X = X') .
  eq ((X S_X) = empLObj) = false .

  eq Y in empObj = false .
  eq Y in (Y S_Y) = true .
  ceq Y in (Y' S_Y) = Y in S_Y if not(Y = Y') .
  eq ((Y S_Y) = empObj) = false .

  eq SX in SX1 = (SX = SX1) .
  eq SX in (SX St_X) = true .
  ceq SX in (SX1 St_X) = SX in St_X if not(SX = SX1) .

  eq SY in empState = false .
  eq SY in (SY St_Y) = true .
  ceq SY in (SY1 St_Y) = SY in St_Y if not(SY = SY1) .
  eq ((SY St_Y) = empState) = false .

  eq subset(empLObj,S_X) = true .
  eq subset(S_X,empLObj) = (S_X = empLObj) .
  eq subset(S_X,S_X) = true .
  ceq subset((X S_X),S_X') = subset(S_X,S_X') if (X in S_X') .
  ceq subset((X S_X),S_X') = false if not (X in S_X') .
  eq subset(S_X,(X S_X)) = true .

  eq subset(empObj,S_Y) = true .
  eq subset(S_Y,empObj) = (S_Y = empObj) .
  eq subset(S_Y,S_Y) = true .
  ceq subset((Y S_Y),S_Y') = subset(S_Y,S_Y') if (Y in S_Y') .
  ceq subset((Y S_Y),S_Y') = false if not (Y in S_Y') .
  eq subset(S_Y,(Y S_Y)) = true .

  eq getLObject((X S_X),IDX)
     = if (id(X) = IDX) then X else getLObject(S_X,IDX) fi .

  pred hasID : LObject LObjID
  eq hasID(X,IDX) = id(X) = IDX .

  eq existLObj(empLObj,IDX) = false .
  eq existLObj((X S_X),IDX)
     = id(X) = IDX or existLObj(S_X,IDX) .

  eq allLObjInStates(empLObj, St_X) = true .
  eq allLObjInStates((X S_X), St_X)
     = (state(X) in St_X) and allLObjInStates(S_X, St_X) .

  eq allObjInStates(empObj, St_Y) = true .
  eq allObjInStates((Y S_Y), St_Y)
     = (state(Y) in St_Y) and allObjInStates(S_Y, St_Y) .

  pred o2o-lemma01 : LObjID SetOfObject SetOfObjState
  eq o2o-lemma01(IDX,S_Y,St_Y)
     = allObjInStates(S_Y,St_Y) implies YOfXInStates0(S_Y,IDX,St_Y)
     when uniqX(S_Y) and onlyOneYOfX0(S_Y,IDX) .

  pred o2o-lemma02 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq o2o-lemma02(Y,Y',S_X,St_X,S_Y,St_Y)
     = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
         implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
     when changeObjState0(Y,Y') and (state(Y') in St_Y) .

  pred o2o-lemma03 : SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq o2o-lemma03(S_X,St_X,S_Y,St_Y)
     = allObjInStates(S_Y,St_Y) implies ifXInStatesThenYInStates0(S_X,St_X,S_Y,St_Y)
     when uniqX(S_Y) and allXHaveY(S_X,S_Y) .

  pred o2o-lemma04 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq o2o-lemma04(Y,Y',S_X,St_X,S_Y,St_Y)
     = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
         implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
     when not existLObj(S_X,link(Y)) and changeObjState0(Y,Y') .

  pred o2o-lemma05 : Object Object SetOfLObject SetOfLObjState SetOfObject SetOfObjState
  eq o2o-lemma05(Y,Y',S_X,St_X,S_Y,St_Y)
     = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
         implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
     when changeObjState0(Y,Y') and not (state(Y) in St_Y) .

  pred o2o-lemma06 : SetOfObject LObjID
  eq o2o-lemma06(S_Y,IDX)
     = (getYOfX0(S_Y,IDX) = null)
     when not existX0(S_Y,IDX) .

  -- Constants for Proofs.
  ops x x' x1 x2 : -> LObject .
  ops y y' y1 y2 : -> Object .
  ops o o' o1 o2 : -> Object .
  op idX : -> LObjID
  op idY : -> ObjID
  ops setX setX' : -> SetOfLObject
  ops setY setY' : -> SetOfObject
  op ot : -> ObjType
  op sx : -> LObjState
  op sy : -> ObjState
  op setSX : -> SetOfLObjState
  op setSY : -> SetOfObjState
}

--> ********************************************************************
--> Prove o2o-lemma01
-->       = allObjInStates(S_Y,St_Y) implies YOfXInStates0(S_Y,IDX,St_Y)
-->       when uniqX(S_Y) and onlyOneYOfX0(S_Y,IDX) .
--> ********************************************************************
select O2O-LEMMAS
:goal {
  eq o2o-lemma01(idX,empObj,setSY) = true .
  eq o2o-lemma01(idX,setY,setSY) implies o2o-lemma01(idX,(y setY),setSY) = true .
}
:def ctf-1 = :ctf {
  eq onlyOneYOfX0(setY,idX) = true .
}
:def ctf-2 = :ctf {
  eq link(y) = idX .
}
:apply (ctf-1 ctf-2 rd-)
show proof

--> *******************************************************************
--> Prove o2o-lemma02(Y,Y',S_X,St_X,S_Y,St_Y)
-->       = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
-->           implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
-->       when changeObjState0(Y,Y') and (state(Y') in St_Y) = true .
--> *******************************************************************
select O2O-LEMMAS
:goal {
  eq o2o-lemma02(y,y',empLObj,setSX,setY,setSY) = true .
  eq o2o-lemma02(y,y',setX,setSX,setY,setSY) implies o2o-lemma02(y,y',(x setX),setSX,setY,setSY) = true .
}
:def ctfy = :ctf {
  eq link(y) = id(x) .
}
:def ctfy' = :ctf {
  eq link(y') = id(x) .
}
:apply (ctfy ctfy' rd-)
show proof

--> *************************************************************************************
--> Prove o2o-lemma03
-->       = allObjInStates(S_Y,St_Y) implies ifXInStatesThenYInStates0(S_X,St_X,S_Y,St_Y)
-->       when uniqX(S_Y) and allXHaveY(S_X,S_Y).
--> *************************************************************************************
open O2O-LEMMAS .
  ceq [o2o-lemma01]:
      (allObjInStates(S_Y,St_Y) and YOfXInStates0(S_Y,IDX,St_Y))
     = allObjInStates(S_Y,St_Y)
     if uniqX(S_Y) and onlyOneYOfX0(S_Y,IDX) .

:goal {
  eq o2o-lemma03(empLObj,setSX,setY,setSY) = true .
  eq o2o-lemma03(setX,setSX,setY,setSY) implies o2o-lemma03((x setX),setSX,setY,setSY) = true .
}
:def ctfsetY = :ctf {
  eq setY = empObj .
}
:apply (ctfsetY rd-)
:def ctfuniqX = :ctf {
  eq uniqX(setY) = true .
}
:apply (ctfuniqX rd-)
:def ctfonly = :ctf {
  eq onlyOneYOfX0(setY,id(x)) = true .
}
:apply (ctfonly rd-)
show proof
close

--> *******************************************************************
--> Prove o2o-lemma04 
-->       = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
-->           implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
-->       when not existLObj(S_X,link(Y)) and changeObjState0(Y,Y') .
--> *******************************************************************
select O2O-LEMMAS
:goal {
  eq o2o-lemma04(y,y',empLObj,setSX,setY,setSY) = true .
  eq o2o-lemma04(y,y',setX,setSX,setY,setSY) implies o2o-lemma04(y,y',(x setX),setSX,setY,setSY) = true .
}
:def ctfy = :ctf {
  eq link(y) = id(x) .
}
:def ctfy' = :ctf {
  eq link(y') = id(x) .
}
:apply (ctfy ctfy' rd-)
show proof

--> *******************************************************************
--> Prove o2o-lemma05(Y,Y',S_X,St_X,S_Y,St_Y)
-->       = ifXInStatesThenYInStates0(S_X,St_X,(Y S_Y),St_Y)
-->           implies ifXInStatesThenYInStates0(S_X,St_X,(Y' S_Y),St_Y)
-->       when changeObjState0(Y,Y') and not (state(Y) in St_Y) .
--> *******************************************************************
select O2O-LEMMAS
:goal {
  eq o2o-lemma05(y,y',empLObj,setSX,setY,setSY) = true .
  eq o2o-lemma05(y,y',setX,setSX,setY,setSY) implies o2o-lemma05(y,y',(x setX),setSX,setY,setSY) = true .
}
:def ctfy = :ctf {
  eq link(y) = id(x) .
}
:def ctfy' = :ctf {
  eq link(y') = id(x) .
}
:apply (ctfy ctfy' rd-)
show proof

--> *********************************
--> Prove o2o-lemma06(S_Y,IDX)
-->       = getYOfX0(S_Y,IDX) = null
-->       when not existX0(S_Y,IDX) .
--> *********************************
select O2O-LEMMAS
:goal {
  eq o2o-lemma06(empObj,idX) = true .
  eq o2o-lemma06(setY,idX) implies o2o-lemma06((y setY),idX) = true .
}
:def ctfidx = :ctf {
  eq idX = link(y) . 
}
:apply (ctfidx rd-)
show proof

select

module O2O2O-LEMMAS {
  including(-OBJLINKONE2ONE2ONE-lemma)

  pred (_when _) : Bool Bool { prec: 64 r-assoc }
  eq (B1:Bool when B2:Bool)
     = B2 implies B1 .

  var IDX : LObjID 
  var IDX' : L'ObjID 
  var IDY : ObjID 
  vars X X1 : LObject
  vars X' X'1 : L'Object
  vars Y Y2 : Object
  vars S_X S_X1 : SetOfLObject
  vars S_X' S_X'1 : SetOfL'Object
  vars S_Y S_Y1 : SetOfObject
  vars SX SX1 SX2 : LObjState
  vars SX' SX'1 SX'2 : L'ObjState
  vars SY SY1 SY2 : ObjState
  var St_X : SetOfLObjState
  var St_X' : SetOfL'ObjState
  var St_Y : SetOfObjState

  -- Axiom
  -- O2O2O Lemmas are valid only when instantiating with the following properties.

  pred existX : SetOfObject LObjID
  eq existX(empObj,IDX) = false .
  eq existX((Y S_Y),IDX) = (link(Y) = IDX or existX(S_Y,IDX)) .

  eq uniqX(empObj)
     = true .
  eq uniqX((Y S_Y))
     = not existX(S_Y,link(Y)) and uniqX(S_Y) .

  pred existX' : SetOfObject L'ObjID
  eq existX'(empObj,IDX') = false .
  eq existX'((Y S_Y),IDX') = (link'(Y) = IDX' or existX'(S_Y,IDX')) .

  eq uniqX'(empObj)
     = true .
  eq uniqX'((Y S_Y))
     = not existX'(S_Y,link'(Y)) and uniqX'(S_Y) .

  eq getX'OfY(X' S_X',Y)
     = if (id(X') = link'(Y)) then X' else getX'OfY(S_X',Y) fi .

  eq getYOfX(empObj,IDX)
     = null .
  eq getYOfX((Y S_Y),IDX)
     = if (IDX = link(Y)) then Y else getYOfX(S_Y,IDX) fi .

  eq existLObj(empLObj,IDX) = false .
  eq existLObj((X S_X),IDX)
     = id(X) = IDX or existLObj(S_X,IDX) .

  pred o2o2o-lemma01 : SetOfLObject SetOfLObjState L'Object L'Object SetOfL'Object
       		       SetOfL'ObjState Object SetOfObject
  eq o2o2o-lemma01(S_X,St_X,X',X'1,S_X',St_X',Y,S_Y)
     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',(Y S_Y)) implies
       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',(Y S_Y)) 
     when not existLObj(S_X,link(Y)) and uniqX(Y S_Y) and uniqX'(Y S_Y) and
          link'(Y) = id(X') and changeObjState0(X',X'1) .

  pred o2o2o-lemma02 : SetOfLObject SetOfLObjState L'Object L'Object SetOfL'Object
       		       SetOfL'ObjState SetOfObject
  eq o2o2o-lemma02(S_X,St_X,X',X'1,S_X',St_X',S_Y)
     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',S_Y) implies
       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',S_Y) 
     when not (state(X') in St_X') and changeObjState0(X',X'1) .

  pred o2o2o-lemma03 : SetOfLObject SetOfLObjState L'Object L'Object SetOfL'Object
       		       SetOfL'ObjState SetOfObject
  eq o2o2o-lemma03(S_X,St_X,X',X'1,S_X',St_X',S_Y)
     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',S_Y) implies
       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',S_Y) 
     when (state(X'1) in St_X') and changeObjState0(X',X'1) .

  -- Constants for Proofs.
  ops x x1 x2 : -> LObject .
  ops x' x'1 x'2 : -> L'Object .
  ops y y1 y2 : -> Object .
  ops o o1 o2 : -> Object .
  op idX : -> LObjID
  op idX' : -> L'ObjID
  op idY : -> ObjID
  ops setX setX1 : -> SetOfLObject
  ops setX' setX'1 : -> SetOfL'Object
  ops setY setY1 : -> SetOfObject
  op sx : -> LObjState
  op sy : -> ObjState
  op setSX : -> SetOfLObjState
  op setSX' : -> SetOfL'ObjState
  op setSY : -> SetOfObjState
}

--> **************************************************************************
--> Prove o2o2o-lemma01(S_X,St_X,X',X'1,S_X',St_X',Y,S_Y)
-->     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',(Y S_Y)) implies
-->       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',(Y S_Y)) 
-->     when not existLObj(S_X,link(Y)) and uniqX(Y S_Y) and uniqX'(Y S_Y) and
-->          link'(Y) = id(X') and changeObjState0(X',X'1) .
--> **************************************************************************
select O2O2O-LEMMAS
:goal {
  eq o2o2o-lemma01(empLObj,setSX,x',x'1,setX',setSX',y,setY) = true .
}
:apply (rd-)
show proof
:goal {
  eq o2o2o-lemma01(setX,setSX,x',x'1,setX',setSX',y,setY) implies
     o2o2o-lemma01((x setX),setSX,x',x'1,setX',setSX',y,setY) = true .
}
:def ctfidx' = :ctf {
  eq id(x') = id(x'1) .
}
:apply(ctfidx')
:def ctfstatex' = :ctf {
  eq state(x') > state(x'1) = true .
}
:apply(ctfstatex')
:def ctfidx = :ctf {
  eq id(x) = link(y) .
}
:apply(ctfidx)
:apply(rd-)
:def ctfexistLObj = :ctf {
  eq existLObj(setX,link(y)) = true .
}
:apply(ctfexistLObj rd-)
:def ctflink' = :ctf {
  eq link'(y) = id(x'1) .
}
:apply(ctflink')
:def ctfexistX = :ctf {
  eq existX(setY,link(y)) = true . 
}
:apply(ctfexistX rd-)
:def ctfuniqX = :ctf {
 eq uniqX(setY) = true . 
}
:apply(ctfuniqX rd-)
:def ctfexistX' = :ctf {
  eq existX'(setY,id(x'1)) = true . 
}
:apply(ctfexistX' rd-)
:def ctfuniqX' = :ctf {
 eq uniqX'(setY) = true . 
}
:apply(ctfuniqX' rd-)
:def cspgetY = :csp {
  eq getYOfX(y setY,id(x)) = null .
  eq setY = (y1 setY1) .
}
:apply(cspgetY)
:apply(rd-)
:csp { eq link(y1) = id(x) . }
:def ctfy1 = :ctf {
  eq link'(y1) = id(x'1) .
}
:apply(ctfy1)
:apply(rd-)
:def ctfgetX' = :ctf {
  eq getX'OfY(setX',y1) = null .
}
:apply(ctfgetX')
:apply(rd-)
:def ctfstatex = :ctf {
  eq (state(x) in setSX) = true .
}
:apply(ctfstatex)
:ctf { eq uniqX(setY1) = true . }
:ctf { eq uniqX'(setY1) = true . }
:ctf { eq existX(setY1,link(y)) = true . }
:apply(rd-)
:apply(rd-)
:apply(rd-)
:apply(rd-)
:apply(rd-)
:apply(rd-)
:apply(rd-)
:apply(rd-)
show proof

select

--> **********************************************************************
--> Prove o2o2o-lemma02(S_X,St_X,X',X'1,S_X',St_X',S_Y)
-->     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',S_Y) implies
-->       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',S_Y) 
-->     when not (state(X') in St_X') and changeObjState0(X',X'1) .
--> **********************************************************************
select O2O2O-LEMMAS
:goal {
  eq o2o2o-lemma02(empLObj,setSX,x',x'1,setX',setSX',setY) = true .
  eq o2o2o-lemma02(setX,setSX,x',x'1,setX',setSX',setY) implies
     o2o2o-lemma02((x setX),setSX,x',x'1,setX',setSX',setY) = true .
}
:apply (rd-)
:def ctfidx' = :ctf {
  eq id(x') = id(x'1) .
}
:apply(ctfidx' rd-)
:def ctfstatex' = :ctf {
  eq state(x') > state(x'1) = true .
}
:apply(ctfstatex' rd-)
:def ctfstatex'in = :ctf {
  eq (state(x') in setSX') = true .
}
:apply(ctfstatex'in rd-)
:def cspgetY = :csp {
  eq getYOfX(setY,id(x)) = null .
  eq setY = (y1 setY1) .
}
:apply(cspgetY)
:apply(rd-)
:csp { eq link(y1) = id(x) . }
:def ctfy1 = :ctf {
  eq link'(y1) = id(x'1) .
}
:apply(ctfy1 rd-)
show proof

select

--> **********************************************************************
--> Prove o2o2o-lemma03(S_X,St_X,X',X'1,S_X',St_X',S_Y)
-->     = ifXInStatesThenX'InStates(S_X,St_X,(X'  S_X'),St_X',S_Y) implies
-->       ifXInStatesThenX'InStates(S_X,St_X,(X'1 S_X'),St_X',S_Y) 
-->     when (state(X'1) in St_X') and changeObjState0(X',X'1) .
--> **********************************************************************
select O2O2O-LEMMAS
:goal {
  eq o2o2o-lemma03(empLObj,setSX,x',x'1,setX',setSX',setY) = true .
  eq o2o2o-lemma03(setX,setSX,x',x'1,setX',setSX',setY) implies
     o2o2o-lemma03((x setX),setSX,x',x'1,setX',setSX',setY) = true .
}
:apply (rd-)
:def ctfidx' = :ctf {
  eq id(x') = id(x'1) .
}
:apply(ctfidx' rd-)
:def ctfstatex' = :ctf {
  eq state(x') > state(x'1) = true .
}
:apply(ctfstatex' rd-)
:def ctfstatex'1 = :ctf {
  eq (state(x'1) in setSX') = true .
}
:apply(ctfstatex'1 rd-)
:def cspgetY = :csp {
  eq getYOfX(setY,id(x)) = null .
  eq setY = (y1 setY1) .
}
:apply(cspgetY)
:apply(rd-)
:csp { eq link(y1) = id(x) . }
:def ctfy1 = :ctf {
  eq link'(y1) = id(x'1) .
}
:apply(ctfy1 rd-)
show proof

select

--> Totally 59 goals should be proved
--> including 2 cont-lemmas, 15 bool&set-lemmas, 4 base-lemmas(+1), 28 m2o-lemmas, 6 o2o-lemmas, and 4 o2o2o-lemmas.
