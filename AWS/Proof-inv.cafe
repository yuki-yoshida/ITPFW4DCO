require PROOF Proof.cafe

--> ***************************
--> (3) init(S) implies inv(S).
--> (4) inv(S) implies inv(SS).
--> ***************************

--> *************************************************************
--> Proof of inv-ifRSStartedThenPRReady.
-->  eq inv-ifRSStartedThenPRReady(< SetRS,SetPR >)
-->     = ifRSInStatesThenPRInStates(SetRS,started,SetPR,ready) .
--> *************************************************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-ifRSStartedThenPRReady {
  protecting(PROOF)
  var S : State
  eq invK(S) = inv-ifRSStartedThenPRReady(S) .
}

select Proofinv-ifRSStartedThenPRReady
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sRS,sPR >) = true .
}
:apply (rd-) 
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ********************************************
-->  ctrans [R01]:
-->     < (res(TRS,IDRS,initial) SetRS), SetPR >
-->  => < (res(TRS,IDRS,started) SetRS), SetPR > 
-->     if allPROfRSInStates(SetPR,IDRS,ready) .
--> ********************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
}
--> *******************************************************
--> Step 4-2: Split the current case for a rule into cases
-->  where the condition of the rule does or does not hold. 
--> *******************************************************
:def ctf4-2R01 = :ctf {
  eq allPROfRSInStates(sPR,idRS,ready) = true .
}
:apply (ctf4-2R01 rd-)
show proof

--> ****************************************************
-->  trans [R02]:
-->     < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
-->  => < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
--> ****************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
}
:apply (rd-)
show proof
select

--> ***********************************
--> Proof of wfs-allPRHaveRS.
-->  eq wfs-allPRHaveRS(< SetRS,SetPR >)
-->     = allPRHaveRS(SetPR,SetRS) .
--> ***********************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofwfs-allPRHaveRS {
  protecting(PROOF)
  var S : State
  eq invK(S) = wfs-allPRHaveRS(S) .
}

select Proofwfs-allPRHaveRS 
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
-- Since wfs-* is imposed by init(S), init(S) implies wfs-* always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ********************************************
-->  ctrans [R01]:
-->     < (res(TRS,IDRS,initial) SetRS), SetPR >
-->  => < (res(TRS,IDRS,started) SetRS), SetPR > 
-->     if allPROfRSInStates(SetPR,IDRS,ready) .
--> ********************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
}
--> ********************************************************
--> Step 4-2: Split the current case for a rule into cases
-->  where the condition of the rule does or does not hold. 
--> ********************************************************
:def ctf4-2R01 = :ctf {
  eq allPROfRSInStates(sPR,idRS,ready) = true .
}
:apply (ctf4-2R01 rd-)
show proof

--> ****************************************************
-->  trans [R02]:
-->     < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
-->  => < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
--> ****************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
}
:apply (rd-)
show proof
select

--> ***********************************
--> Proof of wfs-allPRHaveRRS.
-->  eq wfs-allPRHaveRRS(< SetRS,SetPR >)
-->     = allPRHaveRRS(SetPR,SetRS) .
--> ***********************************
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofwfs-allPRHaveRRS {
  protecting(PROOF)
  var S : State
  eq invK(S) = wfs-allPRHaveRRS(S) .
}

select Proofwfs-allPRHaveRRS 
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
-- Since wfs-* is imposed by init(S), init(S) implies wfs-* always holds.

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ********************************************
-->  ctrans [R01]:
-->     < (res(TRS,IDRS,initial) SetRS), SetPR >
-->  => < (res(TRS,IDRS,started) SetRS), SetPR > 
-->     if allPROfRSInStates(SetPR,IDRS,ready) .
--> ********************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
}
--> *******************************************************
--> Step 4-2: Split the current case for a rule into cases
-->  where the condition of the rule does or does not hold. 
--> *******************************************************
:def ctf4-2R01 = :ctf {
  eq allPROfRSInStates(sPR,idRS,ready) = true .
}
:apply (ctf4-2R01 rd-)
show proof

--> ****************************************************
-->  trans [R02]:
-->     < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
-->  => < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
--> ****************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
}
:apply (rd-)
show proof
select

--> *************************************
--> Proof of noRSCycle.
--> *************************************j
--> ******************************************
--> Step 3-0: Define a predicate to be proved.
--> ******************************************
module Proofinv-noRSCycle {
  protecting(PROOF)
  var S : State
  eq invK(S) = noRSCycle(S) .
}

select Proofinv-noRSCycle
--> ***************************
--> (3) init(S) implies inv(S).
--> ***************************
--> ***************************************************
--> Step 3-1: Begin with the most general initial case.
--> ***************************************************
:goal {
  eq initinv(< sRS,sPR >) = true .
}
:apply (rd-) 
show proof

--> ***************************
--> (4) inv(S) implies inv(SS).
--> ***************************
--> ********************************************
-->  ctrans [R01]:
-->     < (res(TRS,IDRS,initial) SetRS), SetPR >
-->  => < (res(TRS,IDRS,started) SetRS), SetPR > 
-->     if allPROfRSInStates(SetPR,IDRS,ready) .
--> ********************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRS,initial) sRS), sPR >) = true .
}
--> *******************************************************
--> Step 4-2: Split the current case for a rule into cases
-->  where the condition of the rule does or does not hold. 
--> *******************************************************
:def ctf4-2R01 = :ctf {
  eq allPROfRSInStates(sPR,idRS,ready) = true .
}
:apply (ctf4-2R01 rd-)

:init as subsetDepend-in ( eq subsetDepend(S:State,S':State) = true . )
  by {S:State  <- (< (res(trs,idRS,initial) sRS) , sPR >);
      S':State <- (< (res(trs,idRS,started) sRS) , sPR >); }
:init as SDL-lemma-in [SDL-lemma]
  by {S:State  <- (< (res(trs,idRS,initial) sRS) , sPR >);
      S':State <- (< (res(trs,idRS,started) sRS) , sPR >); }
:apply (rd-)
show proof

--> ****************************************************
-->  trans [R02]:
-->     < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
-->  => < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
--> ****************************************************
--> *************************************************************************
--> Step 4-1: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq invinv(< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
}
:init as subsetDepend-in ( eq subsetDepend(S:State,S':State) = true . )
  by {S:State  <- (< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >);
      S':State <- (< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,ready,idRS,idRRS) sPR) >); }
:init as SDL-lemma-in [SDL-lemma]
  by {S:State  <- (< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >);
      S':State <- (< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,ready,idRS,idRRS) sPR) >); }
:apply (rd-)
show proof
select

