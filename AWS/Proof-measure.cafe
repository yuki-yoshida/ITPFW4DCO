require NatAxiom ../lib/NatAxiom.cafe
require PROOF Proof.cafe

--> *************************************************
--> (3) inv(S) and not final(S) implies m(S) > m(SS).
--> *************************************************

module ProofMeasure {
  protecting(PROOF)
  protecting(NATAXIOM)
}

--> ********************************************
-->  ctrans [R01]:
-->     < (res(TRS,IDRS,initial) SetRS), SetPR >
-->  => < (res(TRS,IDRS,started) SetRS), SetPR > 
-->     if allPROfRSInStates(SetPR,IDRS,ready) .
--> ********************************************
select ProofMeasure .
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (res(trs,idRS,initial) sRS), sPR >) = true .
}
--> ********************************************************
--> Step 3-3: Split the current case for a rule into cases
-->  where the condition of the rule does or does not hold. 
--> ********************************************************
-- The condition of R01 does or does not hold for S.
:def ctf3-3R01 = :ctf {
  eq allPROfRSInStates(sPR,idRS,ready) = true .
}
:apply (ctf3-3R01 rd-)
show proof

--> ****************************************************
-->  trans [R02]:
-->     < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,notready,IDRS,IDRRS) SetPR) >
-->  => < (res(TRS,IDRRS,started) SetRS), 
-->       (prop(TPR,IDPR,ready   ,IDRS,IDRRS) SetPR) > .
--> ****************************************************
--> *************************************************************************
--> Step 3-2: Begin with the cases each of which matches to LHS of each rule.
--> *************************************************************************
:goal {
  eq mesmes(< (res(trs,idRRS,started) sRS), (prop(tpr,idPR,notready,idRS,idRRS) sPR) >) = true .
}
:apply (rd-)
show proof

select
